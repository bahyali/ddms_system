/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/entity-types": {
    get: operations["listEntityTypes"];
    post: operations["createEntityType"];
  };
  "/entity-types/{entityTypeId}": {
    patch: operations["updateEntityType"];
  };
  "/entity-types/{entityTypeId}/fields": {
    get: operations["listFieldDefs"];
    post: operations["createFieldDef"];
  };
  "/entities/{entityTypeKey}": {
    post: operations["createRecord"];
  };
  "/entities/{entityTypeKey}/search": {
    post: operations["searchRecords"];
  };
  "/entities/{entityTypeKey}/{recordId}": {
    get: operations["getRecord"];
    patch: operations["updateRecord"];
  };
  "/fields/{fieldId}": {
    patch: operations["updateFieldDef"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** @description A unique machine-readable key for the entity type (e.g., 'user', 'project'). */
    EntityType: {
      /**
       * Format: uuid
       * @readonly
       */
      id: string;
      /** @description A unique machine-readable key for the entity type (e.g., 'user', 'project'). */
      key: string;
      /** @description A human-readable label for the entity type (e.g., 'User', 'Project'). */
      label: string;
      /** @description A description of the entity type. */
      description?: string | null;
    };
    EntityTypeCreate: {
      /** @description A unique machine-readable key for the entity type (e.g., 'user', 'project'). */
      key: string;
      /** @description A human-readable label for the entity type (e.g., 'User', 'Project'). */
      label: string;
      /** @description A description of the entity type. */
      description?: string | null;
    };
    EntityTypeUpdate: {
      /** @description A human-readable label for the entity type (e.g., 'User', 'Project'). */
      label?: string;
      /** @description A description of the entity type. */
      description?: string | null;
    };
    FieldDef: {
      /**
       * Format: uuid
       * @readonly
       */
      id: string;
      /**
       * Format: uuid
       * @readonly
       */
      entityTypeId: string;
      /** @description A unique machine-readable key for the field (e.g., 'status', 'budget'). */
      key: string;
      /** @description A human-readable label for the field (e.g., 'Status', 'Budget'). */
      label: string;
      /** @enum {string} */
      kind: "text" | "number" | "date" | "select" | "relation" | "boolean";
      /** @default false */
      required?: boolean;
      /** @default false */
      uniqueWithinType?: boolean;
      /** @default true */
      searchable?: boolean;
      /** @default false */
      indexed?: boolean;
      options?: components["schemas"]["FieldDefOptions"];
      validate?: components["schemas"]["FieldDefValidate"];
      acl?: components["schemas"]["FieldDefAcl"];
      /** @default 0 */
      position?: number;
      /** @default true */
      active?: boolean;
    };
    FieldDefCreate: {
      key: string;
      label: string;
      /** @enum {string} */
      kind: "text" | "number" | "date" | "select" | "relation" | "boolean";
      required?: boolean;
      uniqueWithinType?: boolean;
      searchable?: boolean;
      indexed?: boolean;
      options?: components["schemas"]["FieldDefOptions"];
      validate?: components["schemas"]["FieldDefValidate"];
      acl?: components["schemas"]["FieldDefAcl"];
      position?: number;
    };
    FieldDefUpdate: {
      label?: string;
      required?: boolean;
      uniqueWithinType?: boolean;
      searchable?: boolean;
      indexed?: boolean;
      options?: components["schemas"]["FieldDefOptions"];
      validate?: components["schemas"]["FieldDefValidate"];
      acl?: components["schemas"]["FieldDefAcl"];
      position?: number;
      active?: boolean;
    };
    FieldDefOptions: {
      /** @description For kind='select'. A list of possible values. */
      enum?: string[];
      /** @description For kind='select'. Whether multiple values can be selected. */
      multiselect?: boolean;
      /** @description For kind='relation'. Defines the relationship target. */
      relation?: {
        /** Format: uuid */
        targetEntityTypeId: string;
        /** @enum {string} */
        cardinality: "one" | "many";
      };
      /**
       * @description For computed fields. An expression to calculate the field value.
       * @example price * qty
       */
      formula?: string;
      /** @description Conditional visibility rules for the UI. */
      visibleIf?: Record<string, unknown>[];
      /** @description Conditional requirement rules. */
      requiredIf?: Record<string, unknown>[];
    };
    /** @description Validation rules that depend on the field kind. */
    FieldDefValidate: {
      text?: {
        minLen?: number;
        maxLen?: number;
        regex?: string;
      };
      number?: {
        min?: number;
        max?: number;
        integer?: boolean;
      };
      date?: {
        /** Format: date */
        min?: string;
        /** Format: date */
        max?: string;
      };
    };
    /** @description Access control list defining roles for read/write access. */
    FieldDefAcl: {
      read?: string[];
      write?: string[];
    };
    Record: {
      /**
       * Format: uuid
       * @readonly
       */
      id: string;
      /**
       * Format: uuid
       * @readonly
       */
      entityTypeId: string;
      /**
       * @description The version number of the record, used for optimistic locking.
       * @readonly
       */
      version: number;
      /**
       * @description A JSON object containing the custom field data for the record.
       * @example {
       *   "name": "AI Roadmap Q4",
       *   "status": "Active",
       *   "budget": 12000
       * }
       */
      data: Record<string, unknown>;
      /**
       * Format: uuid
       * @readonly
       */
      createdBy?: string | null;
      /**
       * Format: uuid
       * @readonly
       */
      updatedBy?: string | null;
      /**
       * Format: date-time
       * @readonly
       */
      createdAt: string;
      /**
       * Format: date-time
       * @readonly
       */
      updatedAt: string;
    };
    RecordCreate: {
      /** @description A JSON object containing the custom field data for the new record. */
      data: Record<string, unknown>;
    };
    RecordUpdate: {
      /** @description A JSON object containing the fields to update. */
      data: Record<string, unknown>;
      /** @description The current version of the record being updated, for optimistic locking. */
      version: number;
    };
    SearchRequest: {
      filter?: components["schemas"]["Filter"];
      /** @description An array of sort objects to apply to the results. */
      sort?: components["schemas"]["Sort"][];
      /**
       * @description The maximum number of records to return.
       * @default 50
       * @minimum 1
       * @maximum 1000
       */
      limit?: number;
      /** @description A cursor for pagination, obtained from a previous search response. */
      cursor?: string | null;
    };
    SearchResponse: {
      rows: components["schemas"]["Record"][];
      /** @description A cursor to retrieve the next page of results. Null if there are no more results. */
      nextCursor?: string | null;
      /** @description The total number of records matching the filter. */
      total: number;
    };
    Sort: {
      /** @description The key of the field to sort by (e.g., 'budget', 'createdAt'). */
      field: string;
      /**
       * @default asc
       * @enum {string}
       */
      dir?: "asc" | "desc";
    };
    /**
     * @description A flexible filter object to query records. It can be a logical operator (`and`, `or`, `not`) or a field-level comparison.
     * See the manifest for the full grammar.
     * @example {
     *   "op": "and",
     *   "filters": [
     *     {
     *       "op": "eq",
     *       "field": "status",
     *       "value": "Active"
     *     },
     *     {
     *       "op": "gte",
     *       "field": "budget",
     *       "value": 10000
     *     },
     *     {
     *       "op": "fulltext",
     *       "query": "ai roadmap"
     *     }
     *   ]
     * }
     */
    Filter: {
      /** @description The operator for the filter. */
      op?: string;
      /** @description Used with logical operators `and` and `or`. */
      filters?: components["schemas"]["Filter"][];
      /** @description The key of the field to compare. */
      field?: string;
      /** @description The value to compare against. */
      value?: unknown;
      /** @description An array of values for the `in` operator. */
      values?: unknown[];
      /** @description The search query for `fulltext` search. */
      query?: string;
    };
    /** @description Error Schema */
    Error: {
      /**
       * @description A machine-readable error code.
       * @example VALIDATION_ERROR
       */
      code: string;
      /**
       * @description A human-readable error message.
       * @example The request body is invalid.
       */
      message: string;
      /**
       * Format: uuid
       * @description A unique identifier for the request, useful for tracing.
       */
      requestId?: string;
      errors?: components["schemas"]["ValidationErrorDetail"][];
    };
    ValidationErrorDetail: {
      /**
       * @description The path to the invalid field in the request body.
       * @example budget
       */
      path: string;
      /**
       * @description A machine-readable code for the specific validation error.
       * @example too_small
       */
      code: string;
      /**
       * @description A human-readable message for the specific validation error.
       * @example The budget must be at least 0.
       */
      message: string;
    };
  };
  responses: {
    /** @description Bad Request - The request body is invalid. */
    BadRequest: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Not Found - The requested resource does not exist. */
    NotFound: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Conflict - The request could not be completed due to a conflict with the current state of the resource, likely an optimistic locking failure. */
    Conflict: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  parameters: {
    /** @description The ID of the entity type. */
    entityTypeId: string;
    /** @description The unique machine-readable key for the entity type (e.g., 'user', 'project'). */
    entityTypeKey: string;
    /** @description The ID of the record. */
    recordId: string;
    /** @description The ID of the field definition. */
    fieldId: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * List Entity Types
   * @description Retrieves a list of all entity types for the tenant.
   */
  listEntityTypes: {
    responses: {
      /** @description A list of entity types. */
      200: {
        content: {
          "application/json": components["schemas"]["EntityType"][];
        };
      };
    };
  };
  /**
   * Create Entity Type
   * @description Creates a new entity type.
   */
  createEntityType: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["EntityTypeCreate"];
      };
    };
    responses: {
      /** @description Entity type created successfully. */
      201: {
        content: {
          "application/json": components["schemas"]["EntityType"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  /**
   * Update Entity Type
   * @description Updates an existing entity type.
   */
  updateEntityType: {
    parameters: {
      path: {
        entityTypeId: components["parameters"]["entityTypeId"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EntityTypeUpdate"];
      };
    };
    responses: {
      /** @description Entity type updated successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["EntityType"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * List Field Definitions
   * @description Retrieves a list of all field definitions for a given entity type.
   */
  listFieldDefs: {
    parameters: {
      path: {
        entityTypeId: components["parameters"]["entityTypeId"];
      };
    };
    responses: {
      /** @description A list of field definitions. */
      200: {
        content: {
          "application/json": components["schemas"]["FieldDef"][];
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Create Field Definition
   * @description Creates a new field definition for an entity type.
   */
  createFieldDef: {
    parameters: {
      path: {
        entityTypeId: components["parameters"]["entityTypeId"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FieldDefCreate"];
      };
    };
    responses: {
      /** @description Field definition created successfully. */
      201: {
        content: {
          "application/json": components["schemas"]["FieldDef"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Create Record
   * @description Creates a new record for a given entity type.
   */
  createRecord: {
    parameters: {
      path: {
        entityTypeKey: components["parameters"]["entityTypeKey"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordCreate"];
      };
    };
    responses: {
      /** @description Record created successfully. */
      201: {
        content: {
          "application/json": components["schemas"]["Record"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Search Records
   * @description Searches for records of a given entity type using a filter.
   */
  searchRecords: {
    parameters: {
      path: {
        entityTypeKey: components["parameters"]["entityTypeKey"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequest"];
      };
    };
    responses: {
      /** @description A list of matching records. */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponse"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get Record by ID
   * @description Retrieves a single record by its ID.
   */
  getRecord: {
    parameters: {
      path: {
        entityTypeKey: components["parameters"]["entityTypeKey"];
        recordId: components["parameters"]["recordId"];
      };
    };
    responses: {
      /** @description The requested record. */
      200: {
        content: {
          "application/json": components["schemas"]["Record"];
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update Record
   * @description Updates an existing record. Uses optimistic locking via a version number.
   */
  updateRecord: {
    parameters: {
      path: {
        entityTypeKey: components["parameters"]["entityTypeKey"];
        recordId: components["parameters"]["recordId"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordUpdate"];
      };
    };
    responses: {
      /** @description Record updated successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["Record"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /**
   * Update Field Definition
   * @description Updates an existing field definition.
   */
  updateFieldDef: {
    parameters: {
      path: {
        fieldId: components["parameters"]["fieldId"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FieldDefUpdate"];
      };
    };
    responses: {
      /** @description Field definition updated successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["FieldDef"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
}