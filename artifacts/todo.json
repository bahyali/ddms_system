[
    {
        "name": "I1.T1",
        "context": {
            "task_id": "I1.T1",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Initialize the pnpm monorepo workspace with the directory structure defined in Section 3. Set up base TypeScript configurations (`tsconfig.base.json`).",
            "agent_type_hint": "SetupAgent",
            "inputs": "Section 3 (Directory Structure)",
            "target_files": [
                "package.json",
                "pnpm-workspace.yaml",
                "tsconfig.base.json",
                "apps/",
                "packages/"
            ],
            "input_files": [],
            "deliverables": "An initialized monorepo with placeholder `package.json` files in each app/package.",
            "acceptance_criteria": "The directory structure matches the plan. `pnpm install` runs successfully at the root.",
            "dependencies": [],
            "parallelizable": false
        },
        "output": "~~~json\n#- file: package.json\n{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\"\n  }\n}\n~~~\n~~~yaml\n#- file: pnpm-workspace.yaml\npackages:\n  - 'apps/*'\n  - 'packages/*'\n~~~\n~~~json\n#- file: tsconfig.base.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n~~~\n~~~json\n#- file: apps/api/package.json\n{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true\n}\n~~~\n~~~json\n#- file: apps/web/package.json\n{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true\n}\n~~~\n~~~json\n#- file: packages/core/package.json\n{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\"\n}\n~~~\n~~~json\n#- file: packages/db/package.json\n{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\"\n}\n~~~\n~~~json\n#- file: packages/sdk/package.json\n{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\"\n}\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "package.json",
            "pnpm-workspace.yaml",
            "tsconfig.base.json",
            "apps/",
            "packages/"
        ],
        "input_files": [],
        "files": [
            {
                "path": "pnpm-workspace.yaml",
                "content": "packages:\n  - 'apps/*'\n  - 'packages/*'"
            },
            {
                "path": "packages/",
                "content": [
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\"\n}"
                    },
                    {
                        "path": "project/packages/sdk/package.json",
                        "content": "{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\"\n}"
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\"\n}"
                    }
                ]
            },
            {
                "path": "tsconfig.base.json",
                "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\"\n  }\n}"
            },
            {
                "path": "apps/",
                "content": [
                    {
                        "path": "project/apps/web/package.json",
                        "content": "{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true\n}"
                    },
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true\n}"
                    }
                ]
            },
            {
                "path": "pnpm-workspace.yaml",
                "content": "packages:\n  - 'apps/*'\n  - 'packages/*'"
            },
            {
                "path": "packages/",
                "content": [
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export const core = () => 'Hello from @ddms/core';"
                    },
                    {
                        "path": "project/packages/sdk/package.json",
                        "content": "{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/sdk/src/index.ts",
                        "content": "export const sdk = () => 'Hello from @ddms/sdk';"
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export const db = () => 'Hello from @ddms/db';"
                    }
                ]
            },
            {
                "path": "tsconfig.base.json",
                "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"format\": \"prettier --write \\\"**/*.{ts,tsx,md}\\\"\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^7.10.0\",\n    \"@typescript-eslint/parser\": \"^7.10.0\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"prettier\": \"^3.3.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}"
            },
            {
                "path": "apps/",
                "content": [
                    {
                        "path": "project/apps/web/package.json",
                        "content": "{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts,.tsx\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/web/src/index.ts",
                        "content": "// Placeholder for web app entry point"
                    },
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "console.log('Hello from @ddms/api');"
                    }
                ]
            },
            {
                "path": "pnpm-workspace.yaml",
                "content": "packages:\n  - 'apps/*'\n  - 'packages/*'"
            },
            {
                "path": "packages/",
                "content": [
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/core: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export const core = () => 'Hello from @ddms/core';"
                    },
                    {
                        "path": "project/packages/sdk/package.json",
                        "content": "{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/sdk: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/sdk/src/index.ts",
                        "content": "export const sdk = () => 'Hello from @ddms/sdk';"
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export const db = () => 'Hello from @ddms/db';"
                    }
                ]
            },
            {
                "path": "tsconfig.base.json",
                "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"format\": \"prettier --write \\\"**/*.{ts,tsx,md}\\\"\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^7.10.0\",\n    \"@typescript-eslint/parser\": \"^7.10.0\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"prettier\": \"^3.3.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}"
            },
            {
                "path": "apps/",
                "content": [
                    {
                        "path": "project/apps/web/package.json",
                        "content": "{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts,.tsx\",\n    \"test\": \"echo \\\"@ddms/web: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/web/src/index.ts",
                        "content": "// Placeholder for web app entry point"
                    },
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/api: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "console.log('Hello from @ddms/api');"
                    }
                ]
            },
            {
                "path": "pnpm-workspace.yaml",
                "content": "packages:\n  - 'apps/*'\n  - 'packages/*'"
            },
            {
                "path": "packages/",
                "content": [
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/core: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export const core = () => 'Hello from @ddms/core';"
                    },
                    {
                        "path": "project/packages/sdk/package.json",
                        "content": "{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/sdk: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/sdk/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/sdk/src/index.ts",
                        "content": "export const sdk = () => 'Hello from @ddms/sdk';"
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export const db = () => 'Hello from @ddms/db';"
                    }
                ]
            },
            {
                "path": "tsconfig.base.json",
                "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"format\": \"prettier --write \\\"**/*.{ts,tsx,md}\\\"\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^7.10.0\",\n    \"@typescript-eslint/parser\": \"^7.10.0\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"prettier\": \"^3.3.0\",\n    \"tsx\": \"^4.11.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}"
            },
            {
                "path": "apps/",
                "content": [
                    {
                        "path": "project/apps/web/package.json",
                        "content": "{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"echo \\\"@ddms/web: no dev script specified\\\" && exit 0\",\n    \"lint\": \"eslint src --ext .ts,.tsx\",\n    \"test\": \"echo \\\"@ddms/web: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/web/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"noEmit\": true,\n    \"incremental\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\"\n  },\n  \"include\": [\"src\"],\n  \"references\": [\n    { \"path\": \"../../packages/sdk\" }\n  ]\n}"
                    },
                    {
                        "path": "project/apps/web/src/index.ts",
                        "content": "// Placeholder for web app entry point\nconsole.log('Hello from @ddms/web');"
                    },
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"tsx watch src/index.ts\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/api: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/api/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": [\n    { \"path\": \"../../packages/core\" },\n    { \"path\": \"../../packages/db\" },\n    { \"path\": \"../../packages/sdk\" }\n  ]\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "console.log('Hello from @ddms/api');"
                    }
                ]
            }
        ]
    },
    {
        "name": "I1.T2",
        "context": {
            "task_id": "I1.T2",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Set up the `packages/db` package with Drizzle ORM. Define the full database schema in TypeScript based on the DDL provided in the manifest (tables: `tenants`, `entity_types`, `field_defs`, `records`, `edges`, `record_versions`, `audit_log`).",
            "agent_type_hint": "DatabaseAgent",
            "inputs": "Section 6 of the manifest (Data Model DDL)",
            "target_files": [
                "packages/db/src/schema.ts"
            ],
            "input_files": [
                "packages/db/"
            ],
            "deliverables": "A TypeScript file containing the Drizzle schema definitions for all tables.",
            "acceptance_criteria": "The Drizzle schema correctly represents all tables, columns, types, and relations from the manifest's DDL. The code is type-correct.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "I will create a new file `packages/db/src/schema.ts` to define the Drizzle ORM schema based on the provided DDL.\n\nThis involves:\n1.  Importing necessary functions from `drizzle-orm` and `drizzle-orm/pg-core`.\n2.  Defining a `pgEnum` for `field_defs.kind` and a `customType` for `records.fts` (tsvector).\n3.  Translating each SQL `CREATE TABLE` statement into a Drizzle `pgTable` definition, mapping all columns, types, and constraints.\n4.  Adding table-level composite unique constraints where specified.\n5.  Defining all inter-table relationships using the `relations` helper function after all tables are defined, which is crucial for type-safe querying and joins.\n\nThe schema will accurately reflect all tables: `tenants`, `entity_types`, `field_defs`, `records`, `edges`, `record_versions`, and `audit_log`.\n\n~~~typescript\n#- file: packages/db/src/schema.ts\nimport { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));\n~~~\n~~~edits\n#- file: packages/db/src/index.ts\n***start_edit\nLITERAL\n***search\nexport const db = () => 'Hello from @ddms/db';\n***replace\nexport * from './schema';\n***description\nExport the newly created schema from the main index file of the @ddms/db package. This makes the schema objects available for other packages to import.\n***end_edit\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "packages/db/src/schema.ts"
        ],
        "input_files": [
            "packages/db/"
        ],
        "files": [
            {
                "path": "packages/db/",
                "content": [
                    {
                        "path": "project/packages/db/migrations/.gitkeep",
                        "content": ""
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export const db = () => 'Hello from @ddms/db';"
                    }
                ]
            },
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            },
            {
                "path": "packages/db/",
                "content": [
                    {
                        "path": "project/packages/db/migrations/.gitkeep",
                        "content": ""
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/db/src/schema.ts",
                        "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export * from './schema';"
                    }
                ]
            }
        ]
    },
    {
        "name": "I1.T3",
        "context": {
            "task_id": "I1.T3",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Generate the initial SQL migration files from the Drizzle schema defined in `I1.T2`.",
            "agent_type_hint": "DatabaseAgent",
            "inputs": "Drizzle schema from `I1.T2`.",
            "target_files": [
                "packages/db/migrations/0000_*.sql"
            ],
            "input_files": [
                "packages/db/src/schema.ts"
            ],
            "deliverables": "SQL migration files.",
            "acceptance_criteria": "The generated migration files accurately reflect the schema and can be applied to a clean PostgreSQL database without errors.",
            "dependencies": [
                "I1.T2"
            ],
            "parallelizable": false
        },
        "output": "This task requires generating the initial SQL migration file from the Drizzle schema. This is typically an automated process using `drizzle-kit`. I will replicate the output of this tool by analyzing the provided `packages/db/src/schema.ts` file and constructing the corresponding SQL DDL statements.\n\nThe migration will include:\n1.  Creation of the custom `field_kind` enum type.\n2.  Creation of all seven tables: `tenants`, `entity_types`, `field_defs`, `records`, `edges`, `record_versions`, and `audit_log`, with their respective columns, constraints, and default values.\n3.  Addition of all foreign key constraints with the specified `ON DELETE CASCADE` behavior.\n\nThe resulting SQL file will be placed in the `packages/db/migrations/` directory, following the naming convention `0000_*.sql`.\n\n~~~\n#- file: packages/db/migrations/0000_curvy_mysterio.sql\nCREATE TYPE \"field_kind\" AS ENUM('text', 'number', 'date', 'select', 'relation', 'boolean');\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"audit_log\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"actor_id\" uuid,\n\t\"action\" text NOT NULL,\n\t\"resource_type\" text NOT NULL,\n\t\"resource_id\" uuid,\n\t\"meta\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"edges\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"field_id\" uuid NOT NULL,\n\t\"from_record_id\" uuid NOT NULL,\n\t\"to_record_id\" uuid NOT NULL,\n\t\"created_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\tCONSTRAINT \"edges_tenant_id_field_id_from_record_id_to_record_id_unique\" UNIQUE(\"tenant_id\",\"field_id\",\"from_record_id\",\"to_record_id\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"entity_types\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"description\" text,\n\tCONSTRAINT \"entity_types_tenant_id_key_unique\" UNIQUE(\"tenant_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"field_defs\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"kind\" \"field_kind\" NOT NULL,\n\t\"required\" boolean DEFAULT false NOT NULL,\n\t\"unique_within_type\" boolean DEFAULT false NOT NULL,\n\t\"searchable\" boolean DEFAULT true NOT NULL,\n\t\"indexed\" boolean DEFAULT false NOT NULL,\n\t\"options\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"validate\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"acl\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"position\" integer DEFAULT 0 NOT NULL,\n\t\"active\" boolean DEFAULT true NOT NULL,\n\tCONSTRAINT \"field_defs_tenant_id_entity_type_id_key_unique\" UNIQUE(\"tenant_id\",\"entity_type_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"record_versions\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"record_id\" uuid NOT NULL,\n\t\"version\" integer NOT NULL,\n\t\"data\" jsonb NOT NULL,\n\t\"changed_by\" uuid,\n\t\"changed_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"records\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"data\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"fts\" tsvector,\n\t\"version\" integer DEFAULT 1 NOT NULL,\n\t\"created_by\" uuid,\n\t\"updated_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"tenants\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"name\" text NOT NULL,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_field_id_field_defs_id_fk\" FOREIGN KEY (\"field_id\") REFERENCES \"public\".\"field_defs\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_from_record_id_records_id_fk\" FOREIGN KEY (\"from_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_to_record_id_records_id_fk\" FOREIGN KEY (\"to_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"entity_types\" ADD CONSTRAINT \"entity_types_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"record_versions\" ADD CONSTRAINT \"record_versions_record_id_records_id_fk\" FOREIGN KEY (\"record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "packages/db/migrations/0000_*.sql"
        ],
        "input_files": [
            "packages/db/src/schema.ts"
        ],
        "files": [
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            },
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            }
        ]
    },
    {
        "name": "I1.T4",
        "context": {
            "task_id": "I1.T4",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Create a `docker-compose.yml` file in the `infra/` directory to run a PostgreSQL 14+ instance for local development, including volume for data persistence.",
            "agent_type_hint": "SetupAgent",
            "inputs": "Section 5 of the manifest (Stack details)",
            "target_files": [
                "infra/docker-compose.yml"
            ],
            "input_files": [],
            "deliverables": "A functional `docker-compose.yml` file.",
            "acceptance_criteria": "`docker-compose up` successfully starts a PostgreSQL container.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "I will create the `infra/docker-compose.yml` file as requested. This file will define a PostgreSQL service using the official `postgres:14` image, configure it with environment variables for the user, password, and database name, map the standard PostgreSQL port `5432` to the host machine, and set up a named volume for data persistence.\n\n~~~yaml\n#- file: infra/docker-compose.yml\nversion: '3.8'\n\nservices:\n  db:\n    image: postgres:14\n    container_name: zentio-db\n    restart: unless-stopped\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: zentio_db\n    ports:\n      - '5432:5432'\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n    driver: local\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "infra/docker-compose.yml"
        ],
        "input_files": [],
        "files": [
            {
                "path": "infra/docker-compose.yml",
                "content": "version: '3.8'\n\nservices:\n  db:\n    image: postgres:14\n    container_name: zentio-db\n    restart: unless-stopped\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: zentio_db\n    ports:\n      - '5432:5432'\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n    driver: local"
            }
        ]
    },
    {
        "name": "I1.T5",
        "context": {
            "task_id": "I1.T5",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Generate a PlantUML Component Diagram for the Backend API based on the components described in Section 2 of this plan and Section 3.5 of the manifest's architecture blueprint.",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Section 2 (Core Architecture), Manifest Architecture Blueprint (Section 3.5)",
            "target_files": [
                "docs/diagrams/backend_component_diagram.puml"
            ],
            "input_files": [],
            "deliverables": "A PlantUML source file for the component diagram.",
            "acceptance_criteria": "The diagram accurately visualizes the REST Controllers, Authorization Service, Validation Engine, Filter Compiler, Core Services, Index Manager, SSE Broadcaster, and DAL. The file renders correctly.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "I will now generate the PlantUML component diagram for the Backend API. The task is to create a new file, `docs/diagrams/backend_component_diagram.puml`, and populate it with the PlantUML code that describes the internal components of the API server.\n\nThe design artifacts, specifically Section 3.5 of the manifest's architecture blueprint, provide a complete and accurate PlantUML definition for this diagram. I will use that as the source for the file's content. This will ensure all acceptance criteria are met, including the visualization of all required components and their relationships.\n\n~~~puml\n#- file: docs/diagrams/backend_component_diagram.puml\n@startuml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml\n\ntitle Component Diagram for Backend API\n\nContainer(api, \"Backend API\", \"Node.js, Fastify\") {\n    Component(rest_controller, \"REST API Controllers\", \"Fastify Routes\", \"Exposes OpenAPI endpoints, handles HTTP requests/responses.\")\n    Component(authz, \"Authorization Service\", \"TypeScript Module\", \"Enforces RBAC and per-field ACLs on incoming requests.\")\n    Component(validation_engine, \"Validation Engine\", \"TypeScript Module\", \"Dynamically builds and memoizes Zod schemas from Field Definitions.\")\n    Component(filter_compiler, \"Filter DSL Compiler\", \"TypeScript Module\", \"Parses JSON filter DSL and compiles it into parameterized SQL queries.\")\n    Component(core_services, \"Core Business Logic\", \"TypeScript Modules\", \"Implements logic for managing records, fields, bulk operations, etc.\")\n    Component(index_manager, \"Index Manager\", \"TypeScript Module\", \"Manages creation of on-demand expression indexes concurrently.\")\n    Component(sse_broadcaster, \"SSE Broadcaster\", \"TypeScript Module\", \"Listens for Postgres NOTIFY events and pushes them to connected SSE clients.\")\n    Component(dal, \"Data Access Layer\", \"Drizzle ORM\", \"Provides a type-safe interface to the database.\")\n}\n\nContainerDb(db, \"Database\", \"PostgreSQL\", \"Stores all system data.\")\n\nRel(rest_controller, authz, \"Uses\", \"For checking permissions\")\nRel(rest_controller, validation_engine, \"Uses\", \"For validating request bodies\")\nRel(rest_controller, core_services, \"Delegates to\", \"For business operations\")\nRel(rest_controller, filter_compiler, \"Uses\", \"For search requests\")\nRel(rest_controller, sse_broadcaster, \"Uses\", \"To handle SSE connections\")\n\nRel(core_services, dal, \"Uses\", \"To access data\")\nRel(filter_compiler, dal, \"Generates SQL for\")\nRel(index_manager, dal, \"Executes CREATE INDEX on\")\n\nRel(dal, db, \"Reads/Writes data\", \"SQL/TCP\")\nRel_Back(sse_broadcaster, db, \"Subscribes to events\", \"LISTEN/NOTIFY\")\n\n@enduml\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "docs/diagrams/backend_component_diagram.puml"
        ],
        "input_files": [],
        "files": [
            {
                "path": "docs/diagrams/backend_component_diagram.puml",
                "content": "@startuml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml\n\ntitle Component Diagram for Backend API\n\nContainer(api, \"Backend API\", \"Node.js, Fastify\") {\n    Component(rest_controller, \"REST API Controllers\", \"Fastify Routes\", \"Exposes OpenAPI endpoints, handles HTTP requests/responses.\")\n    Component(authz, \"Authorization Service\", \"TypeScript Module\", \"Enforces RBAC and per-field ACLs on incoming requests.\")\n    Component(validation_engine, \"Validation Engine\", \"TypeScript Module\", \"Dynamically builds and memoizes Zod schemas from Field Definitions.\")\n    Component(filter_compiler, \"Filter DSL Compiler\", \"TypeScript Module\", \"Parses JSON filter DSL and compiles it into parameterized SQL queries.\")\n    Component(core_services, \"Core Business Logic\", \"TypeScript Modules\", \"Implements logic for managing records, fields, bulk operations, etc.\")\n    Component(index_manager, \"Index Manager\", \"TypeScript Module\", \"Manages creation of on-demand expression indexes concurrently.\")\n    Component(sse_broadcaster, \"SSE Broadcaster\", \"TypeScript Module\", \"Listens for Postgres NOTIFY events and pushes them to connected SSE clients.\")\n    Component(dal, \"Data Access Layer\", \"Drizzle ORM\", \"Provides a type-safe interface to the database.\")\n}\n\nContainerDb(db, \"Database\", \"PostgreSQL\", \"Stores all system data.\")\n\nRel(rest_controller, authz, \"Uses\", \"For checking permissions\")\nRel(rest_controller, validation_engine, \"Uses\", \"For validating request bodies\")\nRel(rest_controller, core_services, \"Delegates to\", \"For business operations\")\nRel(rest_controller, filter_compiler, \"Uses\", \"For search requests\")\nRel(rest_controller, sse_broadcaster, \"Uses\", \"To handle SSE connections\")\n\nRel(core_services, dal, \"Uses\", \"To access data\")\nRel(filter_compiler, dal, \"Generates SQL for\")\nRel(index_manager, dal, \"Executes CREATE INDEX on\")\n\nRel(dal, db, \"Reads/Writes data\", \"SQL/TCP\")\nRel_Back(sse_broadcaster, db, \"Subscribes to events\", \"LISTEN/NOTIFY\")\n\n@enduml"
            }
        ]
    },
    {
        "name": "I1.T6",
        "context": {
            "task_id": "I1.T6",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Generate a Mermaid ERD for the database schema based on the DDL in Section 6 of the manifest.",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Section 6 of the manifest (Data Model DDL)",
            "target_files": [
                "docs/diagrams/database_erd.md"
            ],
            "input_files": [],
            "deliverables": "A Markdown file containing the Mermaid syntax for the ERD.",
            "acceptance_criteria": "The ERD correctly shows all entities and their relationships as defined in the schema. The Mermaid syntax is valid.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "~~~\n#- file: docs/diagrams/database_erd.md\n# Database Entity Relationship Diagram\n\nThis diagram visualizes the database schema for the Dynamic Data Management System, showing all tables and their relationships.\n\n```mermaid\nerDiagram\n    tenants {\n        uuid id PK \"Primary Key\"\n        text name \"Tenant's name\"\n    }\n\n    entity_types {\n        uuid id PK\n        uuid tenant_id FK\n        text key \"e.g., 'user', 'project'\"\n        text label \"e.g., 'User', 'Project'\"\n    }\n\n    field_defs {\n        uuid id PK\n        uuid tenant_id FK\n        uuid entity_type_id FK\n        text key \"e.g., 'status', 'budget'\"\n        text kind \"e.g., 'text', 'relation'\"\n    }\n\n    records {\n        uuid id PK\n        uuid tenant_id FK\n        uuid entity_type_id FK\n        jsonb data \"Property bag for custom fields\"\n        integer version \"For optimistic concurrency\"\n    }\n\n    edges {\n        uuid id PK\n        uuid tenant_id FK\n        uuid field_id FK \"Must be kind='relation'\"\n        uuid from_record_id FK \"Source of the relationship\"\n        uuid to_record_id FK \"Target of the relationship\"\n    }\n\n    record_versions {\n        bigserial id PK\n        uuid record_id FK\n        integer version \"Version number\"\n        jsonb data \"Snapshot of record data\"\n    }\n\n    audit_log {\n        bigserial id PK\n        uuid tenant_id FK\n        text action \"e.g., 'UPDATE_RECORD'\"\n        text resource_type\n        uuid resource_id\n    }\n\n    tenants ||--o{ entity_types : \"owns\"\n    tenants ||--o{ field_defs : \"owns\"\n    tenants ||--o{ records : \"owns\"\n    tenants ||--o{ edges : \"owns\"\n    tenants ||--o{ audit_log : \"owns\"\n\n    entity_types ||--o{ field_defs : \"has\"\n    entity_types ||--o{ records : \"has instances of\"\n\n    records ||--o{ record_versions : \"has versions\"\n    \n    field_defs ||--o{ edges : \"defines\"\n\n    records }o--|| edges : \"is source of (from)\"\n    records }o--|| edges : \"is target of (to)\"\n```\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "docs/diagrams/database_erd.md"
        ],
        "input_files": [],
        "files": [
            {
                "path": "docs/diagrams/database_erd.md",
                "content": "# Database Entity Relationship Diagram\n\nThis diagram visualizes the database schema for the Dynamic Data Management System, showing all tables and their relationships.\n\n```mermaid\nerDiagram\n    tenants {\n        uuid id PK \"Primary Key\"\n        text name \"Tenant's name\"\n    }\n\n    entity_types {\n        uuid id PK\n        uuid tenant_id FK\n        text key \"e.g., 'user', 'project'\"\n        text label \"e.g., 'User', 'Project'\"\n    }\n\n    field_defs {\n        uuid id PK\n        uuid tenant_id FK\n        uuid entity_type_id FK\n        text key \"e.g., 'status', 'budget'\"\n        text kind \"e.g., 'text', 'relation'\"\n    }\n\n    records {\n        uuid id PK\n        uuid tenant_id FK\n        uuid entity_type_id FK\n        jsonb data \"Property bag for custom fields\"\n        integer version \"For optimistic concurrency\"\n    }\n\n    edges {\n        uuid id PK\n        uuid tenant_id FK\n        uuid field_id FK \"Must be kind='relation'\"\n        uuid from_record_id FK \"Source of the relationship\"\n        uuid to_record_id FK \"Target of the relationship\"\n    }\n\n    record_versions {\n        bigserial id PK\n        uuid record_id FK\n        integer version \"Version number\"\n        jsonb data \"Snapshot of record data\"\n    }\n\n    audit_log {\n        bigserial id PK\n        uuid tenant_id FK\n        text action \"e.g., 'UPDATE_RECORD'\"\n        text resource_type\n        uuid resource_id\n    }\n\n    tenants ||--o{ entity_types : \"owns\"\n    tenants ||--o{ field_defs : \"owns\"\n    tenants ||--o{ records : \"owns\"\n    tenants ||--o{ edges : \"owns\"\n    tenants ||--o{ audit_log : \"owns\"\n\n    entity_types ||--o{ field_defs : \"has\"\n    entity_types ||--o{ records : \"has instances of\"\n\n    records ||--o{ record_versions : \"has versions\"\n    \n    field_defs ||--o{ edges : \"defines\"\n\n    records }o--|| edges : \"is source of (from)\"\n    records }o--|| edges : \"is target of (to)\"\n```"
            }
        ]
    },
    {
        "name": "I1.T7",
        "context": {
            "task_id": "I1.T7",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Generate a PlantUML Sequence Diagram for the \"Record Search\" flow, as described in Section 3.7 of the manifest's architecture blueprint.",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Manifest Architecture Blueprint (Section 3.7)",
            "target_files": [
                "docs/diagrams/record_search_sequence.puml"
            ],
            "input_files": [],
            "deliverables": "A PlantUML source file for the sequence diagram.",
            "acceptance_criteria": "The diagram accurately depicts the interaction between User, Frontend, API, Filter Compiler, DAL, and Database. The file renders correctly.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "~~~\n#- file: docs/diagrams/record_search_sequence.puml\n@startuml\ntitle Sequence Diagram: Record Search\n\nactor User\nparticipant \"Frontend App\" as FE\nparticipant \"Backend API\" as API\nparticipant \"Filter Compiler\" as Compiler\nparticipant \"Data Access Layer\" as DAL\ndatabase \"PostgreSQL DB\" as DB\n\nUser -> FE : Builds filter criteria in UI\nFE -> API : POST /entities/:type/search\\n(Filter DSL JSON)\n\nactivate API\nAPI -> Compiler : Compile(filterDSL)\nactivate Compiler\nCompiler --> API : Returns { sql: \"...\", params: [...] }\ndeactivate Compiler\n\nAPI -> DAL : findRecords(sql, params)\nactivate DAL\nDAL -> DB : Executes parameterized SQL query\nactivate DB\nDB --> DAL : Returns matching record rows\ndeactivate DB\nDAL --> API : Returns records\ndeactivate DAL\n\nAPI --> FE : 200 OK\\n{ rows: [...], nextCursor: ... }\ndeactivate API\nFE -> User : Displays filtered records in table\n\n@enduml\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "docs/diagrams/record_search_sequence.puml"
        ],
        "input_files": [],
        "files": [
            {
                "path": "docs/diagrams/record_search_sequence.puml",
                "content": "@startuml\ntitle Sequence Diagram: Record Search\n\nactor User\nparticipant \"Frontend App\" as FE\nparticipant \"Backend API\" as API\nparticipant \"Filter Compiler\" as Compiler\nparticipant \"Data Access Layer\" as DAL\ndatabase \"PostgreSQL DB\" as DB\n\nUser -> FE : Builds filter criteria in UI\nFE -> API : POST /entities/:type/search\\n(Filter DSL JSON)\n\nactivate API\nAPI -> Compiler : Compile(filterDSL)\nactivate Compiler\nCompiler --> API : Returns { sql: \"...\", params: [...] }\ndeactivate Compiler\n\nAPI -> DAL : findRecords(sql, params)\nactivate DAL\nDAL -> DB : Executes parameterized SQL query\nactivate DB\nDB --> DAL : Returns matching record rows\ndeactivate DB\nDAL --> API : Returns records\ndeactivate DAL\n\nAPI --> FE : 200 OK\\n{ rows: [...], nextCursor: ... }\ndeactivate API\nFE -> User : Displays filtered records in table\n\n@enduml"
            }
        ]
    },
    {
        "name": "I2.T1",
        "context": {
            "task_id": "I2.T1",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Scaffold the Fastify API server in `apps/api`. Include basic setup for routing, plugins (e.g., CORS), structured logging (Pino), and database connection using Drizzle.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 2 (Technology Stack)",
            "target_files": [
                "apps/api/src/server.ts",
                "apps/api/src/plugins/",
                "apps/api/src/routes/"
            ],
            "input_files": [
                "apps/api/",
                "packages/db/"
            ],
            "deliverables": "A runnable Fastify server that can connect to the database.",
            "acceptance_criteria": "The server starts without errors. A basic health check endpoint (`/health`) returns 200 OK.",
            "dependencies": [
                "I1.T2",
                "I1.T4"
            ],
            "parallelizable": false
        },
        "output": "I will now proceed with scaffolding the Fastify API server as per the instructions. This involves adding necessary dependencies, creating a structured server with plugins for database connectivity and routes for a health check, and setting up the main application entry point to run the server.\n\nFirst, I will update `apps/api/package.json` to include the required dependencies for Fastify, CORS, environment variables, and development logging.\n\n~~~edits\n#- file: apps/api/package.json\n***start_edit\nLITERAL\n***search\n\"dependencies\": {\n    \"@ddms/core\": \"workspace:*\",\n    \"@ddms/db\": \"workspace:*\",\n    \"@ddms/sdk\": \"workspace:*\"\n  }\n***replace\n\"dependencies\": {\n    \"@ddms/core\": \"workspace:*\",\n    \"@ddms/db\": \"workspace:*\",\n    \"@ddms/sdk\": \"workspace:*\",\n    \"@fastify/cors\": \"^9.0.1\",\n    \"dotenv\": \"^16.4.5\",\n    \"fastify\": \"^4.28.0\"\n  },\n  \"devDependencies\": {\n    \"pino-pretty\": \"^11.2.1\"\n  }\n***description\nAdd Fastify, CORS, dotenv, and pino-pretty dependencies for the API server setup.\n***end_edit\n~~~\n\nNext, I will create the database plugin. This plugin will manage the Drizzle ORM connection and make it available throughout the application.\n\n~~~typescript\n#- file: apps/api/src/plugins/db.ts\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport fp from 'fastify-plugin';\nimport { Pool } from 'pg';\nimport * as schema from '@ddms/db';\n\n// Augment FastifyInstance with the db decorator\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    db: ReturnType<typeof drizzle<typeof schema>>;\n  }\n}\n\n/**\n * This plugin creates a Drizzle instance and decorates the Fastify instance with it.\n * It also handles graceful shutdown of the database connection pool.\n */\nexport default fp(async function (fastify) {\n  if (!process.env.DATABASE_URL) {\n    fastify.log.error('DATABASE_URL environment variable is not set.');\n    throw new Error('DATABASE_URL is not set');\n  }\n\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n  });\n\n  const db = drizzle(pool, { schema });\n\n  fastify.decorate('db', db);\n\n  fastify.addHook('onClose', async (instance) => {\n    instance.log.info('Closing database connection pool...');\n    await pool.end();\n    instance.log.info('Database connection pool closed.');\n  });\n});\n~~~\n\nNow, I will create the health check route, which is a simple endpoint to verify that the server is running.\n\n~~~typescript\n#- file: apps/api/src/routes/health.ts\nimport { FastifyInstance } from 'fastify';\n\n/**\n * Registers a health check route.\n * @param fastify The Fastify instance.\n */\nexport default async function (fastify: FastifyInstance) {\n  fastify.get('/health', async (_request, reply) => {\n    // In a real application, you might also check database connectivity here.\n    // For now, just returning a 200 OK is sufficient.\n    return reply.code(200).send({ status: 'ok' });\n  });\n}\n~~~\n\nWith the plugin and route in place, I will create the server factory. This file assembles the Fastify server, registers plugins, and sets up logging.\n\n~~~typescript\n#- file: apps/api/src/server.ts\nimport fastify from 'fastify';\nimport cors from '@fastify/cors';\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\n\nexport async function buildServer() {\n  const server = fastify({\n    logger: {\n      transport:\n        process.env.NODE_ENV !== 'production'\n          ? {\n              target: 'pino-pretty',\n            }\n          : undefined,\n    },\n  });\n\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(healthRoutes);\n\n  return server;\n}\n~~~\n\nFinally, I will replace the content of `apps/api/src/index.ts` to create the application's main entry point. This script will build and start the server, listen for connections, and handle graceful shutdown.\n\n~~~typescript\n#- file: apps/api/src/index.ts\nimport 'dotenv/config';\nimport { buildServer } from './server';\n\nasync function main() {\n  const server = await buildServer();\n\n  try {\n    const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 3001;\n    if (isNaN(port)) {\n      server.log.error('Invalid PORT environment variable');\n      process.exit(1);\n    }\n    const host = process.env.HOST || '0.0.0.0';\n\n    await server.listen({ port, host });\n\n    server.log.info(`Server listening at http://${host}:${port}`);\n\n    const signals: NodeJS.Signals[] = ['SIGINT', 'SIGTERM'];\n    for (const signal of signals) {\n      process.on(signal, async () => {\n        try {\n          server.log.info(`Received ${signal}, shutting down gracefully...`);\n          await server.close();\n          server.log.info('Server shut down successfully.');\n          process.exit(0);\n        } catch (err) {\n          server.log.error({ err }, 'Error during server shutdown.');\n          process.exit(1);\n        }\n      });\n    }\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n}\n\nmain();\n~~~",
        "iteration_id": "I2",
        "completed": true,
        "target_files": [
            "apps/api/src/server.ts",
            "apps/api/src/plugins/",
            "apps/api/src/routes/"
        ],
        "input_files": [
            "apps/api/",
            "packages/db/"
        ],
        "files": [
            {
                "path": "apps/api/",
                "content": [
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"tsx watch src/index.ts\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/api: no test specified\\\" && exit 0\"\n  },\n  \"dependencies\": {\n    \"@ddms/core\": \"workspace:*\",\n    \"@ddms/db\": \"workspace:*\",\n    \"@ddms/sdk\": \"workspace:*\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/api/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": [\n    { \"path\": \"../../packages/core\" },\n    { \"path\": \"../../packages/db\" },\n    { \"path\": \"../../packages/sdk\" }\n  ]\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "console.log('Hello from @ddms/api');"
                    }
                ]
            },
            {
                "path": "packages/db/",
                "content": [
                    {
                        "path": "project/packages/db/migrations/0000_curvy_mysterio.sql",
                        "content": "CREATE TYPE \"field_kind\" AS ENUM('text', 'number', 'date', 'select', 'relation', 'boolean');\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"audit_log\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"actor_id\" uuid,\n\t\"action\" text NOT NULL,\n\t\"resource_type\" text NOT NULL,\n\t\"resource_id\" uuid,\n\t\"meta\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"edges\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"field_id\" uuid NOT NULL,\n\t\"from_record_id\" uuid NOT NULL,\n\t\"to_record_id\" uuid NOT NULL,\n\t\"created_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\tCONSTRAINT \"edges_tenant_id_field_id_from_record_id_to_record_id_unique\" UNIQUE(\"tenant_id\",\"field_id\",\"from_record_id\",\"to_record_id\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"entity_types\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"description\" text,\n\tCONSTRAINT \"entity_types_tenant_id_key_unique\" UNIQUE(\"tenant_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"field_defs\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"kind\" \"field_kind\" NOT NULL,\n\t\"required\" boolean DEFAULT false NOT NULL,\n\t\"unique_within_type\" boolean DEFAULT false NOT NULL,\n\t\"searchable\" boolean DEFAULT true NOT NULL,\n\t\"indexed\" boolean DEFAULT false NOT NULL,\n\t\"options\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"validate\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"acl\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"position\" integer DEFAULT 0 NOT NULL,\n\t\"active\" boolean DEFAULT true NOT NULL,\n\tCONSTRAINT \"field_defs_tenant_id_entity_type_id_key_unique\" UNIQUE(\"tenant_id\",\"entity_type_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"record_versions\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"record_id\" uuid NOT NULL,\n\t\"version\" integer NOT NULL,\n\t\"data\" jsonb NOT NULL,\n\t\"changed_by\" uuid,\n\t\"changed_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"records\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"data\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"fts\" tsvector,\n\t\"version\" integer DEFAULT 1 NOT NULL,\n\t\"created_by\" uuid,\n\t\"updated_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"tenants\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"name\" text NOT NULL,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_field_id_field_defs_id_fk\" FOREIGN KEY (\"field_id\") REFERENCES \"public\".\"field_defs\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_from_record_id_records_id_fk\" FOREIGN KEY (\"from_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_to_record_id_records_id_fk\" FOREIGN KEY (\"to_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"entity_types\" ADD CONSTRAINT \"entity_types_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"record_versions\" ADD CONSTRAINT \"record_versions_record_id_records_id_fk\" FOREIGN KEY (\"record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"audit_log\" ADD CONSTRAINT \"audit_log_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;"
                    },
                    {
                        "path": "project/packages/db/migrations/.gitkeep",
                        "content": ""
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\",\n    \"db:generate\": \"drizzle-kit generate\"\n  },\n  \"dependencies\": {\n    \"drizzle-orm\": \"^0.31.2\",\n    \"pg\": \"^8.12.0\"\n  },\n  \"devDependencies\": {\n    \"@types/pg\": \"^8.11.6\",\n    \"drizzle-kit\": \"^0.22.7\",\n    \"dotenv\": \"^16.4.5\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/db/.env.example",
                        "content": "DATABASE_URL=\"postgresql://user:password@localhost:5432/ddms\""
                    },
                    {
                        "path": "project/packages/db/drizzle.config.ts",
                        "content": "import 'dotenv/config';\nimport { defineConfig } from 'drizzle-kit';\n\nif (!process.env.DATABASE_URL) {\n  throw new Error('DATABASE_URL is not set in environment variables');\n}\n\nexport default defineConfig({\n  schema: './src/schema.ts',\n  out: './migrations',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n  verbose: true,\n  strict: true,\n});"
                    },
                    {
                        "path": "project/packages/db/src/schema.ts",
                        "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export * from './schema';"
                    }
                ]
            },
            {
                "path": "apps/api/src/routes/",
                "content": [
                    {
                        "path": "project/apps/api/src/routes/health.ts",
                        "content": "import { FastifyInstance } from 'fastify';\n\n/**\n * Registers a health check route.\n * @param fastify The Fastify instance.\n */\nexport default async function (fastify: FastifyInstance) {\n  fastify.get('/health', async (_request, reply) => {\n    // In a real application, you might also check database connectivity here.\n    // For now, just returning a 200 OK is sufficient.\n    return reply.code(200).send({ status: 'ok' });\n  });\n}"
                    }
                ]
            },
            {
                "path": "apps/api/",
                "content": [
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"tsx watch src/index.ts\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/api: no test specified\\\" && exit 0\"\n  },\n  \"dependencies\": {\n    \"@ddms/core\": \"workspace:*\",\n    \"@ddms/db\": \"workspace:*\",\n    \"@ddms/sdk\": \"workspace:*\",\n    \"@fastify/cors\": \"^9.0.1\",\n    \"dotenv\": \"^16.4.5\",\n    \"fastify\": \"^4.28.0\"\n  },\n  \"devDependencies\": {\n    \"pino-pretty\": \"^11.2.1\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/api/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": [\n    { \"path\": \"../../packages/core\" },\n    { \"path\": \"../../packages/db\" },\n    { \"path\": \"../../packages/sdk\" }\n  ]\n}"
                    },
                    {
                        "path": "project/apps/api/src/plugins/db.ts",
                        "content": "import { drizzle } from 'drizzle-orm/node-postgres';\nimport fp from 'fastify-plugin';\nimport { Pool } from 'pg';\nimport * as schema from '@ddms/db';\n\n// Augment FastifyInstance with the db decorator\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    db: ReturnType<typeof drizzle<typeof schema>>;\n  }\n}\n\n/**\n * This plugin creates a Drizzle instance and decorates the Fastify instance with it.\n * It also handles graceful shutdown of the database connection pool.\n */\nexport default fp(async function (fastify) {\n  if (!process.env.DATABASE_URL) {\n    fastify.log.error('DATABASE_URL environment variable is not set.');\n    throw new Error('DATABASE_URL is not set');\n  }\n\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n  });\n\n  const db = drizzle(pool, { schema });\n\n  fastify.decorate('db', db);\n\n  fastify.addHook('onClose', async (instance) => {\n    instance.log.info('Closing database connection pool...');\n    await pool.end();\n    instance.log.info('Database connection pool closed.');\n  });\n});"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "import 'dotenv/config';\nimport { buildServer } from './server';\n\nasync function main() {\n  const server = await buildServer();\n\n  try {\n    const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 3001;\n    if (isNaN(port)) {\n      server.log.error('Invalid PORT environment variable');\n      process.exit(1);\n    }\n    const host = process.env.HOST || '0.0.0.0';\n\n    await server.listen({ port, host });\n\n    server.log.info(`Server listening at http://${host}:${port}`);\n\n    const signals: NodeJS.Signals[] = ['SIGINT', 'SIGTERM'];\n    for (const signal of signals) {\n      process.on(signal, async () => {\n        try {\n          server.log.info(`Received ${signal}, shutting down gracefully...`);\n          await server.close();\n          server.log.info('Server shut down successfully.');\n          process.exit(0);\n        } catch (err) {\n          server.log.error({ err }, 'Error during server shutdown.');\n          process.exit(1);\n        }\n      });\n    }\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n}\n\nmain();"
                    },
                    {
                        "path": "project/apps/api/src/server.ts",
                        "content": "import fastify from 'fastify';\nimport cors from '@fastify/cors';\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\n\nexport async function buildServer() {\n  const server = fastify({\n    logger: {\n      transport:\n        process.env.NODE_ENV !== 'production'\n          ? {\n              target: 'pino-pretty',\n            }\n          : undefined,\n    },\n  });\n\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(healthRoutes);\n\n  return server;\n}"
                    },
                    {
                        "path": "project/apps/api/src/routes/health.ts",
                        "content": "import { FastifyInstance } from 'fastify';\n\n/**\n * Registers a health check route.\n * @param fastify The Fastify instance.\n */\nexport default async function (fastify: FastifyInstance) {\n  fastify.get('/health', async (_request, reply) => {\n    // In a real application, you might also check database connectivity here.\n    // For now, just returning a 200 OK is sufficient.\n    return reply.code(200).send({ status: 'ok' });\n  });\n}"
                    }
                ]
            },
            {
                "path": "apps/api/src/server.ts",
                "content": "import fastify from 'fastify';\nimport cors from '@fastify/cors';\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\n\nexport async function buildServer() {\n  const server = fastify({\n    logger: {\n      transport:\n        process.env.NODE_ENV !== 'production'\n          ? {\n              target: 'pino-pretty',\n            }\n          : undefined,\n    },\n  });\n\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(healthRoutes);\n\n  return server;\n}"
            },
            {
                "path": "apps/api/src/plugins/",
                "content": [
                    {
                        "path": "project/apps/api/src/plugins/db.ts",
                        "content": "import { drizzle } from 'drizzle-orm/node-postgres';\nimport fp from 'fastify-plugin';\nimport { Pool } from 'pg';\nimport * as schema from '@ddms/db';\n\n// Augment FastifyInstance with the db decorator\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    db: ReturnType<typeof drizzle<typeof schema>>;\n  }\n}\n\n/**\n * This plugin creates a Drizzle instance and decorates the Fastify instance with it.\n * It also handles graceful shutdown of the database connection pool.\n */\nexport default fp(async function (fastify) {\n  if (!process.env.DATABASE_URL) {\n    fastify.log.error('DATABASE_URL environment variable is not set.');\n    throw new Error('DATABASE_URL is not set');\n  }\n\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n  });\n\n  const db = drizzle(pool, { schema });\n\n  fastify.decorate('db', db);\n\n  fastify.addHook('onClose', async (instance) => {\n    instance.log.info('Closing database connection pool...');\n    await pool.end();\n    instance.log.info('Database connection pool closed.');\n  });\n});"
                    }
                ]
            },
            {
                "path": "packages/db/",
                "content": [
                    {
                        "path": "project/packages/db/migrations/0000_curvy_mysterio.sql",
                        "content": "CREATE TYPE \"field_kind\" AS ENUM('text', 'number', 'date', 'select', 'relation', 'boolean');\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"audit_log\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"actor_id\" uuid,\n\t\"action\" text NOT NULL,\n\t\"resource_type\" text NOT NULL,\n\t\"resource_id\" uuid,\n\t\"meta\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"edges\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"field_id\" uuid NOT NULL,\n\t\"from_record_id\" uuid NOT NULL,\n\t\"to_record_id\" uuid NOT NULL,\n\t\"created_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\tCONSTRAINT \"edges_tenant_id_field_id_from_record_id_to_record_id_unique\" UNIQUE(\"tenant_id\",\"field_id\",\"from_record_id\",\"to_record_id\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"entity_types\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"description\" text,\n\tCONSTRAINT \"entity_types_tenant_id_key_unique\" UNIQUE(\"tenant_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"field_defs\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"kind\" \"field_kind\" NOT NULL,\n\t\"required\" boolean DEFAULT false NOT NULL,\n\t\"unique_within_type\" boolean DEFAULT false NOT NULL,\n\t\"searchable\" boolean DEFAULT true NOT NULL,\n\t\"indexed\" boolean DEFAULT false NOT NULL,\n\t\"options\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"validate\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"acl\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"position\" integer DEFAULT 0 NOT NULL,\n\t\"active\" boolean DEFAULT true NOT NULL,\n\tCONSTRAINT \"field_defs_tenant_id_entity_type_id_key_unique\" UNIQUE(\"tenant_id\",\"entity_type_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"record_versions\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"record_id\" uuid NOT NULL,\n\t\"version\" integer NOT NULL,\n\t\"data\" jsonb NOT NULL,\n\t\"changed_by\" uuid,\n\t\"changed_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"records\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"data\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"fts\" tsvector,\n\t\"version\" integer DEFAULT 1 NOT NULL,\n\t\"created_by\" uuid,\n\t\"updated_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"tenants\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"name\" text NOT NULL,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_field_id_field_defs_id_fk\" FOREIGN KEY (\"field_id\") REFERENCES \"public\".\"field_defs\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_from_record_id_records_id_fk\" FOREIGN KEY (\"from_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_to_record_id_records_id_fk\" FOREIGN KEY (\"to_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"entity_types\" ADD CONSTRAINT \"entity_types_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"record_versions\" ADD CONSTRAINT \"record_versions_record_id_records_id_fk\" FOREIGN KEY (\"record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"audit_log\" ADD CONSTRAINT \"audit_log_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;"
                    },
                    {
                        "path": "project/packages/db/migrations/.gitkeep",
                        "content": ""
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\",\n    \"db:generate\": \"drizzle-kit generate\"\n  },\n  \"dependencies\": {\n    \"drizzle-orm\": \"^0.31.2\",\n    \"pg\": \"^8.12.0\"\n  },\n  \"devDependencies\": {\n    \"@types/pg\": \"^8.11.6\",\n    \"drizzle-kit\": \"^0.22.7\",\n    \"dotenv\": \"^16.4.5\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/db/.env.example",
                        "content": "DATABASE_URL=\"postgresql://user:password@localhost:5432/ddms\""
                    },
                    {
                        "path": "project/packages/db/drizzle.config.ts",
                        "content": "import 'dotenv/config';\nimport { defineConfig } from 'drizzle-kit';\n\nif (!process.env.DATABASE_URL) {\n  throw new Error('DATABASE_URL is not set in environment variables');\n}\n\nexport default defineConfig({\n  schema: './src/schema.ts',\n  out: './migrations',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n  verbose: true,\n  strict: true,\n});"
                    },
                    {
                        "path": "project/packages/db/src/schema.ts",
                        "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export * from './schema';"
                    }
                ]
            }
        ]
    },
    {
        "name": "I2.T2",
        "context": {
            "task_id": "I2.T2",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Create the initial OpenAPI v3 specification in `api/openapi.yaml`. Define the schemas and endpoints for managing `entity_types` and `field_defs` (GET, POST, PATCH).",
            "agent_type_hint": "DocumentationAgent",
            "inputs": "Section 9.1 of the manifest (Metadata API)",
            "target_files": [
                "api/openapi.yaml"
            ],
            "input_files": [],
            "deliverables": "An OpenAPI YAML file.",
            "acceptance_criteria": "The YAML file is syntactically valid and passes OpenAPI validation. It accurately defines the metadata endpoints.",
            "dependencies": [],
            "parallelizable": true
        },
        "output": "I will create a new file `api/openapi.yaml` to define the OpenAPI v3 specification for the metadata management API. This file will include the schemas for `EntityType` and `FieldDef`, along with the CRUD endpoints as specified in the task instructions. I will structure the file with top-level information, paths for the endpoints, and a components section for reusable schemas, parameters, and responses, ensuring it is syntactically valid and adheres to the OpenAPI standard.\n\n~~~yaml\n#- file: api/openapi.yaml\nopenapi: '3.0.3'\ninfo:\n  title: 'Dynamic Data Management System API'\n  description: 'API for managing dynamic entities, fields, records, and relationships.'\n  version: '1.0.0'\nservers:\n  - url: '/api/v1'\n    description: 'API v1'\n\ntags:\n  - name: Metadata\n    description: 'Operations for managing Entity Types and Field Definitions.'\n\npaths:\n  /entity-types:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Entity Types'\n      description: 'Retrieves a list of all entity types for the tenant.'\n      operationId: 'listEntityTypes'\n      responses:\n        '200':\n          description: 'A list of entity types.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/EntityType'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Entity Type'\n      description: 'Creates a new entity type.'\n      operationId: 'createEntityType'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeCreate'\n      responses:\n        '201':\n          description: 'Entity type created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n\n  /entity-types/{entityTypeId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Entity Type'\n      description: 'Updates an existing entity type.'\n      operationId: 'updateEntityType'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeUpdate'\n      responses:\n        '200':\n          description: 'Entity type updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entity-types/{entityTypeId}/fields:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Field Definitions'\n      description: 'Retrieves a list of all field definitions for a given entity type.'\n      operationId: 'listFieldDefs'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      responses:\n        '200':\n          description: 'A list of field definitions.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/FieldDef'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Field Definition'\n      description: 'Creates a new field definition for an entity type.'\n      operationId: 'createFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefCreate'\n      responses:\n        '201':\n          description: 'Field definition created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /fields/{fieldId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Field Definition'\n      description: 'Updates an existing field definition.'\n      operationId: 'updateFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/fieldId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefUpdate'\n      responses:\n        '200':\n          description: 'Field definition updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  parameters:\n    entityTypeId:\n      name: entityTypeId\n      in: path\n      required: true\n      description: 'The ID of the entity type.'\n      schema:\n        type: string\n        format: uuid\n    fieldId:\n      name: fieldId\n      in: path\n      required: true\n      description: 'The ID of the field definition.'\n      schema:\n        type: string\n        format: uuid\n\n  responses:\n    BadRequest:\n      description: 'Bad Request - The request body is invalid.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    NotFound:\n      description: 'Not Found - The requested resource does not exist.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  schemas:\n    # Entity Type Schemas\n    EntityType:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - id\n        - key\n        - label\n\n    EntityTypeCreate:\n      type: object\n      properties:\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - key\n        - label\n\n    EntityTypeUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n\n    # Field Definition Schemas\n    FieldDef:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the field (e.g., \"status\", \"budget\").'\n        label:\n          type: string\n          description: 'A human-readable label for the field (e.g., \"Status\", \"Budget\").'\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n          default: false\n        uniqueWithinType:\n          type: boolean\n          default: false\n        searchable:\n          type: boolean\n          default: true\n        indexed:\n          type: boolean\n          default: false\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n          default: 0\n        active:\n          type: boolean\n          default: true\n      required:\n        - id\n        - entityTypeId\n        - key\n        - label\n        - kind\n\n    FieldDefCreate:\n      type: object\n      properties:\n        key:\n          type: string\n        label:\n          type: string\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n      required:\n        - key\n        - label\n        - kind\n\n    FieldDefUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n        active:\n          type: boolean\n\n    FieldDefOptions:\n      type: object\n      properties:\n        enum:\n          type: array\n          items:\n            type: string\n          description: 'For kind=\"select\". A list of possible values.'\n        multiselect:\n          type: boolean\n          description: 'For kind=\"select\". Whether multiple values can be selected.'\n        relation:\n          type: object\n          description: 'For kind=\"relation\". Defines the relationship target.'\n          properties:\n            targetEntityTypeId:\n              type: string\n              format: uuid\n            cardinality:\n              type: string\n              enum: [one, many]\n          required:\n            - targetEntityTypeId\n            - cardinality\n\n    FieldDefValidate:\n      type: object\n      description: 'Validation rules that depend on the field kind.'\n      properties:\n        text:\n          type: object\n          properties:\n            minLen:\n              type: integer\n            maxLen:\n              type: integer\n            regex:\n              type: string\n        number:\n          type: object\n          properties:\n            min:\n              type: number\n            max:\n              type: number\n            integer:\n              type: boolean\n        date:\n          type: object\n          properties:\n            min:\n              type: string\n              format: date\n            max:\n              type: string\n              format: date\n\n    FieldDefAcl:\n      type: object\n      description: 'Access control list defining roles for read/write access.'\n      properties:\n        read:\n          type: array\n          items:\n            type: string\n        write:\n          type: array\n          items:\n            type: string\n\n    # Error Schema\n    Error:\n      type: object\n      properties:\n        code:\n          type: string\n          description: 'A machine-readable error code.'\n          example: 'VALIDATION_ERROR'\n        message:\n          type: string\n          description: 'A human-readable error message.'\n          example: 'The request body is invalid.'\n        errors:\n          type: array\n          items:\n            $ref: '#/components/schemas/ValidationErrorDetail'\n      required:\n        - code\n        - message\n\n    ValidationErrorDetail:\n      type: object\n      properties:\n        path:\n          type: string\n          description: 'The path to the invalid field in the request body.'\n          example: 'budget'\n        code:\n          type: string\n          description: 'A machine-readable code for the specific validation error.'\n          example: 'too_small'\n        message:\n          type: string\n          description: 'A human-readable message for the specific validation error.'\n          example: 'The budget must be at least 0.'\n      required:\n        - path\n        - code\n        - message\n~~~",
        "iteration_id": "I2",
        "completed": true,
        "target_files": [
            "api/openapi.yaml"
        ],
        "input_files": [],
        "files": [
            {
                "path": "api/openapi.yaml",
                "content": "openapi: '3.0.3'\ninfo:\n  title: 'Dynamic Data Management System API'\n  description: 'API for managing dynamic entities, fields, records, and relationships.'\n  version: '1.0.0'\nservers:\n  - url: '/api/v1'\n    description: 'API v1'\n\ntags:\n  - name: Metadata\n    description: 'Operations for managing Entity Types and Field Definitions.'\n\npaths:\n  /entity-types:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Entity Types'\n      description: 'Retrieves a list of all entity types for the tenant.'\n      operationId: 'listEntityTypes'\n      responses:\n        '200':\n          description: 'A list of entity types.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/EntityType'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Entity Type'\n      description: 'Creates a new entity type.'\n      operationId: 'createEntityType'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeCreate'\n      responses:\n        '201':\n          description: 'Entity type created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n\n  /entity-types/{entityTypeId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Entity Type'\n      description: 'Updates an existing entity type.'\n      operationId: 'updateEntityType'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeUpdate'\n      responses:\n        '200':\n          description: 'Entity type updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entity-types/{entityTypeId}/fields:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Field Definitions'\n      description: 'Retrieves a list of all field definitions for a given entity type.'\n      operationId: 'listFieldDefs'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      responses:\n        '200':\n          description: 'A list of field definitions.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/FieldDef'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Field Definition'\n      description: 'Creates a new field definition for an entity type.'\n      operationId: 'createFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefCreate'\n      responses:\n        '201':\n          description: 'Field definition created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /fields/{fieldId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Field Definition'\n      description: 'Updates an existing field definition.'\n      operationId: 'updateFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/fieldId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefUpdate'\n      responses:\n        '200':\n          description: 'Field definition updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  parameters:\n    entityTypeId:\n      name: entityTypeId\n      in: path\n      required: true\n      description: 'The ID of the entity type.'\n      schema:\n        type: string\n        format: uuid\n    fieldId:\n      name: fieldId\n      in: path\n      required: true\n      description: 'The ID of the field definition.'\n      schema:\n        type: string\n        format: uuid\n\n  responses:\n    BadRequest:\n      description: 'Bad Request - The request body is invalid.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    NotFound:\n      description: 'Not Found - The requested resource does not exist.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  schemas:\n    # Entity Type Schemas\n    EntityType:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - id\n        - key\n        - label\n\n    EntityTypeCreate:\n      type: object\n      properties:\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - key\n        - label\n\n    EntityTypeUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n\n    # Field Definition Schemas\n    FieldDef:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the field (e.g., \"status\", \"budget\").'\n        label:\n          type: string\n          description: 'A human-readable label for the field (e.g., \"Status\", \"Budget\").'\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n          default: false\n        uniqueWithinType:\n          type: boolean\n          default: false\n        searchable:\n          type: boolean\n          default: true\n        indexed:\n          type: boolean\n          default: false\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n          default: 0\n        active:\n          type: boolean\n          default: true\n      required:\n        - id\n        - entityTypeId\n        - key\n        - label\n        - kind\n\n    FieldDefCreate:\n      type: object\n      properties:\n        key:\n          type: string\n        label:\n          type: string\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n      required:\n        - key\n        - label\n        - kind\n\n    FieldDefUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n        active:\n          type: boolean\n\n    FieldDefOptions:\n      type: object\n      properties:\n        enum:\n          type: array\n          items:\n            type: string\n          description: 'For kind=\"select\". A list of possible values.'\n        multiselect:\n          type: boolean\n          description: 'For kind=\"select\". Whether multiple values can be selected.'\n        relation:\n          type: object\n          description: 'For kind=\"relation\". Defines the relationship target.'\n          properties:\n            targetEntityTypeId:\n              type: string\n              format: uuid\n            cardinality:\n              type: string\n              enum: [one, many]\n          required:\n            - targetEntityTypeId\n            - cardinality\n\n    FieldDefValidate:\n      type: object\n      description: 'Validation rules that depend on the field kind.'\n      properties:\n        text:\n          type: object\n          properties:\n            minLen:\n              type: integer\n            maxLen:\n              type: integer\n            regex:\n              type: string\n        number:\n          type: object\n          properties:\n            min:\n              type: number\n            max:\n              type: number\n            integer:\n              type: boolean\n        date:\n          type: object\n          properties:\n            min:\n              type: string\n              format: date\n            max:\n              type: string\n              format: date\n\n    FieldDefAcl:\n      type: object\n      description: 'Access control list defining roles for read/write access.'\n      properties:\n        read:\n          type: array\n          items:\n            type: string\n        write:\n          type: array\n          items:\n            type: string\n\n    # Error Schema\n    Error:\n      type: object\n      properties:\n        code:\n          type: string\n          description: 'A machine-readable error code.'\n          example: 'VALIDATION_ERROR'\n        message:\n          type: string\n          description: 'A human-readable error message.'\n          example: 'The request body is invalid.'\n        errors:\n          type: array\n          items:\n            $ref: '#/components/schemas/ValidationErrorDetail'\n      required:\n        - code\n        - message\n\n    ValidationErrorDetail:\n      type: object\n      properties:\n        path:\n          type: string\n          description: 'The path to the invalid field in the request body.'\n          example: 'budget'\n        code:\n          type: string\n          description: 'A machine-readable code for the specific validation error.'\n          example: 'too_small'\n        message:\n          type: string\n          description: 'A human-readable message for the specific validation error.'\n          example: 'The budget must be at least 0.'\n      required:\n        - path\n        - code\n        - message"
            }
        ]
    },
    {
        "name": "I2.T3",
        "context": {
            "task_id": "I2.T3",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Implement the Data Access Layer (DAL) functions within `apps/api` for CRUD operations on `entity_types` and `field_defs` using the Drizzle schema.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Drizzle schema from `I1.T2`.",
            "target_files": [
                "apps/api/src/lib/dal/metadata.ts"
            ],
            "input_files": [
                "packages/db/src/schema.ts",
                "apps/api/src/"
            ],
            "deliverables": "TypeScript functions for interacting with metadata tables.",
            "acceptance_criteria": "Functions are type-safe and correctly perform create, read, update operations.",
            "dependencies": [
                "I1.T2"
            ],
            "parallelizable": true
        },
        "output": "~~~\n#- file: apps/api/src/lib/dal/metadata.ts\nimport { and, eq } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\ntype Db = FastifyInstance['db'];\ntype NewEntityType = typeof schema.entityTypes.$inferInsert;\ntype NewFieldDef = typeof schema.fieldDefs.$inferInsert;\n\n//\n// Entity Type Functions\n//\n\n/**\n * Creates a new entity type for a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param data The data for the new entity type.\n * @returns The newly created entity type.\n */\nexport async function createEntityType(\n  db: Db,\n  tenantId: string,\n  data: Omit<NewEntityType, 'tenantId' | 'id'>,\n) {\n  const [result] = await db\n    .insert(schema.entityTypes)\n    .values({\n      ...data,\n      tenantId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all entity types belonging to a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @returns An array of entity types.\n */\nexport async function findEntityTypesByTenant(db: Db, tenantId: string) {\n  return db.query.entityTypes.findMany({\n    where: eq(schema.entityTypes.tenantId, tenantId),\n  });\n}\n\n/**\n * Finds a single entity type by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to find.\n * @returns The entity type, or undefined if not found.\n */\nexport async function findEntityTypeById(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.entityTypes.findFirst({\n    where: and(\n      eq(schema.entityTypes.id, entityTypeId),\n      eq(schema.entityTypes.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to update.\n * @param data The data to update.\n * @returns The updated entity type.\n */\nexport async function updateEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Partial<Omit<NewEntityType, 'tenantId' | 'id'>>,\n) {\n  const [result] = await db\n    .update(schema.entityTypes)\n    .set(data)\n    .where(\n      and(\n        eq(schema.entityTypes.id, entityTypeId),\n        eq(schema.entityTypes.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n//\n// Field Definition Functions\n//\n\n/**\n * Creates a new field definition for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the parent entity type.\n * @param data The data for the new field definition.\n * @returns The newly created field definition.\n */\nexport async function createFieldDef(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>,\n) {\n  const [result] = await db\n    .insert(schema.fieldDefs)\n    .values({\n      ...data,\n      tenantId,\n      entityTypeId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all field definitions for a specific entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @returns An array of field definitions.\n */\nexport async function findFieldDefsByEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.fieldDefs.findMany({\n    where: and(\n      eq(schema.fieldDefs.tenantId, tenantId),\n      eq(schema.fieldDefs.entityTypeId, entityTypeId),\n    ),\n  });\n}\n\n/**\n * Updates an existing field definition.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to update.\n * @param data The data to update.\n * @returns The updated field definition.\n */\nexport async function updateFieldDef(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n  data: Partial<Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>>,\n) {\n  const [result] = await db\n    .update(schema.fieldDefs)\n    .set(data)\n    .where(\n      and(\n        eq(schema.fieldDefs.id, fieldDefId),\n        eq(schema.fieldDefs.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}\n~~~",
        "iteration_id": "I2",
        "completed": true,
        "target_files": [
            "apps/api/src/lib/dal/metadata.ts"
        ],
        "input_files": [
            "packages/db/src/schema.ts",
            "apps/api/src/"
        ],
        "files": [
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            },
            {
                "path": "apps/api/src/",
                "content": [
                    {
                        "path": "project/apps/api/src/plugins/db.ts",
                        "content": "import { drizzle } from 'drizzle-orm/node-postgres';\nimport fp from 'fastify-plugin';\nimport { Pool } from 'pg';\nimport * as schema from '@ddms/db';\n\n// Augment FastifyInstance with the db decorator\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    db: ReturnType<typeof drizzle<typeof schema>>;\n  }\n}\n\n/**\n * This plugin creates a Drizzle instance and decorates the Fastify instance with it.\n * It also handles graceful shutdown of the database connection pool.\n */\nexport default fp(async function (fastify) {\n  if (!process.env.DATABASE_URL) {\n    fastify.log.error('DATABASE_URL environment variable is not set.');\n    throw new Error('DATABASE_URL is not set');\n  }\n\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n  });\n\n  const db = drizzle(pool, { schema });\n\n  fastify.decorate('db', db);\n\n  fastify.addHook('onClose', async (instance) => {\n    instance.log.info('Closing database connection pool...');\n    await pool.end();\n    instance.log.info('Database connection pool closed.');\n  });\n});"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "import 'dotenv/config';\nimport { buildServer } from './server';\n\nasync function main() {\n  const server = await buildServer();\n\n  try {\n    const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 3001;\n    if (isNaN(port)) {\n      server.log.error('Invalid PORT environment variable');\n      process.exit(1);\n    }\n    const host = process.env.HOST || '0.0.0.0';\n\n    await server.listen({ port, host });\n\n    server.log.info(`Server listening at http://${host}:${port}`);\n\n    const signals: NodeJS.Signals[] = ['SIGINT', 'SIGTERM'];\n    for (const signal of signals) {\n      process.on(signal, async () => {\n        try {\n          server.log.info(`Received ${signal}, shutting down gracefully...`);\n          await server.close();\n          server.log.info('Server shut down successfully.');\n          process.exit(0);\n        } catch (err) {\n          server.log.error({ err }, 'Error during server shutdown.');\n          process.exit(1);\n        }\n      });\n    }\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n}\n\nmain();"
                    },
                    {
                        "path": "project/apps/api/src/server.ts",
                        "content": "import fastify from 'fastify';\nimport cors from '@fastify/cors';\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\n\nexport async function buildServer() {\n  const server = fastify({\n    logger: {\n      transport:\n        process.env.NODE_ENV !== 'production'\n          ? {\n              target: 'pino-pretty',\n            }\n          : undefined,\n    },\n  });\n\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(healthRoutes);\n\n  return server;\n}"
                    },
                    {
                        "path": "project/apps/api/src/routes/health.ts",
                        "content": "import { FastifyInstance } from 'fastify';\n\n/**\n * Registers a health check route.\n * @param fastify The Fastify instance.\n */\nexport default async function (fastify: FastifyInstance) {\n  fastify.get('/health', async (_request, reply) => {\n    // In a real application, you might also check database connectivity here.\n    // For now, just returning a 200 OK is sufficient.\n    return reply.code(200).send({ status: 'ok' });\n  });\n}"
                    }
                ]
            },
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            },
            {
                "path": "apps/api/src/lib/dal/metadata.ts",
                "content": "import { and, eq } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\ntype Db = FastifyInstance['db'];\ntype NewEntityType = typeof schema.entityTypes.$inferInsert;\ntype NewFieldDef = typeof schema.fieldDefs.$inferInsert;\n\n//\n// Entity Type Functions\n//\n\n/**\n * Creates a new entity type for a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param data The data for the new entity type.\n * @returns The newly created entity type.\n */\nexport async function createEntityType(\n  db: Db,\n  tenantId: string,\n  data: Omit<NewEntityType, 'tenantId' | 'id'>,\n) {\n  const [result] = await db\n    .insert(schema.entityTypes)\n    .values({\n      ...data,\n      tenantId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all entity types belonging to a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @returns An array of entity types.\n */\nexport async function findEntityTypesByTenant(db: Db, tenantId: string) {\n  return db.query.entityTypes.findMany({\n    where: eq(schema.entityTypes.tenantId, tenantId),\n  });\n}\n\n/**\n * Finds a single entity type by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to find.\n * @returns The entity type, or undefined if not found.\n */\nexport async function findEntityTypeById(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.entityTypes.findFirst({\n    where: and(\n      eq(schema.entityTypes.id, entityTypeId),\n      eq(schema.entityTypes.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to update.\n * @param data The data to update.\n * @returns The updated entity type.\n */\nexport async function updateEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Partial<Omit<NewEntityType, 'tenantId' | 'id'>>,\n) {\n  const [result] = await db\n    .update(schema.entityTypes)\n    .set(data)\n    .where(\n      and(\n        eq(schema.entityTypes.id, entityTypeId),\n        eq(schema.entityTypes.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n//\n// Field Definition Functions\n//\n\n/**\n * Creates a new field definition for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the parent entity type.\n * @param data The data for the new field definition.\n * @returns The newly created field definition.\n */\nexport async function createFieldDef(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>,\n) {\n  const [result] = await db\n    .insert(schema.fieldDefs)\n    .values({\n      ...data,\n      tenantId,\n      entityTypeId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all field definitions for a specific entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @returns An array of field definitions.\n */\nexport async function findFieldDefsByEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.fieldDefs.findMany({\n    where: and(\n      eq(schema.fieldDefs.tenantId, tenantId),\n      eq(schema.fieldDefs.entityTypeId, entityTypeId),\n    ),\n  });\n}\n\n/**\n * Updates an existing field definition.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to update.\n * @param data The data to update.\n * @returns The updated field definition.\n */\nexport async function updateFieldDef(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n  data: Partial<Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>>,\n) {\n  const [result] = await db\n    .update(schema.fieldDefs)\n    .set(data)\n    .where(\n      and(\n        eq(schema.fieldDefs.id, fieldDefId),\n        eq(schema.fieldDefs.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}"
            },
            {
                "path": "apps/api/src/",
                "content": [
                    {
                        "path": "project/apps/api/src/plugins/db.ts",
                        "content": "import { drizzle } from 'drizzle-orm/node-postgres';\nimport fp from 'fastify-plugin';\nimport { Pool } from 'pg';\nimport * as schema from '@ddms/db';\n\n// Augment FastifyInstance with the db decorator\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    db: ReturnType<typeof drizzle<typeof schema>>;\n  }\n}\n\n/**\n * This plugin creates a Drizzle instance and decorates the Fastify instance with it.\n * It also handles graceful shutdown of the database connection pool.\n */\nexport default fp(async function (fastify) {\n  if (!process.env.DATABASE_URL) {\n    fastify.log.error('DATABASE_URL environment variable is not set.');\n    throw new Error('DATABASE_URL is not set');\n  }\n\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n  });\n\n  const db = drizzle(pool, { schema });\n\n  fastify.decorate('db', db);\n\n  fastify.addHook('onClose', async (instance) => {\n    instance.log.info('Closing database connection pool...');\n    await pool.end();\n    instance.log.info('Database connection pool closed.');\n  });\n});"
                    },
                    {
                        "path": "project/apps/api/src/lib/dal/metadata.ts",
                        "content": "import { and, eq } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\ntype Db = FastifyInstance['db'];\ntype NewEntityType = typeof schema.entityTypes.$inferInsert;\ntype NewFieldDef = typeof schema.fieldDefs.$inferInsert;\n\n//\n// Entity Type Functions\n//\n\n/**\n * Creates a new entity type for a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param data The data for the new entity type.\n * @returns The newly created entity type.\n */\nexport async function createEntityType(\n  db: Db,\n  tenantId: string,\n  data: Omit<NewEntityType, 'tenantId' | 'id'>,\n) {\n  const [result] = await db\n    .insert(schema.entityTypes)\n    .values({\n      ...data,\n      tenantId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all entity types belonging to a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @returns An array of entity types.\n */\nexport async function findEntityTypesByTenant(db: Db, tenantId: string) {\n  return db.query.entityTypes.findMany({\n    where: eq(schema.entityTypes.tenantId, tenantId),\n  });\n}\n\n/**\n * Finds a single entity type by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to find.\n * @returns The entity type, or undefined if not found.\n */\nexport async function findEntityTypeById(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.entityTypes.findFirst({\n    where: and(\n      eq(schema.entityTypes.id, entityTypeId),\n      eq(schema.entityTypes.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to update.\n * @param data The data to update.\n * @returns The updated entity type.\n */\nexport async function updateEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Partial<Omit<NewEntityType, 'tenantId' | 'id'>>,\n) {\n  const [result] = await db\n    .update(schema.entityTypes)\n    .set(data)\n    .where(\n      and(\n        eq(schema.entityTypes.id, entityTypeId),\n        eq(schema.entityTypes.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n//\n// Field Definition Functions\n//\n\n/**\n * Creates a new field definition for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the parent entity type.\n * @param data The data for the new field definition.\n * @returns The newly created field definition.\n */\nexport async function createFieldDef(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>,\n) {\n  const [result] = await db\n    .insert(schema.fieldDefs)\n    .values({\n      ...data,\n      tenantId,\n      entityTypeId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all field definitions for a specific entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @returns An array of field definitions.\n */\nexport async function findFieldDefsByEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.fieldDefs.findMany({\n    where: and(\n      eq(schema.fieldDefs.tenantId, tenantId),\n      eq(schema.fieldDefs.entityTypeId, entityTypeId),\n    ),\n  });\n}\n\n/**\n * Updates an existing field definition.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to update.\n * @param data The data to update.\n * @returns The updated field definition.\n */\nexport async function updateFieldDef(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n  data: Partial<Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>>,\n) {\n  const [result] = await db\n    .update(schema.fieldDefs)\n    .set(data)\n    .where(\n      and(\n        eq(schema.fieldDefs.id, fieldDefId),\n        eq(schema.fieldDefs.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "import 'dotenv/config';\nimport { buildServer } from './server';\n\nasync function main() {\n  const server = await buildServer();\n\n  try {\n    const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 3001;\n    if (isNaN(port)) {\n      server.log.error('Invalid PORT environment variable');\n      process.exit(1);\n    }\n    const host = process.env.HOST || '0.0.0.0';\n\n    await server.listen({ port, host });\n\n    server.log.info(`Server listening at http://${host}:${port}`);\n\n    const signals: NodeJS.Signals[] = ['SIGINT', 'SIGTERM'];\n    for (const signal of signals) {\n      process.on(signal, async () => {\n        try {\n          server.log.info(`Received ${signal}, shutting down gracefully...`);\n          await server.close();\n          server.log.info('Server shut down successfully.');\n          process.exit(0);\n        } catch (err) {\n          server.log.error({ err }, 'Error during server shutdown.');\n          process.exit(1);\n        }\n      });\n    }\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n}\n\nmain();"
                    },
                    {
                        "path": "project/apps/api/src/server.ts",
                        "content": "import fastify from 'fastify';\nimport cors from '@fastify/cors';\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\n\nexport async function buildServer() {\n  const server = fastify({\n    logger: {\n      transport:\n        process.env.NODE_ENV !== 'production'\n          ? {\n              target: 'pino-pretty',\n            }\n          : undefined,\n    },\n  });\n\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(healthRoutes);\n\n  return server;\n}"
                    },
                    {
                        "path": "project/apps/api/src/routes/health.ts",
                        "content": "import { FastifyInstance } from 'fastify';\n\n/**\n * Registers a health check route.\n * @param fastify The Fastify instance.\n */\nexport default async function (fastify: FastifyInstance) {\n  fastify.get('/health', async (_request, reply) => {\n    // In a real application, you might also check database connectivity here.\n    // For now, just returning a 200 OK is sufficient.\n    return reply.code(200).send({ status: 'ok' });\n  });\n}"
                    }
                ]
            }
        ]
    },
    {
        "name": "I2.T4",
        "context": {
            "task_id": "I2.T4",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Implement the Fastify routes and handlers for the `entity_types` and `field_defs` endpoints, using the DAL functions from `I2.T3` and validating requests against Zod schemas derived from the OpenAPI spec.",
            "agent_type_hint": "BackendAgent",
            "inputs": "OpenAPI spec from `I2.T2`, DAL from `I2.T3`.",
            "target_files": [
                "apps/api/src/routes/metadata/"
            ],
            "input_files": [
                "api/openapi.yaml",
                "apps/api/src/lib/dal/metadata.ts"
            ],
            "deliverables": "Implemented API routes for metadata.",
            "acceptance_criteria": "Endpoints behave as specified in the OpenAPI document. Basic positive-path tests pass.",
            "dependencies": [
                "I2.T2",
                "I2.T3"
            ],
            "parallelizable": false
        },
        "output": "Following my plan, I will create two new files for the metadata routes and their schemas, and then I will edit the main server file to register these new routes.\n\nFirst, I'll create the Zod schemas that correspond to the OpenAPI specification. This ensures all incoming requests and outgoing responses are correctly typed and validated.\n\n~~~typescript\n#- file: apps/api/src/routes/metadata/schemas.ts\nimport { z } from 'zod';\n\n// Reusable parameter schemas\nexport const entityTypeIdParamsSchema = z.object({\n  entityTypeId: z.string().uuid(),\n});\n\nexport const fieldIdParamsSchema = z.object({\n  fieldId: z.string().uuid(),\n});\n\n// Entity Type Schemas\nexport const entityTypeSchema = z.object({\n  id: z.string().uuid(),\n  key: z.string(),\n  label: z.string(),\n  description: z.string().nullable(),\n});\n\nexport const createEntityTypeBodySchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  description: z.string().nullable().optional(),\n});\n\nexport const updateEntityTypeBodySchema = z.object({\n  label: z.string().optional(),\n  description: z.string().nullable().optional(),\n});\n\n// Field Definition Schemas\nconst fieldKindEnum = z.enum([\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nexport const fieldDefSchema = z.object({\n  id: z.string().uuid(),\n  entityTypeId: z.string().uuid(),\n  key: z.string(),\n  label: z.string(),\n  kind: fieldKindEnum,\n  required: z.boolean(),\n  uniqueWithinType: z.boolean(),\n  searchable: z.boolean(),\n  indexed: z.boolean(),\n  options: z.record(z.any()),\n  validate: z.record(z.any()),\n  acl: z.record(z.any()),\n  position: z.number().int(),\n  active: z.boolean(),\n});\n\nexport const createFieldDefBodySchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  kind: fieldKindEnum,\n  required: z.boolean().optional(),\n  uniqueWithinType: z.boolean().optional(),\n  searchable: z.boolean().optional(),\n  indexed: z.boolean().optional(),\n  options: z.record(z.any()).optional(),\n  validate: z.record(z.any()).optional(),\n  acl: z.record(z.any()).optional(),\n  position: z.number().int().optional(),\n});\n\nexport const updateFieldDefBodySchema = z.object({\n  label: z.string().optional(),\n  required: z.boolean().optional(),\n  uniqueWithinType: z.boolean().optional(),\n  searchable: z.boolean().optional(),\n  indexed: z.boolean().optional(),\n  options: z.record(z.any()).optional(),\n  validate: z.record(z.any()).optional(),\n  acl: z.record(z.any()).optional(),\n  position: z.number().int().optional(),\n  active: z.boolean().optional(),\n});\n~~~\n\nNext, I'll create the Fastify plugin that defines all the metadata API routes. This file will use the schemas for validation and the DAL functions for database interaction.\n\n~~~typescript\n#- file: apps/api/src/routes/metadata/index.ts\nimport { FastifyPluginAsync } from 'fastify';\nimport { z } from 'zod';\nimport * as dal from '../../lib/dal/metadata';\nimport {\n  createEntityTypeBodySchema,\n  entityTypeSchema,\n  updateEntityTypeBodySchema,\n  entityTypeIdParamsSchema,\n  fieldIdParamsSchema,\n  fieldDefSchema,\n  createFieldDefBodySchema,\n  updateFieldDefBodySchema,\n} from './schemas';\n\nconst metadataRoutes: FastifyPluginAsync = async (fastify) => {\n  // A placeholder tenantId until authentication is implemented\n  const tenantId = '00000000-0000-0000-0000-000000000000';\n\n  //\n  // Entity Type Routes\n  //\n\n  fastify.get(\n    '/entity-types',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'List Entity Types',\n        response: {\n          200: z.array(entityTypeSchema),\n        },\n      },\n    },\n    async (request, reply) => {\n      const entityTypes = await dal.findEntityTypesByTenant(\n        request.db,\n        tenantId,\n      );\n      return reply.send(entityTypes);\n    },\n  );\n\n  fastify.post(\n    '/entity-types',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Create Entity Type',\n        body: createEntityTypeBodySchema,\n        response: {\n          201: entityTypeSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const newEntityType = await dal.createEntityType(\n        request.db,\n        tenantId,\n        request.body,\n      );\n      return reply.code(201).send(newEntityType);\n    },\n  );\n\n  fastify.patch(\n    '/entity-types/:entityTypeId',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Update Entity Type',\n        params: entityTypeIdParamsSchema,\n        body: updateEntityTypeBodySchema,\n        response: {\n          200: entityTypeSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const existing = await dal.findEntityTypeById(\n        request.db,\n        tenantId,\n        entityTypeId,\n      );\n      if (!existing) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const updatedEntityType = await dal.updateEntityType(\n        request.db,\n        tenantId,\n        entityTypeId,\n        request.body,\n      );\n      return reply.send(updatedEntityType);\n    },\n  );\n\n  //\n  // Field Definition Routes\n  //\n\n  fastify.get(\n    '/entity-types/:entityTypeId/fields',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'List Field Definitions',\n        params: entityTypeIdParamsSchema,\n        response: {\n          200: z.array(fieldDefSchema),\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const entityType = await dal.findEntityTypeById(\n        request.db,\n        tenantId,\n        entityTypeId,\n      );\n      if (!entityType) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const fieldDefs = await dal.findFieldDefsByEntityType(\n        request.db,\n        tenantId,\n        entityTypeId,\n      );\n      return reply.send(fieldDefs);\n    },\n  );\n\n  fastify.post(\n    '/entity-types/:entityTypeId/fields',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Create Field Definition',\n        params: entityTypeIdParamsSchema,\n        body: createFieldDefBodySchema,\n        response: {\n          201: fieldDefSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const entityType = await dal.findEntityTypeById(\n        request.db,\n        tenantId,\n        entityTypeId,\n      );\n      if (!entityType) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const newFieldDef = await dal.createFieldDef(\n        request.db,\n        tenantId,\n        entityTypeId,\n        request.body,\n      );\n      return reply.code(201).send(newFieldDef);\n    },\n  );\n\n  fastify.patch(\n    '/fields/:fieldId',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Update Field Definition',\n        params: fieldIdParamsSchema,\n        body: updateFieldDefBodySchema,\n        response: {\n          200: fieldDefSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { fieldId } = request.params;\n\n      const existing = await dal.findFieldDefById(request.db, tenantId, fieldId);\n      if (!existing) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Field definition not found' });\n      }\n\n      const updatedFieldDef = await dal.updateFieldDef(\n        request.db,\n        tenantId,\n        fieldId,\n        request.body,\n      );\n      return reply.send(updatedFieldDef);\n    },\n  );\n};\n\nexport default metadataRoutes;\n~~~\n\nFinally, I'll edit the main `server.ts` file to import and register the new metadata routes plugin with the correct `/api/v1` prefix.\n\n~~~edits\n#- file: apps/api/src/server.ts\n***start_edit\nLITERAL\n***search\nimport healthRoutes from './routes/health';\n***replace\nimport healthRoutes from './routes/health';\nimport metadataRoutes from './routes/metadata';\n***description\nImport the new metadata routes plugin.\n***end_edit\n***start_edit\nLITERAL\n***search\n  await server.register(healthRoutes);\n\n  return server;\n}\n***replace\n  await server.register(healthRoutes);\n  await server.register(metadataRoutes, { prefix: '/api/v1' });\n\n  return server;\n}\n***description\nRegister the metadata routes plugin with the /api/v1 prefix.\n***end_edit\n~~~",
        "iteration_id": "I2",
        "completed": true,
        "target_files": [
            "apps/api/src/routes/metadata/"
        ],
        "input_files": [
            "api/openapi.yaml",
            "apps/api/src/lib/dal/metadata.ts"
        ],
        "files": [
            {
                "path": "api/openapi.yaml",
                "content": "openapi: '3.0.3'\ninfo:\n  title: 'Dynamic Data Management System API'\n  description: 'API for managing dynamic entities, fields, records, and relationships.'\n  version: '1.0.0'\nservers:\n  - url: '/api/v1'\n    description: 'API v1'\n\ntags:\n  - name: Metadata\n    description: 'Operations for managing Entity Types and Field Definitions.'\n\npaths:\n  /entity-types:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Entity Types'\n      description: 'Retrieves a list of all entity types for the tenant.'\n      operationId: 'listEntityTypes'\n      responses:\n        '200':\n          description: 'A list of entity types.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/EntityType'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Entity Type'\n      description: 'Creates a new entity type.'\n      operationId: 'createEntityType'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeCreate'\n      responses:\n        '201':\n          description: 'Entity type created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n\n  /entity-types/{entityTypeId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Entity Type'\n      description: 'Updates an existing entity type.'\n      operationId: 'updateEntityType'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeUpdate'\n      responses:\n        '200':\n          description: 'Entity type updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entity-types/{entityTypeId}/fields:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Field Definitions'\n      description: 'Retrieves a list of all field definitions for a given entity type.'\n      operationId: 'listFieldDefs'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      responses:\n        '200':\n          description: 'A list of field definitions.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/FieldDef'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Field Definition'\n      description: 'Creates a new field definition for an entity type.'\n      operationId: 'createFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefCreate'\n      responses:\n        '201':\n          description: 'Field definition created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /fields/{fieldId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Field Definition'\n      description: 'Updates an existing field definition.'\n      operationId: 'updateFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/fieldId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefUpdate'\n      responses:\n        '200':\n          description: 'Field definition updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  parameters:\n    entityTypeId:\n      name: entityTypeId\n      in: path\n      required: true\n      description: 'The ID of the entity type.'\n      schema:\n        type: string\n        format: uuid\n    fieldId:\n      name: fieldId\n      in: path\n      required: true\n      description: 'The ID of the field definition.'\n      schema:\n        type: string\n        format: uuid\n\n  responses:\n    BadRequest:\n      description: 'Bad Request - The request body is invalid.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    NotFound:\n      description: 'Not Found - The requested resource does not exist.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  schemas:\n    # Entity Type Schemas\n    EntityType:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - id\n        - key\n        - label\n\n    EntityTypeCreate:\n      type: object\n      properties:\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - key\n        - label\n\n    EntityTypeUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n\n    # Field Definition Schemas\n    FieldDef:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the field (e.g., \"status\", \"budget\").'\n        label:\n          type: string\n          description: 'A human-readable label for the field (e.g., \"Status\", \"Budget\").'\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n          default: false\n        uniqueWithinType:\n          type: boolean\n          default: false\n        searchable:\n          type: boolean\n          default: true\n        indexed:\n          type: boolean\n          default: false\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n          default: 0\n        active:\n          type: boolean\n          default: true\n      required:\n        - id\n        - entityTypeId\n        - key\n        - label\n        - kind\n\n    FieldDefCreate:\n      type: object\n      properties:\n        key:\n          type: string\n        label:\n          type: string\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n      required:\n        - key\n        - label\n        - kind\n\n    FieldDefUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n        active:\n          type: boolean\n\n    FieldDefOptions:\n      type: object\n      properties:\n        enum:\n          type: array\n          items:\n            type: string\n          description: 'For kind=\"select\". A list of possible values.'\n        multiselect:\n          type: boolean\n          description: 'For kind=\"select\". Whether multiple values can be selected.'\n        relation:\n          type: object\n          description: 'For kind=\"relation\". Defines the relationship target.'\n          properties:\n            targetEntityTypeId:\n              type: string\n              format: uuid\n            cardinality:\n              type: string\n              enum: [one, many]\n          required:\n            - targetEntityTypeId\n            - cardinality\n        formula:\n          type: string\n          description: 'For computed fields. An expression to calculate the field value.'\n          example: 'price * qty'\n        visibleIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional visibility rules for the UI.'\n        requiredIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional requirement rules.'\n\n    FieldDefValidate:\n      type: object\n      description: 'Validation rules that depend on the field kind.'\n      properties:\n        text:\n          type: object\n          properties:\n            minLen:\n              type: integer\n            maxLen:\n              type: integer\n            regex:\n              type: string\n        number:\n          type: object\n          properties:\n            min:\n              type: number\n            max:\n              type: number\n            integer:\n              type: boolean\n        date:\n          type: object\n          properties:\n            min:\n              type: string\n              format: date\n            max:\n              type: string\n              format: date\n\n    FieldDefAcl:\n      type: object\n      description: 'Access control list defining roles for read/write access.'\n      properties:\n        read:\n          type: array\n          items:\n            type: string\n        write:\n          type: array\n          items:\n            type: string\n\n    # Error Schema\n    Error:\n      type: object\n      properties:\n        code:\n          type: string\n          description: 'A machine-readable error code.'\n          example: 'VALIDATION_ERROR'\n        message:\n          type: string\n          description: 'A human-readable error message.'\n          example: 'The request body is invalid.'\n        requestId:\n          type: string\n          format: uuid\n          description: 'A unique identifier for the request, useful for tracing.'\n        errors:\n          type: array\n          items:\n            $ref: '#/components/schemas/ValidationErrorDetail'\n      required:\n        - code\n        - message\n\n    ValidationErrorDetail:\n      type: object\n      properties:\n        path:\n          type: string\n          description: 'The path to the invalid field in the request body.'\n          example: 'budget'\n        code:\n          type: string\n          description: 'A machine-readable code for the specific validation error.'\n          example: 'too_small'\n        message:\n          type: string\n          description: 'A human-readable message for the specific validation error.'\n          example: 'The budget must be at least 0.'\n      required:\n        - path\n        - code\n        - message"
            },
            {
                "path": "apps/api/src/lib/dal/metadata.ts",
                "content": "import { and, eq } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\ntype Db = FastifyInstance['db'];\ntype NewEntityType = typeof schema.entityTypes.$inferInsert;\ntype NewFieldDef = typeof schema.fieldDefs.$inferInsert;\n\n//\n// Entity Type Functions\n//\n\n/**\n * Creates a new entity type for a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param data The data for the new entity type.\n * @returns The newly created entity type.\n */\nexport async function createEntityType(\n  db: Db,\n  tenantId: string,\n  data: Omit<NewEntityType, 'tenantId' | 'id'>,\n) {\n  const [result] = await db\n    .insert(schema.entityTypes)\n    .values({\n      ...data,\n      tenantId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all entity types belonging to a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @returns An array of entity types.\n */\nexport async function findEntityTypesByTenant(db: Db, tenantId: string) {\n  return db.query.entityTypes.findMany({\n    where: eq(schema.entityTypes.tenantId, tenantId),\n  });\n}\n\n/**\n * Finds a single entity type by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to find.\n * @returns The entity type, or undefined if not found.\n */\nexport async function findEntityTypeById(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.entityTypes.findFirst({\n    where: and(\n      eq(schema.entityTypes.id, entityTypeId),\n      eq(schema.entityTypes.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to update.\n * @param data The data to update.\n * @returns The updated entity type.\n */\nexport async function updateEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Partial<Omit<NewEntityType, 'tenantId' | 'id'>>,\n) {\n  const [result] = await db\n    .update(schema.entityTypes)\n    .set(data)\n    .where(\n      and(\n        eq(schema.entityTypes.id, entityTypeId),\n        eq(schema.entityTypes.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n//\n// Field Definition Functions\n//\n\n/**\n * Creates a new field definition for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the parent entity type.\n * @param data The data for the new field definition.\n * @returns The newly created field definition.\n */\nexport async function createFieldDef(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>,\n) {\n  const [result] = await db\n    .insert(schema.fieldDefs)\n    .values({\n      ...data,\n      tenantId,\n      entityTypeId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all field definitions for a specific entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @returns An array of field definitions.\n */\nexport async function findFieldDefsByEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.fieldDefs.findMany({\n    where: and(\n      eq(schema.fieldDefs.tenantId, tenantId),\n      eq(schema.fieldDefs.entityTypeId, entityTypeId),\n    ),\n  });\n}\n\n/**\n * Finds a single field definition by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to find.\n * @returns The field definition, or undefined if not found.\n */\nexport async function findFieldDefById(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n) {\n  return db.query.fieldDefs.findFirst({\n    where: and(\n      eq(schema.fieldDefs.id, fieldDefId),\n      eq(schema.fieldDefs.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing field definition.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to update.\n * @param data The data to update.\n * @returns The updated field definition.\n */\nexport async function updateFieldDef(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n  data: Partial<Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>>,\n) {\n  const [result] = await db\n    .update(schema.fieldDefs)\n    .set(data)\n    .where(\n      and(\n        eq(schema.fieldDefs.id, fieldDefId),\n        eq(schema.fieldDefs.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}"
            },
            {
                "path": "api/openapi.yaml",
                "content": "openapi: '3.0.3'\ninfo:\n  title: 'Dynamic Data Management System API'\n  description: 'API for managing dynamic entities, fields, records, and relationships.'\n  version: '1.0.0'\nservers:\n  - url: '/api/v1'\n    description: 'API v1'\n\ntags:\n  - name: Metadata\n    description: 'Operations for managing Entity Types and Field Definitions.'\n\npaths:\n  /entity-types:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Entity Types'\n      description: 'Retrieves a list of all entity types for the tenant.'\n      operationId: 'listEntityTypes'\n      responses:\n        '200':\n          description: 'A list of entity types.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/EntityType'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Entity Type'\n      description: 'Creates a new entity type.'\n      operationId: 'createEntityType'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeCreate'\n      responses:\n        '201':\n          description: 'Entity type created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n\n  /entity-types/{entityTypeId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Entity Type'\n      description: 'Updates an existing entity type.'\n      operationId: 'updateEntityType'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeUpdate'\n      responses:\n        '200':\n          description: 'Entity type updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entity-types/{entityTypeId}/fields:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Field Definitions'\n      description: 'Retrieves a list of all field definitions for a given entity type.'\n      operationId: 'listFieldDefs'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      responses:\n        '200':\n          description: 'A list of field definitions.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/FieldDef'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Field Definition'\n      description: 'Creates a new field definition for an entity type.'\n      operationId: 'createFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefCreate'\n      responses:\n        '201':\n          description: 'Field definition created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /fields/{fieldId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Field Definition'\n      description: 'Updates an existing field definition.'\n      operationId: 'updateFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/fieldId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefUpdate'\n      responses:\n        '200':\n          description: 'Field definition updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  parameters:\n    entityTypeId:\n      name: entityTypeId\n      in: path\n      required: true\n      description: 'The ID of the entity type.'\n      schema:\n        type: string\n        format: uuid\n    fieldId:\n      name: fieldId\n      in: path\n      required: true\n      description: 'The ID of the field definition.'\n      schema:\n        type: string\n        format: uuid\n\n  responses:\n    BadRequest:\n      description: 'Bad Request - The request body is invalid.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    NotFound:\n      description: 'Not Found - The requested resource does not exist.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  schemas:\n    # Entity Type Schemas\n    EntityType:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - id\n        - key\n        - label\n\n    EntityTypeCreate:\n      type: object\n      properties:\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - key\n        - label\n\n    EntityTypeUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n\n    # Field Definition Schemas\n    FieldDef:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the field (e.g., \"status\", \"budget\").'\n        label:\n          type: string\n          description: 'A human-readable label for the field (e.g., \"Status\", \"Budget\").'\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n          default: false\n        uniqueWithinType:\n          type: boolean\n          default: false\n        searchable:\n          type: boolean\n          default: true\n        indexed:\n          type: boolean\n          default: false\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n          default: 0\n        active:\n          type: boolean\n          default: true\n      required:\n        - id\n        - entityTypeId\n        - key\n        - label\n        - kind\n\n    FieldDefCreate:\n      type: object\n      properties:\n        key:\n          type: string\n        label:\n          type: string\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n      required:\n        - key\n        - label\n        - kind\n\n    FieldDefUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n        active:\n          type: boolean\n\n    FieldDefOptions:\n      type: object\n      properties:\n        enum:\n          type: array\n          items:\n            type: string\n          description: 'For kind=\"select\". A list of possible values.'\n        multiselect:\n          type: boolean\n          description: 'For kind=\"select\". Whether multiple values can be selected.'\n        relation:\n          type: object\n          description: 'For kind=\"relation\". Defines the relationship target.'\n          properties:\n            targetEntityTypeId:\n              type: string\n              format: uuid\n            cardinality:\n              type: string\n              enum: [one, many]\n          required:\n            - targetEntityTypeId\n            - cardinality\n        formula:\n          type: string\n          description: 'For computed fields. An expression to calculate the field value.'\n          example: 'price * qty'\n        visibleIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional visibility rules for the UI.'\n        requiredIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional requirement rules.'\n\n    FieldDefValidate:\n      type: object\n      description: 'Validation rules that depend on the field kind.'\n      properties:\n        text:\n          type: object\n          properties:\n            minLen:\n              type: integer\n            maxLen:\n              type: integer\n            regex:\n              type: string\n        number:\n          type: object\n          properties:\n            min:\n              type: number\n            max:\n              type: number\n            integer:\n              type: boolean\n        date:\n          type: object\n          properties:\n            min:\n              type: string\n              format: date\n            max:\n              type: string\n              format: date\n\n    FieldDefAcl:\n      type: object\n      description: 'Access control list defining roles for read/write access.'\n      properties:\n        read:\n          type: array\n          items:\n            type: string\n        write:\n          type: array\n          items:\n            type: string\n\n    # Error Schema\n    Error:\n      type: object\n      properties:\n        code:\n          type: string\n          description: 'A machine-readable error code.'\n          example: 'VALIDATION_ERROR'\n        message:\n          type: string\n          description: 'A human-readable error message.'\n          example: 'The request body is invalid.'\n        requestId:\n          type: string\n          format: uuid\n          description: 'A unique identifier for the request, useful for tracing.'\n        errors:\n          type: array\n          items:\n            $ref: '#/components/schemas/ValidationErrorDetail'\n      required:\n        - code\n        - message\n\n    ValidationErrorDetail:\n      type: object\n      properties:\n        path:\n          type: string\n          description: 'The path to the invalid field in the request body.'\n          example: 'budget'\n        code:\n          type: string\n          description: 'A machine-readable code for the specific validation error.'\n          example: 'too_small'\n        message:\n          type: string\n          description: 'A human-readable message for the specific validation error.'\n          example: 'The budget must be at least 0.'\n      required:\n        - path\n        - code\n        - message"
            },
            {
                "path": "apps/api/src/routes/metadata/",
                "content": [
                    {
                        "path": "project/apps/api/src/routes/metadata/schemas.ts",
                        "content": "import { z } from 'zod';\n\n// Reusable parameter schemas\nexport const entityTypeIdParamsSchema = z.object({\n  entityTypeId: z.string().uuid(),\n});\n\nexport const fieldIdParamsSchema = z.object({\n  fieldId: z.string().uuid(),\n});\n\n// Entity Type Schemas\nexport const entityTypeSchema = z.object({\n  id: z.string().uuid(),\n  key: z.string(),\n  label: z.string(),\n  description: z.string().nullable(),\n});\n\nexport const createEntityTypeBodySchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  description: z.string().nullable().optional(),\n});\n\nexport const updateEntityTypeBodySchema = z.object({\n  label: z.string().optional(),\n  description: z.string().nullable().optional(),\n});\n\n// Field Definition Schemas\nconst fieldKindEnum = z.enum([\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nexport const fieldDefSchema = z.object({\n  id: z.string().uuid(),\n  entityTypeId: z.string().uuid(),\n  key: z.string(),\n  label: z.string(),\n  kind: fieldKindEnum,\n  required: z.boolean(),\n  uniqueWithinType: z.boolean(),\n  searchable: z.boolean(),\n  indexed: z.boolean(),\n  options: z.record(z.any()),\n  validate: z.record(z.any()),\n  acl: z.record(z.any()),\n  position: z.number().int(),\n  active: z.boolean(),\n});\n\nexport const createFieldDefBodySchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  kind: fieldKindEnum,\n  required: z.boolean().optional(),\n  uniqueWithinType: z.boolean().optional(),\n  searchable: z.boolean().optional(),\n  indexed: z.boolean().optional(),\n  options: z.record(z.any()).optional(),\n  validate: z.record(z.any()).optional(),\n  acl: z.record(z.any()).optional(),\n  position: z.number().int().optional(),\n});\n\nexport const updateFieldDefBodySchema = z.object({\n  label: z.string().optional(),\n  required: z.boolean().optional(),\n  uniqueWithinType: z.boolean().optional(),\n  searchable: z.boolean().optional(),\n  indexed: z.boolean().optional(),\n  options: z.record(z.any()).optional(),\n  validate: z.record(z.any()).optional(),\n  acl: z.record(z.any()).optional(),\n  position: z.number().int().optional(),\n  active: z.boolean().optional(),\n});"
                    },
                    {
                        "path": "project/apps/api/src/routes/metadata/index.ts",
                        "content": "import { FastifyPluginAsync } from 'fastify';\nimport { z } from 'zod';\nimport * as dal from '../../lib/dal/metadata';\nimport {\n  createEntityTypeBodySchema,\n  entityTypeSchema,\n  updateEntityTypeBodySchema,\n  entityTypeIdParamsSchema,\n  fieldIdParamsSchema,\n  fieldDefSchema,\n  createFieldDefBodySchema,\n  updateFieldDefBodySchema,\n} from './schemas';\n\nconst metadataRoutes: FastifyPluginAsync = async (fastify) => {\n  // A placeholder tenantId until authentication is implemented\n  const tenantId = '00000000-0000-0000-0000-000000000000';\n\n  //\n  // Entity Type Routes\n  //\n\n  fastify.get(\n    '/entity-types',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'List Entity Types',\n        response: {\n          200: z.array(entityTypeSchema),\n        },\n      },\n    },\n    async (request, reply) => {\n      const entityTypes = await dal.findEntityTypesByTenant(\n        request.db,\n        tenantId,\n      );\n      return reply.send(entityTypes);\n    },\n  );\n\n  fastify.post(\n    '/entity-types',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Create Entity Type',\n        body: createEntityTypeBodySchema,\n        response: {\n          201: entityTypeSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const newEntityType = await dal.createEntityType(\n        request.db,\n        tenantId,\n        request.body,\n      );\n      return reply.code(201).send(newEntityType);\n    },\n  );\n\n  fastify.patch(\n    '/entity-types/:entityTypeId',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Update Entity Type',\n        params: entityTypeIdParamsSchema,\n        body: updateEntityTypeBodySchema,\n        response: {\n          200: entityTypeSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const existing = await dal.findEntityTypeById(\n        request.db,\n        tenantId,\n        entityTypeId,\n      );\n      if (!existing) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const updatedEntityType = await dal.updateEntityType(\n        request.db,\n        tenantId,\n        entityTypeId,\n        request.body,\n      );\n      return reply.send(updatedEntityType);\n    },\n  );\n\n  //\n  // Field Definition Routes\n  //\n\n  fastify.get(\n    '/entity-types/:entityTypeId/fields',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'List Field Definitions',\n        params: entityTypeIdParamsSchema,\n        response: {\n          200: z.array(fieldDefSchema),\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const entityType = await dal.findEntityTypeById(\n        request.db,\n        tenantId,\n        entityTypeId,\n      );\n      if (!entityType) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const fieldDefs = await dal.findFieldDefsByEntityType(\n        request.db,\n        tenantId,\n        entityTypeId,\n      );\n      return reply.send(fieldDefs);\n    },\n  );\n\n  fastify.post(\n    '/entity-types/:entityTypeId/fields',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Create Field Definition',\n        params: entityTypeIdParamsSchema,\n        body: createFieldDefBodySchema,\n        response: {\n          201: fieldDefSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const entityType = await dal.findEntityTypeById(\n        request.db,\n        tenantId,\n        entityTypeId,\n      );\n      if (!entityType) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const newFieldDef = await dal.createFieldDef(\n        request.db,\n        tenantId,\n        entityTypeId,\n        request.body,\n      );\n      return reply.code(201).send(newFieldDef);\n    },\n  );\n\n  fastify.patch(\n    '/fields/:fieldId',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Update Field Definition',\n        params: fieldIdParamsSchema,\n        body: updateFieldDefBodySchema,\n        response: {\n          200: fieldDefSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { fieldId } = request.params;\n\n      const existing = await dal.findFieldDefById(request.db, tenantId, fieldId);\n      if (!existing) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Field definition not found' });\n      }\n\n      const updatedFieldDef = await dal.updateFieldDef(\n        request.db,\n        tenantId,\n        fieldId,\n        request.body,\n      );\n      return reply.send(updatedFieldDef);\n    },\n  );\n};\n\nexport default metadataRoutes;"
                    }
                ]
            },
            {
                "path": "apps/api/src/lib/dal/metadata.ts",
                "content": "import { and, eq } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\ntype Db = FastifyInstance['db'];\ntype NewEntityType = typeof schema.entityTypes.$inferInsert;\ntype NewFieldDef = typeof schema.fieldDefs.$inferInsert;\n\n//\n// Entity Type Functions\n//\n\n/**\n * Creates a new entity type for a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param data The data for the new entity type.\n * @returns The newly created entity type.\n */\nexport async function createEntityType(\n  db: Db,\n  tenantId: string,\n  data: Omit<NewEntityType, 'tenantId' | 'id'>,\n) {\n  const [result] = await db\n    .insert(schema.entityTypes)\n    .values({\n      ...data,\n      tenantId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all entity types belonging to a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @returns An array of entity types.\n */\nexport async function findEntityTypesByTenant(db: Db, tenantId: string) {\n  return db.query.entityTypes.findMany({\n    where: eq(schema.entityTypes.tenantId, tenantId),\n  });\n}\n\n/**\n * Finds a single entity type by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to find.\n * @returns The entity type, or undefined if not found.\n */\nexport async function findEntityTypeById(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.entityTypes.findFirst({\n    where: and(\n      eq(schema.entityTypes.id, entityTypeId),\n      eq(schema.entityTypes.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to update.\n * @param data The data to update.\n * @returns The updated entity type.\n */\nexport async function updateEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Partial<Omit<NewEntityType, 'tenantId' | 'id'>>,\n) {\n  const [result] = await db\n    .update(schema.entityTypes)\n    .set(data)\n    .where(\n      and(\n        eq(schema.entityTypes.id, entityTypeId),\n        eq(schema.entityTypes.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n//\n// Field Definition Functions\n//\n\n/**\n * Creates a new field definition for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the parent entity type.\n * @param data The data for the new field definition.\n * @returns The newly created field definition.\n */\nexport async function createFieldDef(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>,\n) {\n  const [result] = await db\n    .insert(schema.fieldDefs)\n    .values({\n      ...data,\n      tenantId,\n      entityTypeId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all field definitions for a specific entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @returns An array of field definitions.\n */\nexport async function findFieldDefsByEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.fieldDefs.findMany({\n    where: and(\n      eq(schema.fieldDefs.tenantId, tenantId),\n      eq(schema.fieldDefs.entityTypeId, entityTypeId),\n    ),\n  });\n}\n\n/**\n * Finds a single field definition by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to find.\n * @returns The field definition, or undefined if not found.\n */\nexport async function findFieldDefById(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n) {\n  return db.query.fieldDefs.findFirst({\n    where: and(\n      eq(schema.fieldDefs.id, fieldDefId),\n      eq(schema.fieldDefs.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing field definition.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to update.\n * @param data The data to update.\n * @returns The updated field definition.\n */\nexport async function updateFieldDef(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n  data: Partial<Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>>,\n) {\n  const [result] = await db\n    .update(schema.fieldDefs)\n    .set(data)\n    .where(\n      and(\n        eq(schema.fieldDefs.id, fieldDefId),\n        eq(schema.fieldDefs.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}"
            }
        ]
    },
    {
        "name": "I2.T5",
        "context": {
            "task_id": "I2.T5",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Implement the database triggers for relation type checking (`edges_validate`) and the RLS policies for all tables, along with the API middleware to set `app.tenant_id` for each request.",
            "agent_type_hint": "DatabaseAgent",
            "inputs": "Section 6.6 and 6.7 of the manifest.",
            "target_files": [
                "packages/db/migrations/0001_triggers_and_rls.sql",
                "apps/api/src/plugins/tenant_context.ts"
            ],
            "input_files": [
                "packages/db/migrations/"
            ],
            "deliverables": "A new SQL migration file and a Fastify plugin.",
            "acceptance_criteria": "The migration applies successfully. The middleware correctly sets the tenant ID on the database connection.",
            "dependencies": [
                "I1.T3",
                "I2.T1"
            ],
            "parallelizable": false
        },
        "output": "I will now implement the required database triggers, Row-Level Security (RLS) policies, and the API middleware for setting the tenant context.\n\nFirst, I will create a new SQL migration file to define the `edges_validate` trigger and enable RLS for all tenant-scoped tables. This ensures data integrity for relationships and strict data isolation between tenants at the database level.\n\nNext, I will create a new Fastify plugin. This plugin will act as middleware, running before every request. It will extract a tenant ID from the `x-tenant-id` header, validate it, and then set a session-level configuration variable (`app.tenant_id`) in PostgreSQL. This variable is crucial for the RLS policies to work correctly, as they will filter data based on its value.\n\nFinally, I will register this new plugin in the main API server file, ensuring it loads after the database connection is established but before any routes are processed. This guarantees that the tenant context is set for every database query made during a request.\n\n~~~sql\n#- file: packages/db/migrations/0001_triggers_and_rls.sql\n-- Section 6.6: Relation Type Check Trigger\nCREATE FUNCTION edges_validate() RETURNS trigger AS $$\nDECLARE\n  tgt uuid;\nBEGIN\n  SELECT (options->'relation'->>'target_entity_type_id')::uuid INTO tgt\n  FROM field_defs WHERE id = NEW.field_id;\n\n  IF tgt IS NULL THEN\n    RAISE EXCEPTION 'field_id % is not relation', NEW.field_id;\n  END IF;\n\n  IF (SELECT entity_type_id FROM records WHERE id = NEW.to_record_id) != tgt THEN\n    RAISE EXCEPTION 'edge target type mismatch';\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_edges_validate\nBEFORE INSERT OR UPDATE ON edges\nFOR EACH ROW EXECUTE FUNCTION edges_validate();\n\n\n-- Section 6.7: Row-Level Security (RLS)\n-- Enable RLS for all tenant-scoped tables\nALTER TABLE entity_types ENABLE ROW LEVEL SECURITY;\nALTER TABLE field_defs ENABLE ROW LEVEL SECURITY;\nALTER TABLE records ENABLE ROW LEVEL SECURITY;\nALTER TABLE edges ENABLE ROW LEVEL SECURITY;\nALTER TABLE record_versions ENABLE ROW LEVEL SECURITY;\nALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;\n\n-- Create policies to restrict access to the current tenant\nCREATE POLICY tenant_only_entity_types ON entity_types\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_field_defs ON field_defs\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_records ON records\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_edges ON edges\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_audit_log ON audit_log\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\n-- record_versions is special as it does not have a tenant_id column.\n-- The policy must be based on the tenant_id of the associated record.\nCREATE POLICY tenant_only_record_versions ON record_versions\n  FOR ALL\n  USING (\n    EXISTS (\n      SELECT 1\n      FROM records\n      WHERE records.id = record_versions.record_id\n      AND records.tenant_id = current_setting('app.tenant_id')::uuid\n    )\n  );\n~~~\n~~~typescript\n#- file: apps/api/src/plugins/tenant_context.ts\nimport { FastifyPluginAsync } from 'fastify';\nimport fp from 'fastify-plugin';\nimport { sql } from 'drizzle-orm';\nimport { ZodError, z } from 'zod';\n\nconst tenantIdSchema = z.string().uuid({ message: 'Invalid tenant ID format.' });\n\nconst tenantContextPlugin: FastifyPluginAsync = async (fastify) => {\n  fastify.addHook('preHandler', async (request, reply) => {\n    const tenantId = request.headers['x-tenant-id'];\n\n    if (!tenantId || typeof tenantId !== 'string') {\n      return reply.status(400).send({\n        code: 'BAD_REQUEST',\n        message: 'x-tenant-id header is required.',\n      });\n    }\n\n    try {\n      const validatedTenantId = tenantIdSchema.parse(tenantId);\n      // The third argument `true` makes the setting local to the current transaction.\n      await request.server.db.execute(\n        sql`SELECT set_config('app.tenant_id', ${validatedTenantId}, true)`,\n      );\n    } catch (err) {\n      if (err instanceof ZodError) {\n        return reply.status(400).send({\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid x-tenant-id header.',\n          errors: err.errors,\n        });\n      }\n      request.log.error(err, 'Failed to set tenant context');\n      return reply.status(500).send({\n        code: 'INTERNAL_SERVER_ERROR',\n        message: 'An unexpected error occurred while setting tenant context.',\n      });\n    }\n  });\n};\n\nexport default fp(tenantContextPlugin, {\n  name: 'tenantContext',\n  dependencies: ['db'],\n});\n~~~\n~~~edits\n#- file: apps/api/src/server.ts\n***start_edit\nLITERAL\n***search\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\nimport metadataRoutes from './routes/metadata';\n***replace\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\nimport metadataRoutes from './routes/metadata';\nimport tenantContextPlugin from './plugins/tenant_context';\n***description\nImport the newly created tenant context plugin to be registered with the Fastify server.\n***end_edit\n***start_edit\nLITERAL\n***search\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(healthRoutes);\n***replace\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(tenantContextPlugin);\n  await server.register(healthRoutes);\n***description\nRegister the tenant context plugin. It's crucial to register it after the database plugin (so `server.db` is available) and before any routes that will access the database, ensuring the tenant context is set for all queries.\n***end_edit\n~~~",
        "iteration_id": "I2",
        "completed": true,
        "target_files": [
            "packages/db/migrations/0001_triggers_and_rls.sql",
            "apps/api/src/plugins/tenant_context.ts"
        ],
        "input_files": [
            "packages/db/migrations/"
        ],
        "files": [
            {
                "path": "packages/db/migrations/",
                "content": [
                    {
                        "path": "project/packages/db/migrations/0000_curvy_mysterio.sql",
                        "content": "CREATE TYPE \"field_kind\" AS ENUM('text', 'number', 'date', 'select', 'relation', 'boolean');\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"audit_log\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"actor_id\" uuid,\n\t\"action\" text NOT NULL,\n\t\"resource_type\" text NOT NULL,\n\t\"resource_id\" uuid,\n\t\"meta\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"edges\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"field_id\" uuid NOT NULL,\n\t\"from_record_id\" uuid NOT NULL,\n\t\"to_record_id\" uuid NOT NULL,\n\t\"created_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\tCONSTRAINT \"edges_tenant_id_field_id_from_record_id_to_record_id_unique\" UNIQUE(\"tenant_id\",\"field_id\",\"from_record_id\",\"to_record_id\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"entity_types\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"description\" text,\n\tCONSTRAINT \"entity_types_tenant_id_key_unique\" UNIQUE(\"tenant_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"field_defs\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"kind\" \"field_kind\" NOT NULL,\n\t\"required\" boolean DEFAULT false NOT NULL,\n\t\"unique_within_type\" boolean DEFAULT false NOT NULL,\n\t\"searchable\" boolean DEFAULT true NOT NULL,\n\t\"indexed\" boolean DEFAULT false NOT NULL,\n\t\"options\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"validate\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"acl\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"position\" integer DEFAULT 0 NOT NULL,\n\t\"active\" boolean DEFAULT true NOT NULL,\n\tCONSTRAINT \"field_defs_tenant_id_entity_type_id_key_unique\" UNIQUE(\"tenant_id\",\"entity_type_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"record_versions\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"record_id\" uuid NOT NULL,\n\t\"version\" integer NOT NULL,\n\t\"data\" jsonb NOT NULL,\n\t\"changed_by\" uuid,\n\t\"changed_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"records\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"data\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"fts\" tsvector,\n\t\"version\" integer DEFAULT 1 NOT NULL,\n\t\"created_by\" uuid,\n\t\"updated_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"tenants\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"name\" text NOT NULL,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_field_id_field_defs_id_fk\" FOREIGN KEY (\"field_id\") REFERENCES \"public\".\"field_defs\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_from_record_id_records_id_fk\" FOREIGN KEY (\"from_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_to_record_id_records_id_fk\" FOREIGN KEY (\"to_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"entity_types\" ADD CONSTRAINT \"entity_types_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"record_versions\" ADD CONSTRAINT \"record_versions_record_id_records_id_fk\" FOREIGN KEY (\"record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"audit_log\" ADD CONSTRAINT \"audit_log_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;"
                    },
                    {
                        "path": "project/packages/db/migrations/.gitkeep",
                        "content": ""
                    }
                ]
            },
            {
                "path": "packages/db/migrations/",
                "content": [
                    {
                        "path": "project/packages/db/migrations/0000_curvy_mysterio.sql",
                        "content": "CREATE TYPE \"field_kind\" AS ENUM('text', 'number', 'date', 'select', 'relation', 'boolean');\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"audit_log\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"actor_id\" uuid,\n\t\"action\" text NOT NULL,\n\t\"resource_type\" text NOT NULL,\n\t\"resource_id\" uuid,\n\t\"meta\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"edges\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"field_id\" uuid NOT NULL,\n\t\"from_record_id\" uuid NOT NULL,\n\t\"to_record_id\" uuid NOT NULL,\n\t\"created_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\tCONSTRAINT \"edges_tenant_id_field_id_from_record_id_to_record_id_unique\" UNIQUE(\"tenant_id\",\"field_id\",\"from_record_id\",\"to_record_id\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"entity_types\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"description\" text,\n\tCONSTRAINT \"entity_types_tenant_id_key_unique\" UNIQUE(\"tenant_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"field_defs\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"kind\" \"field_kind\" NOT NULL,\n\t\"required\" boolean DEFAULT false NOT NULL,\n\t\"unique_within_type\" boolean DEFAULT false NOT NULL,\n\t\"searchable\" boolean DEFAULT true NOT NULL,\n\t\"indexed\" boolean DEFAULT false NOT NULL,\n\t\"options\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"validate\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"acl\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"position\" integer DEFAULT 0 NOT NULL,\n\t\"active\" boolean DEFAULT true NOT NULL,\n\tCONSTRAINT \"field_defs_tenant_id_entity_type_id_key_unique\" UNIQUE(\"tenant_id\",\"entity_type_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"record_versions\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"record_id\" uuid NOT NULL,\n\t\"version\" integer NOT NULL,\n\t\"data\" jsonb NOT NULL,\n\t\"changed_by\" uuid,\n\t\"changed_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"records\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"data\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"fts\" tsvector,\n\t\"version\" integer DEFAULT 1 NOT NULL,\n\t\"created_by\" uuid,\n\t\"updated_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"tenants\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"name\" text NOT NULL,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_field_id_field_defs_id_fk\" FOREIGN KEY (\"field_id\") REFERENCES \"public\".\"field_defs\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_from_record_id_records_id_fk\" FOREIGN KEY (\"from_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_to_record_id_records_id_fk\" FOREIGN KEY (\"to_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"entity_types\" ADD CONSTRAINT \"entity_types_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"record_versions\" ADD CONSTRAINT \"record_versions_record_id_records_id_fk\" FOREIGN KEY (\"record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"audit_log\" ADD CONSTRAINT \"audit_log_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;"
                    },
                    {
                        "path": "project/packages/db/migrations/.gitkeep",
                        "content": ""
                    },
                    {
                        "path": "project/packages/db/migrations/0001_triggers_and_rls.sql",
                        "content": "-- Section 6.6: Relation Type Check Trigger\nCREATE FUNCTION edges_validate() RETURNS trigger AS $$\nDECLARE\n  tgt uuid;\nBEGIN\n  SELECT (options->'relation'->>'target_entity_type_id')::uuid INTO tgt\n  FROM field_defs WHERE id = NEW.field_id;\n\n  IF tgt IS NULL THEN\n    RAISE EXCEPTION 'field_id % is not relation', NEW.field_id;\n  END IF;\n\n  IF (SELECT entity_type_id FROM records WHERE id = NEW.to_record_id) != tgt THEN\n    RAISE EXCEPTION 'edge target type mismatch';\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_edges_validate\nBEFORE INSERT OR UPDATE ON edges\nFOR EACH ROW EXECUTE FUNCTION edges_validate();\n\n\n-- Section 6.7: Row-Level Security (RLS)\n-- Enable RLS for all tenant-scoped tables\nALTER TABLE entity_types ENABLE ROW LEVEL SECURITY;\nALTER TABLE field_defs ENABLE ROW LEVEL SECURITY;\nALTER TABLE records ENABLE ROW LEVEL SECURITY;\nALTER TABLE edges ENABLE ROW LEVEL SECURITY;\nALTER TABLE record_versions ENABLE ROW LEVEL SECURITY;\nALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;\n\n-- Create policies to restrict access to the current tenant\nCREATE POLICY tenant_only_entity_types ON entity_types\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_field_defs ON field_defs\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_records ON records\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_edges ON edges\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_audit_log ON audit_log\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\n-- record_versions is special as it does not have a tenant_id column.\n-- The policy must be based on the tenant_id of the associated record.\nCREATE POLICY tenant_only_record_versions ON record_versions\n  FOR ALL\n  USING (\n    EXISTS (\n      SELECT 1\n      FROM records\n      WHERE records.id = record_versions.record_id\n      AND records.tenant_id = current_setting('app.tenant_id')::uuid\n    )\n  );"
                    }
                ]
            },
            {
                "path": "apps/api/src/plugins/tenant_context.ts",
                "content": "import { FastifyPluginAsync } from 'fastify';\nimport fp from 'fastify-plugin';\nimport { sql } from 'drizzle-orm';\nimport { ZodError, z } from 'zod';\n\nconst tenantIdSchema = z.string().uuid({ message: 'Invalid tenant ID format.' });\n\nconst tenantContextPlugin: FastifyPluginAsync = async (fastify) => {\n  fastify.addHook('preHandler', async (request, reply) => {\n    const tenantId = request.headers['x-tenant-id'];\n\n    if (!tenantId || typeof tenantId !== 'string') {\n      return reply.status(400).send({\n        code: 'BAD_REQUEST',\n        message: 'x-tenant-id header is required.',\n      });\n    }\n\n    try {\n      const validatedTenantId = tenantIdSchema.parse(tenantId);\n      // The third argument `true` makes the setting local to the current transaction.\n      await request.server.db.execute(\n        sql`SELECT set_config('app.tenant_id', ${validatedTenantId}, true)`,\n      );\n    } catch (err) {\n      if (err instanceof ZodError) {\n        return reply.status(400).send({\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid x-tenant-id header.',\n          errors: err.errors,\n        });\n      }\n      request.log.error(err, 'Failed to set tenant context');\n      return reply.status(500).send({\n        code: 'INTERNAL_SERVER_ERROR',\n        message: 'An unexpected error occurred while setting tenant context.',\n      });\n    }\n  });\n};\n\nexport default fp(tenantContextPlugin, {\n  name: 'tenantContext',\n  dependencies: ['db'],\n});"
            },
            {
                "path": "packages/db/migrations/0001_triggers_and_rls.sql",
                "content": "-- Section 6.6: Relation Type Check Trigger\nCREATE FUNCTION edges_validate() RETURNS trigger AS $$\nDECLARE\n  tgt uuid;\nBEGIN\n  SELECT (options->'relation'->>'target_entity_type_id')::uuid INTO tgt\n  FROM field_defs WHERE id = NEW.field_id;\n\n  IF tgt IS NULL THEN\n    RAISE EXCEPTION 'field_id % is not relation', NEW.field_id;\n  END IF;\n\n  IF (SELECT entity_type_id FROM records WHERE id = NEW.to_record_id) != tgt THEN\n    RAISE EXCEPTION 'edge target type mismatch';\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_edges_validate\nBEFORE INSERT OR UPDATE ON edges\nFOR EACH ROW EXECUTE FUNCTION edges_validate();\n\n\n-- Section 6.7: Row-Level Security (RLS)\n-- Enable RLS for all tenant-scoped tables\nALTER TABLE entity_types ENABLE ROW LEVEL SECURITY;\nALTER TABLE field_defs ENABLE ROW LEVEL SECURITY;\nALTER TABLE records ENABLE ROW LEVEL SECURITY;\nALTER TABLE edges ENABLE ROW LEVEL SECURITY;\nALTER TABLE record_versions ENABLE ROW LEVEL SECURITY;\nALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;\n\n-- Create policies to restrict access to the current tenant\nCREATE POLICY tenant_only_entity_types ON entity_types\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_field_defs ON field_defs\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_records ON records\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_edges ON edges\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\nCREATE POLICY tenant_only_audit_log ON audit_log\n  FOR ALL\n  USING (tenant_id = current_setting('app.tenant_id')::uuid);\n\n-- record_versions is special as it does not have a tenant_id column.\n-- The policy must be based on the tenant_id of the associated record.\nCREATE POLICY tenant_only_record_versions ON record_versions\n  FOR ALL\n  USING (\n    EXISTS (\n      SELECT 1\n      FROM records\n      WHERE records.id = record_versions.record_id\n      AND records.tenant_id = current_setting('app.tenant_id')::uuid\n    )\n  );"
            }
        ]
    },
    {
        "name": "I3.T1",
        "context": {
            "task_id": "I3.T1",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Update `api/openapi.yaml` to include the endpoints for `records`: `POST /entities/:entityTypeKey`, `GET /entities/:entityTypeKey/:id`, `PATCH /entities/:entityTypeKey/:id`, and `POST /entities/:entityTypeKey/search`.",
            "agent_type_hint": "DocumentationAgent",
            "inputs": "Section 9.2 of the manifest, existing OpenAPI spec.",
            "target_files": [
                "api/openapi.yaml"
            ],
            "input_files": [
                "api/openapi.yaml"
            ],
            "deliverables": "Updated OpenAPI YAML file.",
            "acceptance_criteria": "The spec is valid and includes the new record management endpoints.",
            "dependencies": [
                "I2.T2"
            ],
            "parallelizable": false
        },
        "output": "I will update the `api/openapi.yaml` file to include the new endpoints and schemas for managing records, as per the task instructions. This involves adding a new tag, new paths, new parameters, a new response type, and several new schemas for records and search functionality. Since the changes are extensive and affect multiple sections of the file, I will replace the entire file with its updated content.\n\n~~~\n#- file: api/openapi.yaml\nopenapi: '3.0.3'\ninfo:\n  title: 'Dynamic Data Management System API'\n  description: 'API for managing dynamic entities, fields, records, and relationships.'\n  version: '1.0.0'\nservers:\n  - url: '/api/v1'\n    description: 'API v1'\n\ntags:\n  - name: Metadata\n    description: 'Operations for managing Entity Types and Field Definitions.'\n  - name: Records\n    description: 'Operations for managing Records (instances of an Entity Type).'\n\npaths:\n  /entity-types:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Entity Types'\n      description: 'Retrieves a list of all entity types for the tenant.'\n      operationId: 'listEntityTypes'\n      responses:\n        '200':\n          description: 'A list of entity types.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/EntityType'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Entity Type'\n      description: 'Creates a new entity type.'\n      operationId: 'createEntityType'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeCreate'\n      responses:\n        '201':\n          description: 'Entity type created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n\n  /entity-types/{entityTypeId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Entity Type'\n      description: 'Updates an existing entity type.'\n      operationId: 'updateEntityType'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeUpdate'\n      responses:\n        '200':\n          description: 'Entity type updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entity-types/{entityTypeId}/fields:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Field Definitions'\n      description: 'Retrieves a list of all field definitions for a given entity type.'\n      operationId: 'listFieldDefs'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      responses:\n        '200':\n          description: 'A list of field definitions.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/FieldDef'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Field Definition'\n      description: 'Creates a new field definition for an entity type.'\n      operationId: 'createFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefCreate'\n      responses:\n        '201':\n          description: 'Field definition created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}:\n    post:\n      tags:\n        - Records\n      summary: 'Create Record'\n      description: 'Creates a new record for a given entity type.'\n      operationId: 'createRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/RecordCreate'\n      responses:\n        '201':\n          description: 'Record created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}/search:\n    post:\n      tags:\n        - Records\n      summary: 'Search Records'\n      description: 'Searches for records of a given entity type using a filter.'\n      operationId: 'searchRecords'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/SearchRequest'\n      responses:\n        '200':\n          description: 'A list of matching records.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/SearchResponse'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}/{recordId}:\n    get:\n      tags:\n        - Records\n      summary: 'Get Record by ID'\n      description: 'Retrieves a single record by its ID.'\n      operationId: 'getRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n        - $ref: '#/components/parameters/recordId'\n      responses:\n        '200':\n          description: 'The requested record.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    patch:\n      tags:\n        - Records\n      summary: 'Update Record'\n      description: 'Updates an existing record. Uses optimistic locking via a version number.'\n      operationId: 'updateRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n        - $ref: '#/components/parameters/recordId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/RecordUpdate'\n      responses:\n        '200':\n          description: 'Record updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '409':\n          $ref: '#/components/responses/Conflict'\n\n  /fields/{fieldId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Field Definition'\n      description: 'Updates an existing field definition.'\n      operationId: 'updateFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/fieldId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefUpdate'\n      responses:\n        '200':\n          description: 'Field definition updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  parameters:\n    entityTypeId:\n      name: entityTypeId\n      in: path\n      required: true\n      description: 'The ID of the entity type.'\n      schema:\n        type: string\n        format: uuid\n    entityTypeKey:\n      name: entityTypeKey\n      in: path\n      required: true\n      description: 'The unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n      schema:\n        type: string\n    recordId:\n      name: recordId\n      in: path\n      required: true\n      description: 'The ID of the record.'\n      schema:\n        type: string\n        format: uuid\n    fieldId:\n      name: fieldId\n      in: path\n      required: true\n      description: 'The ID of the field definition.'\n      schema:\n        type: string\n        format: uuid\n\n  responses:\n    BadRequest:\n      description: 'Bad Request - The request body is invalid.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    NotFound:\n      description: 'Not Found - The requested resource does not exist.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    Conflict:\n      description: 'Conflict - The request could not be completed due to a conflict with the current state of the resource, likely an optimistic locking failure.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  schemas:\n    # Entity Type Schemas\n    EntityType:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - id\n        - key\n        - label\n\n    EntityTypeCreate:\n      type: object\n      properties:\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - key\n        - label\n\n    EntityTypeUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n\n    # Field Definition Schemas\n    FieldDef:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the field (e.g., \"status\", \"budget\").'\n        label:\n          type: string\n          description: 'A human-readable label for the field (e.g., \"Status\", \"Budget\").'\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n          default: false\n        uniqueWithinType:\n          type: boolean\n          default: false\n        searchable:\n          type: boolean\n          default: true\n        indexed:\n          type: boolean\n          default: false\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n          default: 0\n        active:\n          type: boolean\n          default: true\n      required:\n        - id\n        - entityTypeId\n        - key\n        - label\n        - kind\n\n    FieldDefCreate:\n      type: object\n      properties:\n        key:\n          type: string\n        label:\n          type: string\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n      required:\n        - key\n        - label\n        - kind\n\n    FieldDefUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n        active:\n          type: boolean\n\n    FieldDefOptions:\n      type: object\n      properties:\n        enum:\n          type: array\n          items:\n            type: string\n          description: 'For kind=\"select\". A list of possible values.'\n        multiselect:\n          type: boolean\n          description: 'For kind=\"select\". Whether multiple values can be selected.'\n        relation:\n          type: object\n          description: 'For kind=\"relation\". Defines the relationship target.'\n          properties:\n            targetEntityTypeId:\n              type: string\n              format: uuid\n            cardinality:\n              type: string\n              enum: [one, many]\n          required:\n            - targetEntityTypeId\n            - cardinality\n        formula:\n          type: string\n          description: 'For computed fields. An expression to calculate the field value.'\n          example: 'price * qty'\n        visibleIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional visibility rules for the UI.'\n        requiredIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional requirement rules.'\n\n    FieldDefValidate:\n      type: object\n      description: 'Validation rules that depend on the field kind.'\n      properties:\n        text:\n          type: object\n          properties:\n            minLen:\n              type: integer\n            maxLen:\n              type: integer\n            regex:\n              type: string\n        number:\n          type: object\n          properties:\n            min:\n              type: number\n            max:\n              type: number\n            integer:\n              type: boolean\n        date:\n          type: object\n          properties:\n            min:\n              type: string\n              format: date\n            max:\n              type: string\n              format: date\n\n    FieldDefAcl:\n      type: object\n      description: 'Access control list defining roles for read/write access.'\n      properties:\n        read:\n          type: array\n          items:\n            type: string\n        write:\n          type: array\n          items:\n            type: string\n\n    # Record Schemas\n    Record:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        version:\n          type: integer\n          description: 'The version number of the record, used for optimistic locking.'\n          readOnly: true\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the custom field data for the record.'\n          example:\n            name: 'AI Roadmap Q4'\n            status: 'Active'\n            budget: 12000\n        createdBy:\n          type: string\n          format: uuid\n          readOnly: true\n          nullable: true\n        updatedBy:\n          type: string\n          format: uuid\n          readOnly: true\n          nullable: true\n        createdAt:\n          type: string\n          format: date-time\n          readOnly: true\n        updatedAt:\n          type: string\n          format: date-time\n          readOnly: true\n      required:\n        - id\n        - entityTypeId\n        - version\n        - data\n        - createdAt\n        - updatedAt\n\n    RecordCreate:\n      type: object\n      properties:\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the custom field data for the new record.'\n      required:\n        - data\n\n    RecordUpdate:\n      type: object\n      properties:\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the fields to update.'\n        version:\n          type: integer\n          description: 'The current version of the record being updated, for optimistic locking.'\n      required:\n        - data\n        - version\n\n    # Search Schemas\n    SearchRequest:\n      type: object\n      properties:\n        filter:\n          $ref: '#/components/schemas/Filter'\n        sort:\n          type: array\n          items:\n            $ref: '#/components/schemas/Sort'\n          description: 'An array of sort objects to apply to the results.'\n        limit:\n          type: integer\n          minimum: 1\n          maximum: 1000\n          default: 50\n          description: 'The maximum number of records to return.'\n        cursor:\n          type: string\n          nullable: true\n          description: 'A cursor for pagination, obtained from a previous search response.'\n\n    SearchResponse:\n      type: object\n      properties:\n        rows:\n          type: array\n          items:\n            $ref: '#/components/schemas/Record'\n        nextCursor:\n          type: string\n          nullable: true\n          description: 'A cursor to retrieve the next page of results. Null if there are no more results.'\n      required:\n        - rows\n\n    Sort:\n      type: object\n      properties:\n        field:\n          type: string\n          description: 'The key of the field to sort by (e.g., \"budget\", \"createdAt\").'\n        dir:\n          type: string\n          enum: [asc, desc]\n          default: asc\n      required:\n        - field\n\n    Filter:\n      type: object\n      description: |\n        A flexible filter object to query records. It can be a logical operator (`and`, `or`, `not`) or a field-level comparison.\n        See the manifest for the full grammar.\n      properties:\n        op:\n          type: string\n          description: 'The operator for the filter.'\n        filters:\n          type: array\n          items:\n            $ref: '#/components/schemas/Filter'\n          description: 'Used with logical operators `and` and `or`.'\n        field:\n          type: string\n          description: 'The key of the field to compare.'\n        value:\n          description: 'The value to compare against.'\n        values:\n          type: array\n          description: 'An array of values for the `in` operator.'\n        query:\n          type: string\n          description: 'The search query for `fulltext` search.'\n      example:\n        op: 'and'\n        filters:\n          - { op: 'eq', field: 'status', value: 'Active' }\n          - { op: 'gte', field: 'budget', value: 10000 }\n          - { op: 'fulltext', query: 'ai roadmap' }\n\n    # Error Schema\n    Error:\n      type: object\n      properties:\n        code:\n          type: string\n          description: 'A machine-readable error code.'\n          example: 'VALIDATION_ERROR'\n        message:\n          type: string\n          description: 'A human-readable error message.'\n          example: 'The request body is invalid.'\n        requestId:\n          type: string\n          format: uuid\n          description: 'A unique identifier for the request, useful for tracing.'\n        errors:\n          type: array\n          items:\n            $ref: '#/components/schemas/ValidationErrorDetail'\n      required:\n        - code\n        - message\n\n    ValidationErrorDetail:\n      type: object\n      properties:\n        path:\n          type: string\n          description: 'The path to the invalid field in the request body.'\n          example: 'budget'\n        code:\n          type: string\n          description: 'A machine-readable code for the specific validation error.'\n          example: 'too_small'\n        message:\n          type: string\n          description: 'A human-readable message for the specific validation error.'\n          example: 'The budget must be at least 0.'\n      required:\n        - path\n        - code\n        - message\n~~~",
        "iteration_id": "I3",
        "completed": true,
        "target_files": [
            "api/openapi.yaml"
        ],
        "input_files": [
            "api/openapi.yaml"
        ],
        "files": [
            {
                "path": "api/openapi.yaml",
                "content": "openapi: '3.0.3'\ninfo:\n  title: 'Dynamic Data Management System API'\n  description: 'API for managing dynamic entities, fields, records, and relationships.'\n  version: '1.0.0'\nservers:\n  - url: '/api/v1'\n    description: 'API v1'\n\ntags:\n  - name: Metadata\n    description: 'Operations for managing Entity Types and Field Definitions.'\n\npaths:\n  /entity-types:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Entity Types'\n      description: 'Retrieves a list of all entity types for the tenant.'\n      operationId: 'listEntityTypes'\n      responses:\n        '200':\n          description: 'A list of entity types.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/EntityType'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Entity Type'\n      description: 'Creates a new entity type.'\n      operationId: 'createEntityType'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeCreate'\n      responses:\n        '201':\n          description: 'Entity type created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n\n  /entity-types/{entityTypeId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Entity Type'\n      description: 'Updates an existing entity type.'\n      operationId: 'updateEntityType'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeUpdate'\n      responses:\n        '200':\n          description: 'Entity type updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entity-types/{entityTypeId}/fields:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Field Definitions'\n      description: 'Retrieves a list of all field definitions for a given entity type.'\n      operationId: 'listFieldDefs'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      responses:\n        '200':\n          description: 'A list of field definitions.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/FieldDef'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Field Definition'\n      description: 'Creates a new field definition for an entity type.'\n      operationId: 'createFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefCreate'\n      responses:\n        '201':\n          description: 'Field definition created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /fields/{fieldId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Field Definition'\n      description: 'Updates an existing field definition.'\n      operationId: 'updateFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/fieldId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefUpdate'\n      responses:\n        '200':\n          description: 'Field definition updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  parameters:\n    entityTypeId:\n      name: entityTypeId\n      in: path\n      required: true\n      description: 'The ID of the entity type.'\n      schema:\n        type: string\n        format: uuid\n    fieldId:\n      name: fieldId\n      in: path\n      required: true\n      description: 'The ID of the field definition.'\n      schema:\n        type: string\n        format: uuid\n\n  responses:\n    BadRequest:\n      description: 'Bad Request - The request body is invalid.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    NotFound:\n      description: 'Not Found - The requested resource does not exist.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  schemas:\n    # Entity Type Schemas\n    EntityType:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - id\n        - key\n        - label\n\n    EntityTypeCreate:\n      type: object\n      properties:\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - key\n        - label\n\n    EntityTypeUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n\n    # Field Definition Schemas\n    FieldDef:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the field (e.g., \"status\", \"budget\").'\n        label:\n          type: string\n          description: 'A human-readable label for the field (e.g., \"Status\", \"Budget\").'\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n          default: false\n        uniqueWithinType:\n          type: boolean\n          default: false\n        searchable:\n          type: boolean\n          default: true\n        indexed:\n          type: boolean\n          default: false\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n          default: 0\n        active:\n          type: boolean\n          default: true\n      required:\n        - id\n        - entityTypeId\n        - key\n        - label\n        - kind\n\n    FieldDefCreate:\n      type: object\n      properties:\n        key:\n          type: string\n        label:\n          type: string\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n      required:\n        - key\n        - label\n        - kind\n\n    FieldDefUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n        active:\n          type: boolean\n\n    FieldDefOptions:\n      type: object\n      properties:\n        enum:\n          type: array\n          items:\n            type: string\n          description: 'For kind=\"select\". A list of possible values.'\n        multiselect:\n          type: boolean\n          description: 'For kind=\"select\". Whether multiple values can be selected.'\n        relation:\n          type: object\n          description: 'For kind=\"relation\". Defines the relationship target.'\n          properties:\n            targetEntityTypeId:\n              type: string\n              format: uuid\n            cardinality:\n              type: string\n              enum: [one, many]\n          required:\n            - targetEntityTypeId\n            - cardinality\n        formula:\n          type: string\n          description: 'For computed fields. An expression to calculate the field value.'\n          example: 'price * qty'\n        visibleIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional visibility rules for the UI.'\n        requiredIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional requirement rules.'\n\n    FieldDefValidate:\n      type: object\n      description: 'Validation rules that depend on the field kind.'\n      properties:\n        text:\n          type: object\n          properties:\n            minLen:\n              type: integer\n            maxLen:\n              type: integer\n            regex:\n              type: string\n        number:\n          type: object\n          properties:\n            min:\n              type: number\n            max:\n              type: number\n            integer:\n              type: boolean\n        date:\n          type: object\n          properties:\n            min:\n              type: string\n              format: date\n            max:\n              type: string\n              format: date\n\n    FieldDefAcl:\n      type: object\n      description: 'Access control list defining roles for read/write access.'\n      properties:\n        read:\n          type: array\n          items:\n            type: string\n        write:\n          type: array\n          items:\n            type: string\n\n    # Error Schema\n    Error:\n      type: object\n      properties:\n        code:\n          type: string\n          description: 'A machine-readable error code.'\n          example: 'VALIDATION_ERROR'\n        message:\n          type: string\n          description: 'A human-readable error message.'\n          example: 'The request body is invalid.'\n        requestId:\n          type: string\n          format: uuid\n          description: 'A unique identifier for the request, useful for tracing.'\n        errors:\n          type: array\n          items:\n            $ref: '#/components/schemas/ValidationErrorDetail'\n      required:\n        - code\n        - message\n\n    ValidationErrorDetail:\n      type: object\n      properties:\n        path:\n          type: string\n          description: 'The path to the invalid field in the request body.'\n          example: 'budget'\n        code:\n          type: string\n          description: 'A machine-readable code for the specific validation error.'\n          example: 'too_small'\n        message:\n          type: string\n          description: 'A human-readable message for the specific validation error.'\n          example: 'The budget must be at least 0.'\n      required:\n        - path\n        - code\n        - message"
            },
            {
                "path": "api/openapi.yaml",
                "content": "openapi: '3.0.3'\ninfo:\n  title: 'Dynamic Data Management System API'\n  description: 'API for managing dynamic entities, fields, records, and relationships.'\n  version: '1.0.0'\nservers:\n  - url: '/api/v1'\n    description: 'API v1'\n\ntags:\n  - name: Metadata\n    description: 'Operations for managing Entity Types and Field Definitions.'\n  - name: Records\n    description: 'Operations for managing Records (instances of an Entity Type).'\n\npaths:\n  /entity-types:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Entity Types'\n      description: 'Retrieves a list of all entity types for the tenant.'\n      operationId: 'listEntityTypes'\n      responses:\n        '200':\n          description: 'A list of entity types.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/EntityType'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Entity Type'\n      description: 'Creates a new entity type.'\n      operationId: 'createEntityType'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeCreate'\n      responses:\n        '201':\n          description: 'Entity type created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n\n  /entity-types/{entityTypeId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Entity Type'\n      description: 'Updates an existing entity type.'\n      operationId: 'updateEntityType'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeUpdate'\n      responses:\n        '200':\n          description: 'Entity type updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entity-types/{entityTypeId}/fields:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Field Definitions'\n      description: 'Retrieves a list of all field definitions for a given entity type.'\n      operationId: 'listFieldDefs'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      responses:\n        '200':\n          description: 'A list of field definitions.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/FieldDef'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Field Definition'\n      description: 'Creates a new field definition for an entity type.'\n      operationId: 'createFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefCreate'\n      responses:\n        '201':\n          description: 'Field definition created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}:\n    post:\n      tags:\n        - Records\n      summary: 'Create Record'\n      description: 'Creates a new record for a given entity type.'\n      operationId: 'createRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/RecordCreate'\n      responses:\n        '201':\n          description: 'Record created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}/search:\n    post:\n      tags:\n        - Records\n      summary: 'Search Records'\n      description: 'Searches for records of a given entity type using a filter.'\n      operationId: 'searchRecords'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/SearchRequest'\n      responses:\n        '200':\n          description: 'A list of matching records.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/SearchResponse'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}/{recordId}:\n    get:\n      tags:\n        - Records\n      summary: 'Get Record by ID'\n      description: 'Retrieves a single record by its ID.'\n      operationId: 'getRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n        - $ref: '#/components/parameters/recordId'\n      responses:\n        '200':\n          description: 'The requested record.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    patch:\n      tags:\n        - Records\n      summary: 'Update Record'\n      description: 'Updates an existing record. Uses optimistic locking via a version number.'\n      operationId: 'updateRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n        - $ref: '#/components/parameters/recordId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/RecordUpdate'\n      responses:\n        '200':\n          description: 'Record updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '409':\n          $ref: '#/components/responses/Conflict'\n\n  /fields/{fieldId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Field Definition'\n      description: 'Updates an existing field definition.'\n      operationId: 'updateFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/fieldId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefUpdate'\n      responses:\n        '200':\n          description: 'Field definition updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  parameters:\n    entityTypeId:\n      name: entityTypeId\n      in: path\n      required: true\n      description: 'The ID of the entity type.'\n      schema:\n        type: string\n        format: uuid\n    entityTypeKey:\n      name: entityTypeKey\n      in: path\n      required: true\n      description: 'The unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n      schema:\n        type: string\n    recordId:\n      name: recordId\n      in: path\n      required: true\n      description: 'The ID of the record.'\n      schema:\n        type: string\n        format: uuid\n    fieldId:\n      name: fieldId\n      in: path\n      required: true\n      description: 'The ID of the field definition.'\n      schema:\n        type: string\n        format: uuid\n\n  responses:\n    BadRequest:\n      description: 'Bad Request - The request body is invalid.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    NotFound:\n      description: 'Not Found - The requested resource does not exist.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    Conflict:\n      description: 'Conflict - The request could not be completed due to a conflict with the current state of the resource, likely an optimistic locking failure.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  schemas:\n    # Entity Type Schemas\n    EntityType:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - id\n        - key\n        - label\n\n    EntityTypeCreate:\n      type: object\n      properties:\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - key\n        - label\n\n    EntityTypeUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n\n    # Field Definition Schemas\n    FieldDef:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the field (e.g., \"status\", \"budget\").'\n        label:\n          type: string\n          description: 'A human-readable label for the field (e.g., \"Status\", \"Budget\").'\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n          default: false\n        uniqueWithinType:\n          type: boolean\n          default: false\n        searchable:\n          type: boolean\n          default: true\n        indexed:\n          type: boolean\n          default: false\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n          default: 0\n        active:\n          type: boolean\n          default: true\n      required:\n        - id\n        - entityTypeId\n        - key\n        - label\n        - kind\n\n    FieldDefCreate:\n      type: object\n      properties:\n        key:\n          type: string\n        label:\n          type: string\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n      required:\n        - key\n        - label\n        - kind\n\n    FieldDefUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n        active:\n          type: boolean\n\n    FieldDefOptions:\n      type: object\n      properties:\n        enum:\n          type: array\n          items:\n            type: string\n          description: 'For kind=\"select\". A list of possible values.'\n        multiselect:\n          type: boolean\n          description: 'For kind=\"select\". Whether multiple values can be selected.'\n        relation:\n          type: object\n          description: 'For kind=\"relation\". Defines the relationship target.'\n          properties:\n            targetEntityTypeId:\n              type: string\n              format: uuid\n            cardinality:\n              type: string\n              enum: [one, many]\n          required:\n            - targetEntityTypeId\n            - cardinality\n        formula:\n          type: string\n          description: 'For computed fields. An expression to calculate the field value.'\n          example: 'price * qty'\n        visibleIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional visibility rules for the UI.'\n        requiredIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional requirement rules.'\n\n    FieldDefValidate:\n      type: object\n      description: 'Validation rules that depend on the field kind.'\n      properties:\n        text:\n          type: object\n          properties:\n            minLen:\n              type: integer\n            maxLen:\n              type: integer\n            regex:\n              type: string\n        number:\n          type: object\n          properties:\n            min:\n              type: number\n            max:\n              type: number\n            integer:\n              type: boolean\n        date:\n          type: object\n          properties:\n            min:\n              type: string\n              format: date\n            max:\n              type: string\n              format: date\n\n    FieldDefAcl:\n      type: object\n      description: 'Access control list defining roles for read/write access.'\n      properties:\n        read:\n          type: array\n          items:\n            type: string\n        write:\n          type: array\n          items:\n            type: string\n\n    # Record Schemas\n    Record:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        version:\n          type: integer\n          description: 'The version number of the record, used for optimistic locking.'\n          readOnly: true\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the custom field data for the record.'\n          example:\n            name: 'AI Roadmap Q4'\n            status: 'Active'\n            budget: 12000\n        createdBy:\n          type: string\n          format: uuid\n          readOnly: true\n          nullable: true\n        updatedBy:\n          type: string\n          format: uuid\n          readOnly: true\n          nullable: true\n        createdAt:\n          type: string\n          format: date-time\n          readOnly: true\n        updatedAt:\n          type: string\n          format: date-time\n          readOnly: true\n      required:\n        - id\n        - entityTypeId\n        - version\n        - data\n        - createdAt\n        - updatedAt\n\n    RecordCreate:\n      type: object\n      properties:\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the custom field data for the new record.'\n      required:\n        - data\n\n    RecordUpdate:\n      type: object\n      properties:\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the fields to update.'\n        version:\n          type: integer\n          description: 'The current version of the record being updated, for optimistic locking.'\n      required:\n        - data\n        - version\n\n    # Search Schemas\n    SearchRequest:\n      type: object\n      properties:\n        filter:\n          $ref: '#/components/schemas/Filter'\n        sort:\n          type: array\n          items:\n            $ref: '#/components/schemas/Sort'\n          description: 'An array of sort objects to apply to the results.'\n        limit:\n          type: integer\n          minimum: 1\n          maximum: 1000\n          default: 50\n          description: 'The maximum number of records to return.'\n        cursor:\n          type: string\n          nullable: true\n          description: 'A cursor for pagination, obtained from a previous search response.'\n\n    SearchResponse:\n      type: object\n      properties:\n        rows:\n          type: array\n          items:\n            $ref: '#/components/schemas/Record'\n        nextCursor:\n          type: string\n          nullable: true\n          description: 'A cursor to retrieve the next page of results. Null if there are no more results.'\n      required:\n        - rows\n\n    Sort:\n      type: object\n      properties:\n        field:\n          type: string\n          description: 'The key of the field to sort by (e.g., \"budget\", \"createdAt\").'\n        dir:\n          type: string\n          enum: [asc, desc]\n          default: asc\n      required:\n        - field\n\n    Filter:\n      type: object\n      description: |\n        A flexible filter object to query records. It can be a logical operator (`and`, `or`, `not`) or a field-level comparison.\n        See the manifest for the full grammar.\n      properties:\n        op:\n          type: string\n          description: 'The operator for the filter.'\n        filters:\n          type: array\n          items:\n            $ref: '#/components/schemas/Filter'\n          description: 'Used with logical operators `and` and `or`.'\n        field:\n          type: string\n          description: 'The key of the field to compare.'\n        value:\n          description: 'The value to compare against.'\n        values:\n          type: array\n          description: 'An array of values for the `in` operator.'\n        query:\n          type: string\n          description: 'The search query for `fulltext` search.'\n      example:\n        op: 'and'\n        filters:\n          - { op: 'eq', field: 'status', value: 'Active' }\n          - { op: 'gte', field: 'budget', value: 10000 }\n          - { op: 'fulltext', query: 'ai roadmap' }\n\n    # Error Schema\n    Error:\n      type: object\n      properties:\n        code:\n          type: string\n          description: 'A machine-readable error code.'\n          example: 'VALIDATION_ERROR'\n        message:\n          type: string\n          description: 'A human-readable error message.'\n          example: 'The request body is invalid.'\n        requestId:\n          type: string\n          format: uuid\n          description: 'A unique identifier for the request, useful for tracing.'\n        errors:\n          type: array\n          items:\n            $ref: '#/components/schemas/ValidationErrorDetail'\n      required:\n        - code\n        - message\n\n    ValidationErrorDetail:\n      type: object\n      properties:\n        path:\n          type: string\n          description: 'The path to the invalid field in the request body.'\n          example: 'budget'\n        code:\n          type: string\n          description: 'A machine-readable code for the specific validation error.'\n          example: 'too_small'\n        message:\n          type: string\n          description: 'A human-readable message for the specific validation error.'\n          example: 'The budget must be at least 0.'\n      required:\n        - path\n        - code\n        - message"
            },
            {
                "path": "api/openapi.yaml",
                "content": "openapi: '3.0.3'\ninfo:\n  title: 'Dynamic Data Management System API'\n  description: 'API for managing dynamic entities, fields, records, and relationships.'\n  version: '1.0.0'\nservers:\n  - url: '/api/v1'\n    description: 'API v1'\n\ntags:\n  - name: Metadata\n    description: 'Operations for managing Entity Types and Field Definitions.'\n  - name: Records\n    description: 'Operations for managing Records (instances of an Entity Type).'\n\npaths:\n  /entity-types:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Entity Types'\n      description: 'Retrieves a list of all entity types for the tenant.'\n      operationId: 'listEntityTypes'\n      responses:\n        '200':\n          description: 'A list of entity types.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/EntityType'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Entity Type'\n      description: 'Creates a new entity type.'\n      operationId: 'createEntityType'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeCreate'\n      responses:\n        '201':\n          description: 'Entity type created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n\n  /entity-types/{entityTypeId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Entity Type'\n      description: 'Updates an existing entity type.'\n      operationId: 'updateEntityType'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EntityTypeUpdate'\n      responses:\n        '200':\n          description: 'Entity type updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EntityType'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entity-types/{entityTypeId}/fields:\n    get:\n      tags:\n        - Metadata\n      summary: 'List Field Definitions'\n      description: 'Retrieves a list of all field definitions for a given entity type.'\n      operationId: 'listFieldDefs'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      responses:\n        '200':\n          description: 'A list of field definitions.'\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/FieldDef'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    post:\n      tags:\n        - Metadata\n      summary: 'Create Field Definition'\n      description: 'Creates a new field definition for an entity type.'\n      operationId: 'createFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefCreate'\n      responses:\n        '201':\n          description: 'Field definition created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}:\n    post:\n      tags:\n        - Records\n      summary: 'Create Record'\n      description: 'Creates a new record for a given entity type.'\n      operationId: 'createRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/RecordCreate'\n      responses:\n        '201':\n          description: 'Record created successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}/search:\n    post:\n      tags:\n        - Records\n      summary: 'Search Records'\n      description: 'Searches for records of a given entity type using a filter.'\n      operationId: 'searchRecords'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/SearchRequest'\n      responses:\n        '200':\n          description: 'A list of matching records.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/SearchResponse'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n  /entities/{entityTypeKey}/{recordId}:\n    get:\n      tags:\n        - Records\n      summary: 'Get Record by ID'\n      description: 'Retrieves a single record by its ID.'\n      operationId: 'getRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n        - $ref: '#/components/parameters/recordId'\n      responses:\n        '200':\n          description: 'The requested record.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '404':\n          $ref: '#/components/responses/NotFound'\n    patch:\n      tags:\n        - Records\n      summary: 'Update Record'\n      description: 'Updates an existing record. Uses optimistic locking via a version number.'\n      operationId: 'updateRecord'\n      parameters:\n        - $ref: '#/components/parameters/entityTypeKey'\n        - $ref: '#/components/parameters/recordId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/RecordUpdate'\n      responses:\n        '200':\n          description: 'Record updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Record'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '409':\n          $ref: '#/components/responses/Conflict'\n\n  /fields/{fieldId}:\n    patch:\n      tags:\n        - Metadata\n      summary: 'Update Field Definition'\n      description: 'Updates an existing field definition.'\n      operationId: 'updateFieldDef'\n      parameters:\n        - $ref: '#/components/parameters/fieldId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/FieldDefUpdate'\n      responses:\n        '200':\n          description: 'Field definition updated successfully.'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FieldDef'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  parameters:\n    entityTypeId:\n      name: entityTypeId\n      in: path\n      required: true\n      description: 'The ID of the entity type.'\n      schema:\n        type: string\n        format: uuid\n    entityTypeKey:\n      name: entityTypeKey\n      in: path\n      required: true\n      description: 'The unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n      schema:\n        type: string\n    recordId:\n      name: recordId\n      in: path\n      required: true\n      description: 'The ID of the record.'\n      schema:\n        type: string\n        format: uuid\n    fieldId:\n      name: fieldId\n      in: path\n      required: true\n      description: 'The ID of the field definition.'\n      schema:\n        type: string\n        format: uuid\n\n  responses:\n    BadRequest:\n      description: 'Bad Request - The request body is invalid.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    NotFound:\n      description: 'Not Found - The requested resource does not exist.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n    Conflict:\n      description: 'Conflict - The request could not be completed due to a conflict with the current state of the resource, likely an optimistic locking failure.'\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  schemas:\n    # Entity Type Schemas\n    EntityType:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - id\n        - key\n        - label\n\n    EntityTypeCreate:\n      type: object\n      properties:\n        key:\n          type: string\n          description: 'A unique machine-readable key for the entity type (e.g., \"user\", \"project\").'\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n      required:\n        - key\n        - label\n\n    EntityTypeUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n          description: 'A human-readable label for the entity type (e.g., \"User\", \"Project\").'\n        description:\n          type: string\n          nullable: true\n          description: 'A description of the entity type.'\n\n    # Field Definition Schemas\n    FieldDef:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        key:\n          type: string\n          description: 'A unique machine-readable key for the field (e.g., \"status\", \"budget\").'\n        label:\n          type: string\n          description: 'A human-readable label for the field (e.g., \"Status\", \"Budget\").'\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n          default: false\n        uniqueWithinType:\n          type: boolean\n          default: false\n        searchable:\n          type: boolean\n          default: true\n        indexed:\n          type: boolean\n          default: false\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n          default: 0\n        active:\n          type: boolean\n          default: true\n      required:\n        - id\n        - entityTypeId\n        - key\n        - label\n        - kind\n\n    FieldDefCreate:\n      type: object\n      properties:\n        key:\n          type: string\n        label:\n          type: string\n        kind:\n          type: string\n          enum: [text, number, date, select, relation, boolean]\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n      required:\n        - key\n        - label\n        - kind\n\n    FieldDefUpdate:\n      type: object\n      properties:\n        label:\n          type: string\n        required:\n          type: boolean\n        uniqueWithinType:\n          type: boolean\n        searchable:\n          type: boolean\n        indexed:\n          type: boolean\n        options:\n          $ref: '#/components/schemas/FieldDefOptions'\n        validate:\n          $ref: '#/components/schemas/FieldDefValidate'\n        acl:\n          $ref: '#/components/schemas/FieldDefAcl'\n        position:\n          type: integer\n        active:\n          type: boolean\n\n    FieldDefOptions:\n      type: object\n      properties:\n        enum:\n          type: array\n          items:\n            type: string\n          description: 'For kind=\"select\". A list of possible values.'\n        multiselect:\n          type: boolean\n          description: 'For kind=\"select\". Whether multiple values can be selected.'\n        relation:\n          type: object\n          description: 'For kind=\"relation\". Defines the relationship target.'\n          properties:\n            targetEntityTypeId:\n              type: string\n              format: uuid\n            cardinality:\n              type: string\n              enum: [one, many]\n          required:\n            - targetEntityTypeId\n            - cardinality\n        formula:\n          type: string\n          description: 'For computed fields. An expression to calculate the field value.'\n          example: 'price * qty'\n        visibleIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional visibility rules for the UI.'\n        requiredIf:\n          type: array\n          items:\n            type: object\n          description: 'Conditional requirement rules.'\n\n    FieldDefValidate:\n      type: object\n      description: 'Validation rules that depend on the field kind.'\n      properties:\n        text:\n          type: object\n          properties:\n            minLen:\n              type: integer\n            maxLen:\n              type: integer\n            regex:\n              type: string\n        number:\n          type: object\n          properties:\n            min:\n              type: number\n            max:\n              type: number\n            integer:\n              type: boolean\n        date:\n          type: object\n          properties:\n            min:\n              type: string\n              format: date\n            max:\n              type: string\n              format: date\n\n    FieldDefAcl:\n      type: object\n      description: 'Access control list defining roles for read/write access.'\n      properties:\n        read:\n          type: array\n          items:\n            type: string\n        write:\n          type: array\n          items:\n            type: string\n\n    # Record Schemas\n    Record:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          readOnly: true\n        entityTypeId:\n          type: string\n          format: uuid\n          readOnly: true\n        version:\n          type: integer\n          description: 'The version number of the record, used for optimistic locking.'\n          readOnly: true\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the custom field data for the record.'\n          example:\n            name: 'AI Roadmap Q4'\n            status: 'Active'\n            budget: 12000\n        createdBy:\n          type: string\n          format: uuid\n          readOnly: true\n          nullable: true\n        updatedBy:\n          type: string\n          format: uuid\n          readOnly: true\n          nullable: true\n        createdAt:\n          type: string\n          format: date-time\n          readOnly: true\n        updatedAt:\n          type: string\n          format: date-time\n          readOnly: true\n      required:\n        - id\n        - entityTypeId\n        - version\n        - data\n        - createdAt\n        - updatedAt\n\n    RecordCreate:\n      type: object\n      properties:\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the custom field data for the new record.'\n      required:\n        - data\n\n    RecordUpdate:\n      type: object\n      properties:\n        data:\n          type: object\n          additionalProperties: true\n          description: 'A JSON object containing the fields to update.'\n        version:\n          type: integer\n          description: 'The current version of the record being updated, for optimistic locking.'\n      required:\n        - data\n        - version\n\n    # Search Schemas\n    SearchRequest:\n      type: object\n      properties:\n        filter:\n          $ref: '#/components/schemas/Filter'\n        sort:\n          type: array\n          items:\n            $ref: '#/components/schemas/Sort'\n          description: 'An array of sort objects to apply to the results.'\n        limit:\n          type: integer\n          minimum: 1\n          maximum: 1000\n          default: 50\n          description: 'The maximum number of records to return.'\n        cursor:\n          type: string\n          nullable: true\n          description: 'A cursor for pagination, obtained from a previous search response.'\n\n    SearchResponse:\n      type: object\n      properties:\n        rows:\n          type: array\n          items:\n            $ref: '#/components/schemas/Record'\n        nextCursor:\n          type: string\n          nullable: true\n          description: 'A cursor to retrieve the next page of results. Null if there are no more results.'\n      required:\n        - rows\n\n    Sort:\n      type: object\n      properties:\n        field:\n          type: string\n          description: 'The key of the field to sort by (e.g., \"budget\", \"createdAt\").'\n        dir:\n          type: string\n          enum: [asc, desc]\n          default: asc\n      required:\n        - field\n\n    Filter:\n      type: object\n      description: |\n        A flexible filter object to query records. It can be a logical operator (`and`, `or`, `not`) or a field-level comparison.\n        See the manifest for the full grammar.\n      properties:\n        op:\n          type: string\n          description: 'The operator for the filter.'\n        filters:\n          type: array\n          items:\n            $ref: '#/components/schemas/Filter'\n          description: 'Used with logical operators `and` and `or`.'\n        field:\n          type: string\n          description: 'The key of the field to compare.'\n        value:\n          description: 'The value to compare against.'\n        values:\n          type: array\n          description: 'An array of values for the `in` operator.'\n        query:\n          type: string\n          description: 'The search query for `fulltext` search.'\n      example:\n        op: 'and'\n        filters:\n          - { op: 'eq', field: 'status', value: 'Active' }\n          - { op: 'gte', field: 'budget', value: 10000 }\n          - { op: 'fulltext', query: 'ai roadmap' }\n\n    # Error Schema\n    Error:\n      type: object\n      properties:\n        code:\n          type: string\n          description: 'A machine-readable error code.'\n          example: 'VALIDATION_ERROR'\n        message:\n          type: string\n          description: 'A human-readable error message.'\n          example: 'The request body is invalid.'\n        requestId:\n          type: string\n          format: uuid\n          description: 'A unique identifier for the request, useful for tracing.'\n        errors:\n          type: array\n          items:\n            $ref: '#/components/schemas/ValidationErrorDetail'\n      required:\n        - code\n        - message\n\n    ValidationErrorDetail:\n      type: object\n      properties:\n        path:\n          type: string\n          description: 'The path to the invalid field in the request body.'\n          example: 'budget'\n        code:\n          type: string\n          description: 'A machine-readable code for the specific validation error.'\n          example: 'too_small'\n        message:\n          type: string\n          description: 'A human-readable message for the specific validation error.'\n          example: 'The budget must be at least 0.'\n      required:\n        - path\n        - code\n        - message"
            }
        ]
    },
    {
        "name": "I3.T2",
        "context": {
            "task_id": "I3.T2",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the `Validation Engine` in the `packages/core` package. It should contain a function that takes an array of `field_defs` and returns a Zod object schema. Implement memoization for caching.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 7.1 of the manifest.",
            "target_files": [
                "packages/core/src/validation.ts"
            ],
            "input_files": [
                "packages/core/"
            ],
            "deliverables": "A well-tested validation schema builder function.",
            "acceptance_criteria": "The function correctly translates `field_defs` of all kinds (`text`, `number`, `select`, etc.) into corresponding Zod validators.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "I will now implement the `Validation Engine` as requested in task `I3.T2`.\n\nFirst, I will create the new file `packages/core/src/validation.ts` which will contain the core logic for building Zod schemas from field definitions, including memoization.\n\nNext, I will update `packages/core/package.json` to include necessary dependencies: `zod` for schema validation, `@ddms/db` to access database types like `FieldDef`, and `drizzle-orm` for its typing utilities.\n\nFinally, I will modify `packages/core/src/index.ts` to export the new validation engine functionality, making it available to other packages in the monorepo.\n\n~~~typescript\n#- file: packages/core/src/validation.ts\nimport { z, ZodTypeAny } from 'zod';\nimport { fieldDefs } from '@ddms/db/schema';\nimport { InferSelectModel } from 'drizzle-orm';\n\n// Drizzle's InferSelectModel gives us the type of a selected row.\nexport type FieldDef = InferSelectModel<typeof fieldDefs>;\n\n// Schemas for the `validate` JSONB column, nested by field kind as per manifest\nconst textValidationSchema = z\n  .object({\n    minLen: z.number().optional(),\n    maxLen: z.number().optional(),\n    regex: z.string().optional(),\n  })\n  .optional();\n\nconst numberValidationSchema = z\n  .object({\n    min: z.number().optional(),\n    max: z.number().optional(),\n    integer: z.boolean().optional(),\n  })\n  .optional();\n\nconst dateValidationSchema = z\n  .object({\n    min: z.string().optional(),\n    max: z.string().optional(),\n  })\n  .optional();\n\n// Schemas for the `options` JSONB column\nconst selectOptionsSchema = z\n  .object({\n    enum: z.array(z.string()).min(1),\n    multiselect: z.boolean().optional(),\n  })\n  .optional();\n\nconst relationOptionsSchema = z\n  .object({\n    relation: z.object({\n      target_entity_type_id: z.string().uuid(),\n      cardinality: z.enum(['one', 'many']).optional(),\n    }),\n  })\n  .optional();\n\n/**\n * Builds a Zod schema from a single field definition.\n * @param field - The field definition from the database.\n * @returns A Zod type for the given field.\n */\nfunction buildZodTypeFromFieldDef(field: FieldDef): ZodTypeAny {\n  let zodType: ZodTypeAny;\n\n  switch (field.kind) {\n    case 'text': {\n      let type = z.string();\n      const validationRules = z\n        .object({ text: textValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.text;\n\n      if (validate?.minLen !== undefined) {\n        type = type.min(validate.minLen);\n      }\n      if (validate?.maxLen !== undefined) {\n        type = type.max(validate.maxLen);\n      }\n      if (validate?.regex) {\n        type = type.regex(new RegExp(validate.regex));\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'number': {\n      let type = z.number();\n      const validationRules = z\n        .object({ number: numberValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.number;\n\n      if (validate?.min !== undefined) {\n        type = type.min(validate.min);\n      }\n      if (validate?.max !== undefined) {\n        type = type.max(validate.max);\n      }\n      if (validate?.integer) {\n        type = type.int();\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'date': {\n      let type = z.string().datetime({ message: 'Invalid ISO 8601 date format' });\n      const validationRules = z\n        .object({ date: dateValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.date;\n\n      if (validate?.min) {\n        type = type.refine((val) => new Date(val) >= new Date(validate!.min!), {\n          message: `Date must be on or after ${validate.min}`,\n        });\n      }\n      if (validate?.max) {\n        type = type.refine((val) => new Date(val) <= new Date(validate!.max!), {\n          message: `Date must be on or before ${validate.max}`,\n        });\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'boolean': {\n      zodType = z.boolean();\n      break;\n    }\n\n    case 'select': {\n      const options = selectOptionsSchema.parse(field.options ?? {});\n      if (!options?.enum) {\n        throw new Error(`'select' field '${field.key}' is missing enum options.`);\n      }\n      const enumType = z.enum(options.enum as [string, ...string[]]);\n      if (options.multiselect) {\n        zodType = z.array(enumType);\n      } else {\n        zodType = enumType;\n      }\n      break;\n    }\n\n    case 'relation': {\n      const options = relationOptionsSchema.parse(field.options ?? {});\n      const relationOptions = options?.relation;\n      if (!relationOptions?.target_entity_type_id) {\n        throw new Error(\n          `'relation' field '${field.key}' is missing target_entity_type_id.`,\n        );\n      }\n      const uuidType = z.string().uuid();\n      if (relationOptions.cardinality === 'many') {\n        zodType = z.array(uuidType);\n      } else {\n        zodType = uuidType;\n      }\n      break;\n    }\n\n    default:\n      const exhaustiveCheck: never = field.kind;\n      throw new Error(`Unsupported field kind: ${exhaustiveCheck}`);\n  }\n\n  if (!field.required) {\n    return zodType.optional().nullable();\n  }\n\n  return zodType;\n}\n\n/**\n * The internal schema builder without memoization.\n * @param fields - An array of field definitions.\n * @returns A Zod object schema.\n */\nfunction buildSchemaFromFieldDefs(fields: FieldDef[]): z.ZodObject<any> {\n  const shape: Record<string, ZodTypeAny> = {};\n\n  for (const field of fields) {\n    shape[field.key] = buildZodTypeFromFieldDef(field);\n  }\n\n  return z.object(shape);\n}\n\n// Memoization cache\nconst schemaCache = new Map<string, z.ZodObject<any>>();\n\n/**\n * Gets a Zod validation schema for a given set of field definitions.\n * The result is memoized based on the cacheKey.\n *\n * @param cacheKey - A unique key to identify this set of field definitions (e.g., entityTypeId).\n * @param fields - An array of field definitions.\n * @returns A memoized Zod object schema.\n */\nexport function getValidationSchema(\n  cacheKey: string,\n  fields: FieldDef[],\n): z.ZodObject<any> {\n  if (schemaCache.has(cacheKey)) {\n    return schemaCache.get(cacheKey)!;\n  }\n\n  const newSchema = buildSchemaFromFieldDefs(fields);\n  schemaCache.set(cacheKey, newSchema);\n\n  return newSchema;\n}\n~~~\n~~~edits\n#- file: packages/core/package.json\n***start_edit\nLITERAL\n***search\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/core: no test specified\\\" && exit 0\"\n  }\n}\n***replace\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/core: no test specified\\\" && exit 0\"\n  },\n  \"dependencies\": {\n    \"@ddms/db\": \"workspace:*\",\n    \"drizzle-orm\": \"^0.32.1\",\n    \"zod\": \"^3.23.8\"\n  }\n}\n***description\nAdd zod, drizzle-orm and @ddms/db as dependencies for the validation engine.\n***end_edit\n~~~\n~~~edits\n#- file: packages/core/src/index.ts\n***start_edit\nLITERAL\n***search\nexport const core = () => 'Hello from @ddms/core';\n***replace\nexport * from './validation';\n***description\nExport the new validation engine module.\n***end_edit\n~~~",
        "iteration_id": "I3",
        "completed": true,
        "target_files": [
            "packages/core/src/validation.ts"
        ],
        "input_files": [
            "packages/core/"
        ],
        "files": [
            {
                "path": "packages/core/",
                "content": [
                    {
                        "path": "project/packages/core/dist/index.js",
                        "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.core = void 0;\nconst core = () => 'Hello from @ddms/core';\nexports.core = core;\n//# sourceMappingURL=index.js.map"
                    },
                    {
                        "path": "project/packages/core/dist/index.js.map",
                        "content": "{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/index.ts\"],\"names\":[],\"mappings\":\";;;AAAO,MAAM,IAAI,GAAG,GAAG,EAAE,CAAC,uBAAuB,CAAC;AAArC,QAAA,IAAI,QAAiC\"}"
                    },
                    {
                        "path": "project/packages/core/dist/index.d.ts",
                        "content": "export declare const core: () => string;\n"
                    },
                    {
                        "path": "project/packages/core/tsconfig.tsbuildinfo",
                        "content": "{\"fileNames\":[\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es5.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.iterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.asynciterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.webworker.importscripts.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.scripthost.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.core.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.collection.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.generator.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.iterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.proxy.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.reflect.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.symbol.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.array.include.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.date.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.regexp.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.array.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.symbol.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.bigint.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.date.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.number.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.weakref.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.array.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.error.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.regexp.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.decorators.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.decorators.legacy.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.full.d.ts\",\"./src/index.ts\"],\"fileInfos\":[{\"version\":\"c430d44666289dae81f30fa7b2edebf186ecc91a2d4c71266ea6ae76388792e1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4\",\"impliedFormat\":1},{\"version\":\"3facaf05f0c5fc569c5649dd359892c98a85557e3e0c847964caeb67076f4d75\",\"impliedFormat\":1},{\"version\":\"e44bb8bbac7f10ecc786703fe0a6a4b952189f908707980ba8f3c8975a760962\",\"impliedFormat\":1},{\"version\":\"5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8\",\"impliedFormat\":1},{\"version\":\"68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7\",\"impliedFormat\":1},{\"version\":\"5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4\",\"impliedFormat\":1},{\"version\":\"feecb1be483ed332fad555aff858affd90a48ab19ba7272ee084704eb7167569\",\"impliedFormat\":1},{\"version\":\"ee7bad0c15b58988daa84371e0b89d313b762ab83cb5b31b8a2d1162e8eb41c2\",\"impliedFormat\":1},{\"version\":\"080941d9f9ff9307f7e27a83bcd888b7c8270716c39af943532438932ec1d0b9\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"2e80ee7a49e8ac312cc11b77f1475804bee36b3b2bc896bead8b6e1266befb43\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d7a3c8b952931daebdfc7a2897c53c0a1c73624593fa070e46bd537e64dcd20a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"80e18897e5884b6723488d4f5652167e7bb5024f946743134ecc4aa4ee731f89\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"cd034f499c6cdca722b60c04b5b1b78e058487a7085a8e0d6fb50809947ee573\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"c57796738e7f83dbc4b8e65132f11a377649c00dd3eee333f672b8f0a6bea671\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"dc2df20b1bcdc8c2d34af4926e2c3ab15ffe1160a63e58b7e09833f616efff44\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"515d0b7b9bea2e31ea4ec968e9edd2c39d3eebf4a2d5cbd04e88639819ae3b71\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0559b1f683ac7505ae451f9a96ce4c3c92bdc71411651ca6ddb0e88baaaad6a3\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0dc1e7ceda9b8b9b455c3a2d67b0412feab00bd2f66656cd8850e8831b08b537\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"4ff2a353abf8a80ee399af572debb8faab2d33ad38c4b4474cff7f26e7653b8d\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"fb0f136d372979348d59b3f5020b4cdb81b5504192b1cacff5d1fbba29378aa1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d15bea3d62cbbdb9797079416b8ac375ae99162a7fba5de2c6c505446486ac0a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"68d18b664c9d32a7336a70235958b8997ebc1c3b8505f4f1ae2b7e7753b87618\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"eb3d66c8327153d8fa7dd03f9c58d351107fe824c79e9b56b462935176cdf12a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"69ab18c3b76cd9b1be3d188eaf8bba06112ebbe2f47f6c322b5105a6fbc45a2e\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"a680117f487a4d2f30ea46f1b4b7f58bef1480456e18ba53ee85c2746eeca012\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"4de680d5bb41c17f7f68e0419412ca23c98d5749dcaaea1896172f06435891fc\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"954296b30da6d508a104a3a0b5d96b76495c709785c1d11610908e63481ee667\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"ac9538681b19688c8eae65811b329d3744af679e0bdfa5d842d0e32524c73e1c\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0a969edff4bd52585473d24995c5ef223f6652d6ef46193309b3921d65dd4376\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"9e9fbd7030c440b33d021da145d3232984c8bb7916f277e8ffd3dc2e3eae2bdb\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"811ec78f7fefcabbda4bfa93b3eb67d9ae166ef95f9bff989d964061cbf81a0c\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"717937616a17072082152a2ef351cb51f98802fb4b2fdabd32399843875974ca\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d7e7d9b7b50e5f22c915b525acc5a49a7a6584cf8f62d0569e557c5cfc4b2ac2\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"71c37f4c9543f31dfced6c7840e068c5a5aacb7b89111a4364b1d5276b852557\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"74f7fa2d027d5b33eb0471c8e82a6c87216223181ec31247c357a3e8e2fddc5b\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d6d7ae4d1f1f3772e2a3cde568ed08991a8ae34a080ff1151af28b7f798e22ca\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"063600664504610fe3e99b717a1223f8b1900087fab0b4cad1496a114744f8df\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"934019d7e3c81950f9a8426d093458b65d5aff2c7c1511233c0fd5b941e608ab\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"52ada8e0b6e0482b728070b7639ee42e83a9b1c22d205992756fe020fd9f4a47\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3bdefe1bfd4d6dee0e26f928f93ccc128f1b64d5d501ff4a8cf3c6371200e5e6\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"59fb2c069260b4ba00b5643b907ef5d5341b167e7d1dbf58dfd895658bda2867\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"639e512c0dfc3fad96a84caad71b8834d66329a1f28dc95e3946c9b58176c73a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"af3dd424cf267428f30ccfc376f47a2c0114546b55c44d8c0f1d57d841e28d74\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"995c005ab91a498455ea8dfb63aa9f83fa2ea793c3d8aa344be4a1678d06d399\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"959d36cddf5e7d572a65045b876f2956c973a586da58e5d26cde519184fd9b8a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"965f36eae237dd74e6cca203a43e9ca801ce38824ead814728a2807b1910117d\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3925a6c820dcb1a06506c90b1577db1fdbf7705d65b62b99dce4be75c637e26b\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0a3d63ef2b853447ec4f749d3f368ce642264246e02911fcb1590d8c161b8005\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8cdf8847677ac7d20486e54dd3fcf09eda95812ac8ace44b4418da1bbbab6eb8\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8444af78980e3b20b49324f4a16ba35024fef3ee069a0eb67616ea6ca821c47a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3287d9d085fbd618c3971944b65b4be57859f5415f495b33a6adc994edd2f004\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"b4b67b1a91182421f5df999988c690f14d813b9850b40acd06ed44691f6727ad\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8e7f8264d0fb4c5339605a15daadb037bf238c10b654bb3eee14208f860a32ea\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3cbad9a1ba4453443026ed38e4b8be018abb26565fa7c944376463ad9df07c41\",\"impliedFormat\":1},{\"version\":\"3ed321a1f1fcaeb1c05cc9f6d90e149bad7642cfa73facb323a347198e7b6e62\",\"signature\":\"252314f963f733f961076c222dbe6ce80a2062a15c5b8bf5e48f06f5247856f4\",\"impliedFormat\":1}],\"root\":[64],\"options\":{\"composite\":true,\"declaration\":true,\"esModuleInterop\":true,\"module\":199,\"outDir\":\"./dist\",\"rootDir\":\"./src\",\"skipLibCheck\":true,\"sourceMap\":true,\"strict\":true,\"target\":9},\"latestChangedDtsFile\":\"./dist/index.d.ts\",\"version\":\"5.9.3\"}"
                    },
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/core: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export const core = () => 'Hello from @ddms/core';"
                    }
                ]
            },
            {
                "path": "packages/core/src/validation.ts",
                "content": "import { z, ZodTypeAny } from 'zod';\nimport { fieldDefs } from '@ddms/db/schema';\nimport { InferSelectModel } from 'drizzle-orm';\n\n// Drizzle's InferSelectModel gives us the type of a selected row.\nexport type FieldDef = InferSelectModel<typeof fieldDefs>;\n\n// Schemas for the `validate` JSONB column, nested by field kind as per manifest\nconst textValidationSchema = z\n  .object({\n    minLen: z.number().optional(),\n    maxLen: z.number().optional(),\n    regex: z.string().optional(),\n  })\n  .optional();\n\nconst numberValidationSchema = z\n  .object({\n    min: z.number().optional(),\n    max: z.number().optional(),\n    integer: z.boolean().optional(),\n  })\n  .optional();\n\nconst dateValidationSchema = z\n  .object({\n    min: z.string().optional(),\n    max: z.string().optional(),\n  })\n  .optional();\n\n// Schemas for the `options` JSONB column\nconst selectOptionsSchema = z\n  .object({\n    enum: z.array(z.string()).min(1),\n    multiselect: z.boolean().optional(),\n  })\n  .optional();\n\nconst relationOptionsSchema = z\n  .object({\n    relation: z.object({\n      target_entity_type_id: z.string().uuid(),\n      cardinality: z.enum(['one', 'many']).optional(),\n    }),\n  })\n  .optional();\n\n/**\n * Builds a Zod schema from a single field definition.\n * @param field - The field definition from the database.\n * @returns A Zod type for the given field.\n */\nfunction buildZodTypeFromFieldDef(field: FieldDef): ZodTypeAny {\n  let zodType: ZodTypeAny;\n\n  switch (field.kind) {\n    case 'text': {\n      let type = z.string();\n      const validationRules = z\n        .object({ text: textValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.text;\n\n      if (validate?.minLen !== undefined) {\n        type = type.min(validate.minLen);\n      }\n      if (validate?.maxLen !== undefined) {\n        type = type.max(validate.maxLen);\n      }\n      if (validate?.regex) {\n        type = type.regex(new RegExp(validate.regex));\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'number': {\n      let type = z.number();\n      const validationRules = z\n        .object({ number: numberValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.number;\n\n      if (validate?.min !== undefined) {\n        type = type.min(validate.min);\n      }\n      if (validate?.max !== undefined) {\n        type = type.max(validate.max);\n      }\n      if (validate?.integer) {\n        type = type.int();\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'date': {\n      let type = z.string().datetime({ message: 'Invalid ISO 8601 date format' });\n      const validationRules = z\n        .object({ date: dateValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.date;\n\n      if (validate?.min) {\n        type = type.refine((val) => new Date(val) >= new Date(validate!.min!), {\n          message: `Date must be on or after ${validate.min}`,\n        });\n      }\n      if (validate?.max) {\n        type = type.refine((val) => new Date(val) <= new Date(validate!.max!), {\n          message: `Date must be on or before ${validate.max}`,\n        });\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'boolean': {\n      zodType = z.boolean();\n      break;\n    }\n\n    case 'select': {\n      const options = selectOptionsSchema.parse(field.options ?? {});\n      if (!options?.enum) {\n        throw new Error(`'select' field '${field.key}' is missing enum options.`);\n      }\n      const enumType = z.enum(options.enum as [string, ...string[]]);\n      if (options.multiselect) {\n        zodType = z.array(enumType);\n      } else {\n        zodType = enumType;\n      }\n      break;\n    }\n\n    case 'relation': {\n      const options = relationOptionsSchema.parse(field.options ?? {});\n      const relationOptions = options?.relation;\n      if (!relationOptions?.target_entity_type_id) {\n        throw new Error(\n          `'relation' field '${field.key}' is missing target_entity_type_id.`,\n        );\n      }\n      const uuidType = z.string().uuid();\n      if (relationOptions.cardinality === 'many') {\n        zodType = z.array(uuidType);\n      } else {\n        zodType = uuidType;\n      }\n      break;\n    }\n\n    default:\n      const exhaustiveCheck: never = field.kind;\n      throw new Error(`Unsupported field kind: ${exhaustiveCheck}`);\n  }\n\n  if (!field.required) {\n    return zodType.optional().nullable();\n  }\n\n  return zodType;\n}\n\n/**\n * The internal schema builder without memoization.\n * @param fields - An array of field definitions.\n * @returns A Zod object schema.\n */\nfunction buildSchemaFromFieldDefs(fields: FieldDef[]): z.ZodObject<any> {\n  const shape: Record<string, ZodTypeAny> = {};\n\n  for (const field of fields) {\n    shape[field.key] = buildZodTypeFromFieldDef(field);\n  }\n\n  return z.object(shape);\n}\n\n// Memoization cache\nconst schemaCache = new Map<string, z.ZodObject<any>>();\n\n/**\n * Gets a Zod validation schema for a given set of field definitions.\n * The result is memoized based on the cacheKey.\n *\n * @param cacheKey - A unique key to identify this set of field definitions (e.g., entityTypeId).\n * @param fields - An array of field definitions.\n * @returns A memoized Zod object schema.\n */\nexport function getValidationSchema(\n  cacheKey: string,\n  fields: FieldDef[],\n): z.ZodObject<any> {\n  if (schemaCache.has(cacheKey)) {\n    return schemaCache.get(cacheKey)!;\n  }\n\n  const newSchema = buildSchemaFromFieldDefs(fields);\n  schemaCache.set(cacheKey, newSchema);\n\n  return newSchema;\n}"
            },
            {
                "path": "packages/core/",
                "content": [
                    {
                        "path": "project/packages/core/dist/index.js",
                        "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.core = void 0;\nconst core = () => 'Hello from @ddms/core';\nexports.core = core;\n//# sourceMappingURL=index.js.map"
                    },
                    {
                        "path": "project/packages/core/dist/index.js.map",
                        "content": "{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/index.ts\"],\"names\":[],\"mappings\":\";;;AAAO,MAAM,IAAI,GAAG,GAAG,EAAE,CAAC,uBAAuB,CAAC;AAArC,QAAA,IAAI,QAAiC\"}"
                    },
                    {
                        "path": "project/packages/core/dist/index.d.ts",
                        "content": "export declare const core: () => string;\n"
                    },
                    {
                        "path": "project/packages/core/tsconfig.tsbuildinfo",
                        "content": "{\"fileNames\":[\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es5.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.iterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.asynciterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.webworker.importscripts.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.scripthost.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.core.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.collection.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.generator.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.iterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.proxy.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.reflect.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.symbol.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.array.include.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.date.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.regexp.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.array.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.symbol.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.bigint.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.date.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.number.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.weakref.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.array.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.error.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.regexp.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.decorators.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.decorators.legacy.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.full.d.ts\",\"./src/index.ts\"],\"fileInfos\":[{\"version\":\"c430d44666289dae81f30fa7b2edebf186ecc91a2d4c71266ea6ae76388792e1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4\",\"impliedFormat\":1},{\"version\":\"3facaf05f0c5fc569c5649dd359892c98a85557e3e0c847964caeb67076f4d75\",\"impliedFormat\":1},{\"version\":\"e44bb8bbac7f10ecc786703fe0a6a4b952189f908707980ba8f3c8975a760962\",\"impliedFormat\":1},{\"version\":\"5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8\",\"impliedFormat\":1},{\"version\":\"68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7\",\"impliedFormat\":1},{\"version\":\"5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4\",\"impliedFormat\":1},{\"version\":\"feecb1be483ed332fad555aff858affd90a48ab19ba7272ee084704eb7167569\",\"impliedFormat\":1},{\"version\":\"ee7bad0c15b58988daa84371e0b89d313b762ab83cb5b31b8a2d1162e8eb41c2\",\"impliedFormat\":1},{\"version\":\"080941d9f9ff9307f7e27a83bcd888b7c8270716c39af943532438932ec1d0b9\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"2e80ee7a49e8ac312cc11b77f1475804bee36b3b2bc896bead8b6e1266befb43\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d7a3c8b952931daebdfc7a2897c53c0a1c73624593fa070e46bd537e64dcd20a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"80e18897e5884b6723488d4f5652167e7bb5024f946743134ecc4aa4ee731f89\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"cd034f499c6cdca722b60c04b5b1b78e058487a7085a8e0d6fb50809947ee573\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"c57796738e7f83dbc4b8e65132f11a377649c00dd3eee333f672b8f0a6bea671\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"dc2df20b1bcdc8c2d34af4926e2c3ab15ffe1160a63e58b7e09833f616efff44\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"515d0b7b9bea2e31ea4ec968e9edd2c39d3eebf4a2d5cbd04e88639819ae3b71\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0559b1f683ac7505ae451f9a96ce4c3c92bdc71411651ca6ddb0e88baaaad6a3\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0dc1e7ceda9b8b9b455c3a2d67b0412feab00bd2f66656cd8850e8831b08b537\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"4ff2a353abf8a80ee399af572debb8faab2d33ad38c4b4474cff7f26e7653b8d\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"fb0f136d372979348d59b3f5020b4cdb81b5504192b1cacff5d1fbba29378aa1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d15bea3d62cbbdb9797079416b8ac375ae99162a7fba5de2c6c505446486ac0a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"68d18b664c9d32a7336a70235958b8997ebc1c3b8505f4f1ae2b7e7753b87618\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"eb3d66c8327153d8fa7dd03f9c58d351107fe824c79e9b56b462935176cdf12a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"69ab18c3b76cd9b1be3d188eaf8bba06112ebbe2f47f6c322b5105a6fbc45a2e\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"a680117f487a4d2f30ea46f1b4b7f58bef1480456e18ba53ee85c2746eeca012\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"4de680d5bb41c17f7f68e0419412ca23c98d5749dcaaea1896172f06435891fc\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"954296b30da6d508a104a3a0b5d96b76495c709785c1d11610908e63481ee667\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"ac9538681b19688c8eae65811b329d3744af679e0bdfa5d842d0e32524c73e1c\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0a969edff4bd52585473d24995c5ef223f6652d6ef46193309b3921d65dd4376\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"9e9fbd7030c440b33d021da145d3232984c8bb7916f277e8ffd3dc2e3eae2bdb\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"811ec78f7fefcabbda4bfa93b3eb67d9ae166ef95f9bff989d964061cbf81a0c\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"717937616a17072082152a2ef351cb51f98802fb4b2fdabd32399843875974ca\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d7e7d9b7b50e5f22c915b525acc5a49a7a6584cf8f62d0569e557c5cfc4b2ac2\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"71c37f4c9543f31dfced6c7840e068c5a5aacb7b89111a4364b1d5276b852557\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"74f7fa2d027d5b33eb0471c8e82a6c87216223181ec31247c357a3e8e2fddc5b\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d6d7ae4d1f1f3772e2a3cde568ed08991a8ae34a080ff1151af28b7f798e22ca\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"063600664504610fe3e99b717a1223f8b1900087fab0b4cad1496a114744f8df\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"934019d7e3c81950f9a8426d093458b65d5aff2c7c1511233c0fd5b941e608ab\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"52ada8e0b6e0482b728070b7639ee42e83a9b1c22d205992756fe020fd9f4a47\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3bdefe1bfd4d6dee0e26f928f93ccc128f1b64d5d501ff4a8cf3c6371200e5e6\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"59fb2c069260b4ba00b5643b907ef5d5341b167e7d1dbf58dfd895658bda2867\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"639e512c0dfc3fad96a84caad71b8834d66329a1f28dc95e3946c9b58176c73a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"af3dd424cf267428f30ccfc376f47a2c0114546b55c44d8c0f1d57d841e28d74\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"995c005ab91a498455ea8dfb63aa9f83fa2ea793c3d8aa344be4a1678d06d399\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"959d36cddf5e7d572a65045b876f2956c973a586da58e5d26cde519184fd9b8a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"965f36eae237dd74e6cca203a43e9ca801ce38824ead814728a2807b1910117d\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3925a6c820dcb1a06506c90b1577db1fdbf7705d65b62b99dce4be75c637e26b\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0a3d63ef2b853447ec4f749d3f368ce642264246e02911fcb1590d8c161b8005\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8cdf8847677ac7d20486e54dd3fcf09eda95812ac8ace44b4418da1bbbab6eb8\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8444af78980e3b20b49324f4a16ba35024fef3ee069a0eb67616ea6ca821c47a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3287d9d085fbd618c3971944b65b4be57859f5415f495b33a6adc994edd2f004\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"b4b67b1a91182421f5df999988c690f14d813b9850b40acd06ed44691f6727ad\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8e7f8264d0fb4c5339605a15daadb037bf238c10b654bb3eee14208f860a32ea\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3cbad9a1ba4453443026ed38e4b8be018abb26565fa7c944376463ad9df07c41\",\"impliedFormat\":1},{\"version\":\"3ed321a1f1fcaeb1c05cc9f6d90e149bad7642cfa73facb323a347198e7b6e62\",\"signature\":\"252314f963f733f961076c222dbe6ce80a2062a15c5b8bf5e48f06f5247856f4\",\"impliedFormat\":1}],\"root\":[64],\"options\":{\"composite\":true,\"declaration\":true,\"esModuleInterop\":true,\"module\":199,\"outDir\":\"./dist\",\"rootDir\":\"./src\",\"skipLibCheck\":true,\"sourceMap\":true,\"strict\":true,\"target\":9},\"latestChangedDtsFile\":\"./dist/index.d.ts\",\"version\":\"5.9.3\"}"
                    },
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/core: no test specified\\\" && exit 0\"\n  },\n  \"dependencies\": {\n    \"@ddms/db\": \"workspace:*\",\n    \"drizzle-orm\": \"^0.32.1\",\n    \"zod\": \"^3.23.8\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/core/src/validation.ts",
                        "content": "import { z, ZodTypeAny } from 'zod';\nimport { fieldDefs } from '@ddms/db/schema';\nimport { InferSelectModel } from 'drizzle-orm';\n\n// Drizzle's InferSelectModel gives us the type of a selected row.\nexport type FieldDef = InferSelectModel<typeof fieldDefs>;\n\n// Schemas for the `validate` JSONB column, nested by field kind as per manifest\nconst textValidationSchema = z\n  .object({\n    minLen: z.number().optional(),\n    maxLen: z.number().optional(),\n    regex: z.string().optional(),\n  })\n  .optional();\n\nconst numberValidationSchema = z\n  .object({\n    min: z.number().optional(),\n    max: z.number().optional(),\n    integer: z.boolean().optional(),\n  })\n  .optional();\n\nconst dateValidationSchema = z\n  .object({\n    min: z.string().optional(),\n    max: z.string().optional(),\n  })\n  .optional();\n\n// Schemas for the `options` JSONB column\nconst selectOptionsSchema = z\n  .object({\n    enum: z.array(z.string()).min(1),\n    multiselect: z.boolean().optional(),\n  })\n  .optional();\n\nconst relationOptionsSchema = z\n  .object({\n    relation: z.object({\n      target_entity_type_id: z.string().uuid(),\n      cardinality: z.enum(['one', 'many']).optional(),\n    }),\n  })\n  .optional();\n\n/**\n * Builds a Zod schema from a single field definition.\n * @param field - The field definition from the database.\n * @returns A Zod type for the given field.\n */\nfunction buildZodTypeFromFieldDef(field: FieldDef): ZodTypeAny {\n  let zodType: ZodTypeAny;\n\n  switch (field.kind) {\n    case 'text': {\n      let type = z.string();\n      const validationRules = z\n        .object({ text: textValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.text;\n\n      if (validate?.minLen !== undefined) {\n        type = type.min(validate.minLen);\n      }\n      if (validate?.maxLen !== undefined) {\n        type = type.max(validate.maxLen);\n      }\n      if (validate?.regex) {\n        type = type.regex(new RegExp(validate.regex));\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'number': {\n      let type = z.number();\n      const validationRules = z\n        .object({ number: numberValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.number;\n\n      if (validate?.min !== undefined) {\n        type = type.min(validate.min);\n      }\n      if (validate?.max !== undefined) {\n        type = type.max(validate.max);\n      }\n      if (validate?.integer) {\n        type = type.int();\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'date': {\n      let type = z.string().datetime({ message: 'Invalid ISO 8601 date format' });\n      const validationRules = z\n        .object({ date: dateValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.date;\n\n      if (validate?.min) {\n        type = type.refine((val) => new Date(val) >= new Date(validate!.min!), {\n          message: `Date must be on or after ${validate.min}`,\n        });\n      }\n      if (validate?.max) {\n        type = type.refine((val) => new Date(val) <= new Date(validate!.max!), {\n          message: `Date must be on or before ${validate.max}`,\n        });\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'boolean': {\n      zodType = z.boolean();\n      break;\n    }\n\n    case 'select': {\n      const options = selectOptionsSchema.parse(field.options ?? {});\n      if (!options?.enum) {\n        throw new Error(`'select' field '${field.key}' is missing enum options.`);\n      }\n      const enumType = z.enum(options.enum as [string, ...string[]]);\n      if (options.multiselect) {\n        zodType = z.array(enumType);\n      } else {\n        zodType = enumType;\n      }\n      break;\n    }\n\n    case 'relation': {\n      const options = relationOptionsSchema.parse(field.options ?? {});\n      const relationOptions = options?.relation;\n      if (!relationOptions?.target_entity_type_id) {\n        throw new Error(\n          `'relation' field '${field.key}' is missing target_entity_type_id.`,\n        );\n      }\n      const uuidType = z.string().uuid();\n      if (relationOptions.cardinality === 'many') {\n        zodType = z.array(uuidType);\n      } else {\n        zodType = uuidType;\n      }\n      break;\n    }\n\n    default:\n      const exhaustiveCheck: never = field.kind;\n      throw new Error(`Unsupported field kind: ${exhaustiveCheck}`);\n  }\n\n  if (!field.required) {\n    return zodType.optional().nullable();\n  }\n\n  return zodType;\n}\n\n/**\n * The internal schema builder without memoization.\n * @param fields - An array of field definitions.\n * @returns A Zod object schema.\n */\nfunction buildSchemaFromFieldDefs(fields: FieldDef[]): z.ZodObject<any> {\n  const shape: Record<string, ZodTypeAny> = {};\n\n  for (const field of fields) {\n    shape[field.key] = buildZodTypeFromFieldDef(field);\n  }\n\n  return z.object(shape);\n}\n\n// Memoization cache\nconst schemaCache = new Map<string, z.ZodObject<any>>();\n\n/**\n * Gets a Zod validation schema for a given set of field definitions.\n * The result is memoized based on the cacheKey.\n *\n * @param cacheKey - A unique key to identify this set of field definitions (e.g., entityTypeId).\n * @param fields - An array of field definitions.\n * @returns A memoized Zod object schema.\n */\nexport function getValidationSchema(\n  cacheKey: string,\n  fields: FieldDef[],\n): z.ZodObject<any> {\n  if (schemaCache.has(cacheKey)) {\n    return schemaCache.get(cacheKey)!;\n  }\n\n  const newSchema = buildSchemaFromFieldDefs(fields);\n  schemaCache.set(cacheKey, newSchema);\n\n  return newSchema;\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export * from './validation';"
                    }
                ]
            },
            {
                "path": "packages/core/src/validation.ts",
                "content": "import { z, ZodTypeAny, AnyZodObject } from 'zod';\nimport { fieldDefs } from '@ddms/db/schema';\nimport { InferSelectModel } from 'drizzle-orm';\n\n// Drizzle's InferSelectModel gives us the type of a selected row.\nexport type FieldDef = InferSelectModel<typeof fieldDefs>;\n\n// Schemas for the `validate` JSONB column, nested by field kind as per manifest\nconst textValidationSchema = z\n  .object({\n    minLen: z.number().optional(),\n    maxLen: z.number().optional(),\n    regex: z.string().optional(),\n  })\n  .optional();\n\nconst numberValidationSchema = z\n  .object({\n    min: z.number().optional(),\n    max: z.number().optional(),\n    integer: z.boolean().optional(),\n  })\n  .optional();\n\nconst dateValidationSchema = z\n  .object({\n    min: z.string().optional(),\n    max: z.string().optional(),\n  })\n  .optional();\n\n// Schemas for the `options` JSONB column\nconst selectOptionsSchema = z\n  .object({\n    enum: z.array(z.string()).min(1),\n    multiselect: z.boolean().optional(),\n  })\n  .optional();\n\nconst relationOptionsSchema = z\n  .object({\n    relation: z.object({\n      target_entity_type_id: z.string().uuid(),\n      cardinality: z.enum(['one', 'many']).optional(),\n    }),\n  })\n  .optional();\n\n/**\n * Builds a Zod schema from a single field definition.\n * @param field - The field definition from the database.\n * @returns A Zod type for the given field.\n */\nfunction buildZodTypeFromFieldDef(field: FieldDef): ZodTypeAny {\n  let zodType: ZodTypeAny;\n\n  switch (field.kind) {\n    case 'text': {\n      let type = z.string();\n      const validationRules = z\n        .object({ text: textValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.text;\n\n      if (validate?.minLen !== undefined) {\n        type = type.min(validate.minLen);\n      }\n      if (validate?.maxLen !== undefined) {\n        type = type.max(validate.maxLen);\n      }\n      if (validate?.regex) {\n        type = type.regex(new RegExp(validate.regex));\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'number': {\n      let type = z.number();\n      const validationRules = z\n        .object({ number: numberValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.number;\n\n      if (validate?.min !== undefined) {\n        type = type.min(validate.min);\n      }\n      if (validate?.max !== undefined) {\n        type = type.max(validate.max);\n      }\n      if (validate?.integer) {\n        type = type.int();\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'date': {\n      let type = z\n        .string()\n        .datetime({ message: 'Invalid ISO 8601 date format' });\n      const validationRules = z\n        .object({ date: dateValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.date;\n\n      if (validate?.min) {\n        type = type.refine((val) => new Date(val) >= new Date(validate!.min!), {\n          message: `Date must be on or after ${validate.min}`,\n        });\n      }\n      if (validate?.max) {\n        type = type.refine((val) => new Date(val) <= new Date(validate!.max!), {\n          message: `Date must be on or before ${validate.max}`,\n        });\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'boolean': {\n      zodType = z.boolean();\n      break;\n    }\n\n    case 'select': {\n      const options = selectOptionsSchema.parse(field.options ?? {});\n      if (!options?.enum) {\n        throw new Error(\n          `'select' field '${field.key}' is missing enum options.`,\n        );\n      }\n      const enumType = z.enum(options.enum as [string, ...string[]]);\n      if (options.multiselect) {\n        zodType = z.array(enumType);\n      } else {\n        zodType = enumType;\n      }\n      break;\n    }\n\n    case 'relation': {\n      const options = relationOptionsSchema.parse(field.options ?? {});\n      const relationOptions = options?.relation;\n      if (!relationOptions?.target_entity_type_id) {\n        throw new Error(\n          `'relation' field '${field.key}' is missing target_entity_type_id.`,\n        );\n      }\n      const uuidType = z.string().uuid();\n      if (relationOptions.cardinality === 'many') {\n        zodType = z.array(uuidType);\n      } else {\n        zodType = uuidType;\n      }\n      break;\n    }\n\n    default: {\n      const exhaustiveCheck: never = field.kind;\n      throw new Error(`Unsupported field kind: ${exhaustiveCheck}`);\n    }\n  }\n\n  if (!field.required) {\n    return zodType.optional().nullable();\n  }\n\n  return zodType;\n}\n\n/**\n * The internal schema builder without memoization.\n * @param fields - An array of field definitions.\n * @returns A Zod object schema.\n */\nfunction buildSchemaFromFieldDefs(fields: FieldDef[]): AnyZodObject {\n  const shape: Record<string, ZodTypeAny> = {};\n\n  for (const field of fields) {\n    shape[field.key] = buildZodTypeFromFieldDef(field);\n  }\n\n  return z.object(shape);\n}\n\n// Memoization cache\nconst schemaCache = new Map<string, AnyZodObject>();\n\n/**\n * Gets a Zod validation schema for a given set of field definitions.\n * The result is memoized based on the cacheKey.\n *\n * @param cacheKey - A unique key to identify this set of field definitions (e.g., entityTypeId).\n * @param fields - An array of field definitions.\n * @returns A memoized Zod object schema.\n */\nexport function getValidationSchema(\n  cacheKey: string,\n  fields: FieldDef[],\n): AnyZodObject {\n  if (schemaCache.has(cacheKey)) {\n    return schemaCache.get(cacheKey)!;\n  }\n\n  const newSchema = buildSchemaFromFieldDefs(fields);\n  schemaCache.set(cacheKey, newSchema);\n\n  return newSchema;\n}"
            },
            {
                "path": "packages/core/",
                "content": [
                    {
                        "path": "project/packages/core/dist/index.js",
                        "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.core = void 0;\nconst core = () => 'Hello from @ddms/core';\nexports.core = core;\n//# sourceMappingURL=index.js.map"
                    },
                    {
                        "path": "project/packages/core/dist/index.js.map",
                        "content": "{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/index.ts\"],\"names\":[],\"mappings\":\";;;AAAO,MAAM,IAAI,GAAG,GAAG,EAAE,CAAC,uBAAuB,CAAC;AAArC,QAAA,IAAI,QAAiC\"}"
                    },
                    {
                        "path": "project/packages/core/dist/index.d.ts",
                        "content": "export declare const core: () => string;\n"
                    },
                    {
                        "path": "project/packages/core/tsconfig.tsbuildinfo",
                        "content": "{\"fileNames\":[\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es5.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.iterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.asynciterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.webworker.importscripts.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.scripthost.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.core.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.collection.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.generator.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.iterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.proxy.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.reflect.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.symbol.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.array.include.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.date.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.regexp.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.array.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.symbol.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.bigint.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.date.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.number.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.weakref.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.array.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.error.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.regexp.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.decorators.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.decorators.legacy.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.full.d.ts\",\"./src/index.ts\"],\"fileInfos\":[{\"version\":\"c430d44666289dae81f30fa7b2edebf186ecc91a2d4c71266ea6ae76388792e1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4\",\"impliedFormat\":1},{\"version\":\"3facaf05f0c5fc569c5649dd359892c98a85557e3e0c847964caeb67076f4d75\",\"impliedFormat\":1},{\"version\":\"e44bb8bbac7f10ecc786703fe0a6a4b952189f908707980ba8f3c8975a760962\",\"impliedFormat\":1},{\"version\":\"5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8\",\"impliedFormat\":1},{\"version\":\"68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7\",\"impliedFormat\":1},{\"version\":\"5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4\",\"impliedFormat\":1},{\"version\":\"feecb1be483ed332fad555aff858affd90a48ab19ba7272ee084704eb7167569\",\"impliedFormat\":1},{\"version\":\"ee7bad0c15b58988daa84371e0b89d313b762ab83cb5b31b8a2d1162e8eb41c2\",\"impliedFormat\":1},{\"version\":\"080941d9f9ff9307f7e27a83bcd888b7c8270716c39af943532438932ec1d0b9\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"2e80ee7a49e8ac312cc11b77f1475804bee36b3b2bc896bead8b6e1266befb43\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d7a3c8b952931daebdfc7a2897c53c0a1c73624593fa070e46bd537e64dcd20a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"80e18897e5884b6723488d4f5652167e7bb5024f946743134ecc4aa4ee731f89\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"cd034f499c6cdca722b60c04b5b1b78e058487a7085a8e0d6fb50809947ee573\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"c57796738e7f83dbc4b8e65132f11a377649c00dd3eee333f672b8f0a6bea671\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"dc2df20b1bcdc8c2d34af4926e2c3ab15ffe1160a63e58b7e09833f616efff44\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"515d0b7b9bea2e31ea4ec968e9edd2c39d3eebf4a2d5cbd04e88639819ae3b71\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0559b1f683ac7505ae451f9a96ce4c3c92bdc71411651ca6ddb0e88baaaad6a3\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0dc1e7ceda9b8b9b455c3a2d67b0412feab00bd2f66656cd8850e8831b08b537\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"4ff2a353abf8a80ee399af572debb8faab2d33ad38c4b4474cff7f26e7653b8d\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"fb0f136d372979348d59b3f5020b4cdb81b5504192b1cacff5d1fbba29378aa1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d15bea3d62cbbdb9797079416b8ac375ae99162a7fba5de2c6c505446486ac0a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"68d18b664c9d32a7336a70235958b8997ebc1c3b8505f4f1ae2b7e7753b87618\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"eb3d66c8327153d8fa7dd03f9c58d351107fe824c79e9b56b462935176cdf12a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"69ab18c3b76cd9b1be3d188eaf8bba06112ebbe2f47f6c322b5105a6fbc45a2e\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"a680117f487a4d2f30ea46f1b4b7f58bef1480456e18ba53ee85c2746eeca012\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"4de680d5bb41c17f7f68e0419412ca23c98d5749dcaaea1896172f06435891fc\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"954296b30da6d508a104a3a0b5d96b76495c709785c1d11610908e63481ee667\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"ac9538681b19688c8eae65811b329d3744af679e0bdfa5d842d0e32524c73e1c\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0a969edff4bd52585473d24995c5ef223f6652d6ef46193309b3921d65dd4376\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"9e9fbd7030c440b33d021da145d3232984c8bb7916f277e8ffd3dc2e3eae2bdb\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"811ec78f7fefcabbda4bfa93b3eb67d9ae166ef95f9bff989d964061cbf81a0c\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"717937616a17072082152a2ef351cb51f98802fb4b2fdabd32399843875974ca\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d7e7d9b7b50e5f22c915b525acc5a49a7a6584cf8f62d0569e557c5cfc4b2ac2\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"71c37f4c9543f31dfced6c7840e068c5a5aacb7b89111a4364b1d5276b852557\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"74f7fa2d027d5b33eb0471c8e82a6c87216223181ec31247c357a3e8e2fddc5b\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d6d7ae4d1f1f3772e2a3cde568ed08991a8ae34a080ff1151af28b7f798e22ca\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"063600664504610fe3e99b717a1223f8b1900087fab0b4cad1496a114744f8df\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"934019d7e3c81950f9a8426d093458b65d5aff2c7c1511233c0fd5b941e608ab\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"52ada8e0b6e0482b728070b7639ee42e83a9b1c22d205992756fe020fd9f4a47\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3bdefe1bfd4d6dee0e26f928f93ccc128f1b64d5d501ff4a8cf3c6371200e5e6\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"59fb2c069260b4ba00b5643b907ef5d5341b167e7d1dbf58dfd895658bda2867\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"639e512c0dfc3fad96a84caad71b8834d66329a1f28dc95e3946c9b58176c73a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"af3dd424cf267428f30ccfc376f47a2c0114546b55c44d8c0f1d57d841e28d74\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"995c005ab91a498455ea8dfb63aa9f83fa2ea793c3d8aa344be4a1678d06d399\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"959d36cddf5e7d572a65045b876f2956c973a586da58e5d26cde519184fd9b8a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"965f36eae237dd74e6cca203a43e9ca801ce38824ead814728a2807b1910117d\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3925a6c820dcb1a06506c90b1577db1fdbf7705d65b62b99dce4be75c637e26b\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0a3d63ef2b853447ec4f749d3f368ce642264246e02911fcb1590d8c161b8005\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8cdf8847677ac7d20486e54dd3fcf09eda95812ac8ace44b4418da1bbbab6eb8\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8444af78980e3b20b49324f4a16ba35024fef3ee069a0eb67616ea6ca821c47a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3287d9d085fbd618c3971944b65b4be57859f5415f495b33a6adc994edd2f004\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"b4b67b1a91182421f5df999988c690f14d813b9850b40acd06ed44691f6727ad\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8e7f8264d0fb4c5339605a15daadb037bf238c10b654bb3eee14208f860a32ea\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3cbad9a1ba4453443026ed38e4b8be018abb26565fa7c944376463ad9df07c41\",\"impliedFormat\":1},{\"version\":\"3ed321a1f1fcaeb1c05cc9f6d90e149bad7642cfa73facb323a347198e7b6e62\",\"signature\":\"252314f963f733f961076c222dbe6ce80a2062a15c5b8bf5e48f06f5247856f4\",\"impliedFormat\":1}],\"root\":[64],\"options\":{\"composite\":true,\"declaration\":true,\"esModuleInterop\":true,\"module\":199,\"outDir\":\"./dist\",\"rootDir\":\"./src\",\"skipLibCheck\":true,\"sourceMap\":true,\"strict\":true,\"target\":9},\"latestChangedDtsFile\":\"./dist/index.d.ts\",\"version\":\"5.9.3\"}"
                    },
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"tsx --test src/**/*.test.ts\"\n  },\n  \"dependencies\": {\n    \"@ddms/db\": \"workspace:*\",\n    \"drizzle-orm\": \"^0.32.1\",\n    \"zod\": \"^3.23.8\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.14.2\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\",\n    \"types\": [\n      \"node\"\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/core/src/validation.ts",
                        "content": "import { z, ZodTypeAny, AnyZodObject } from 'zod';\nimport { fieldDefs } from '@ddms/db/schema';\nimport { InferSelectModel } from 'drizzle-orm';\n\n// Drizzle's InferSelectModel gives us the type of a selected row.\nexport type FieldDef = InferSelectModel<typeof fieldDefs>;\n\n// Schemas for the `validate` JSONB column, nested by field kind as per manifest\nconst textValidationSchema = z\n  .object({\n    minLen: z.number().optional(),\n    maxLen: z.number().optional(),\n    regex: z.string().optional(),\n  })\n  .optional();\n\nconst numberValidationSchema = z\n  .object({\n    min: z.number().optional(),\n    max: z.number().optional(),\n    integer: z.boolean().optional(),\n  })\n  .optional();\n\nconst dateValidationSchema = z\n  .object({\n    min: z.string().optional(),\n    max: z.string().optional(),\n  })\n  .optional();\n\n// Schemas for the `options` JSONB column\nconst selectOptionsSchema = z\n  .object({\n    enum: z.array(z.string()).min(1),\n    multiselect: z.boolean().optional(),\n  })\n  .optional();\n\nconst relationOptionsSchema = z\n  .object({\n    relation: z.object({\n      target_entity_type_id: z.string().uuid(),\n      cardinality: z.enum(['one', 'many']).optional(),\n    }),\n  })\n  .optional();\n\n/**\n * Builds a Zod schema from a single field definition.\n * @param field - The field definition from the database.\n * @returns A Zod type for the given field.\n */\nfunction buildZodTypeFromFieldDef(field: FieldDef): ZodTypeAny {\n  let zodType: ZodTypeAny;\n\n  switch (field.kind) {\n    case 'text': {\n      let type = z.string();\n      const validationRules = z\n        .object({ text: textValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.text;\n\n      if (validate?.minLen !== undefined) {\n        type = type.min(validate.minLen);\n      }\n      if (validate?.maxLen !== undefined) {\n        type = type.max(validate.maxLen);\n      }\n      if (validate?.regex) {\n        type = type.regex(new RegExp(validate.regex));\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'number': {\n      let type = z.number();\n      const validationRules = z\n        .object({ number: numberValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.number;\n\n      if (validate?.min !== undefined) {\n        type = type.min(validate.min);\n      }\n      if (validate?.max !== undefined) {\n        type = type.max(validate.max);\n      }\n      if (validate?.integer) {\n        type = type.int();\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'date': {\n      let type = z\n        .string()\n        .datetime({ message: 'Invalid ISO 8601 date format' });\n      const validationRules = z\n        .object({ date: dateValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.date;\n\n      if (validate?.min) {\n        type = type.refine((val) => new Date(val) >= new Date(validate!.min!), {\n          message: `Date must be on or after ${validate.min}`,\n        });\n      }\n      if (validate?.max) {\n        type = type.refine((val) => new Date(val) <= new Date(validate!.max!), {\n          message: `Date must be on or before ${validate.max}`,\n        });\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'boolean': {\n      zodType = z.boolean();\n      break;\n    }\n\n    case 'select': {\n      const options = selectOptionsSchema.parse(field.options ?? {});\n      if (!options?.enum) {\n        throw new Error(\n          `'select' field '${field.key}' is missing enum options.`,\n        );\n      }\n      const enumType = z.enum(options.enum as [string, ...string[]]);\n      if (options.multiselect) {\n        zodType = z.array(enumType);\n      } else {\n        zodType = enumType;\n      }\n      break;\n    }\n\n    case 'relation': {\n      const options = relationOptionsSchema.parse(field.options ?? {});\n      const relationOptions = options?.relation;\n      if (!relationOptions?.target_entity_type_id) {\n        throw new Error(\n          `'relation' field '${field.key}' is missing target_entity_type_id.`,\n        );\n      }\n      const uuidType = z.string().uuid();\n      if (relationOptions.cardinality === 'many') {\n        zodType = z.array(uuidType);\n      } else {\n        zodType = uuidType;\n      }\n      break;\n    }\n\n    default: {\n      const exhaustiveCheck: never = field.kind;\n      throw new Error(`Unsupported field kind: ${exhaustiveCheck}`);\n    }\n  }\n\n  if (!field.required) {\n    return zodType.optional().nullable();\n  }\n\n  return zodType;\n}\n\n/**\n * The internal schema builder without memoization.\n * @param fields - An array of field definitions.\n * @returns A Zod object schema.\n */\nfunction buildSchemaFromFieldDefs(fields: FieldDef[]): AnyZodObject {\n  const shape: Record<string, ZodTypeAny> = {};\n\n  for (const field of fields) {\n    shape[field.key] = buildZodTypeFromFieldDef(field);\n  }\n\n  return z.object(shape);\n}\n\n// Memoization cache\nconst schemaCache = new Map<string, AnyZodObject>();\n\n/**\n * Gets a Zod validation schema for a given set of field definitions.\n * The result is memoized based on the cacheKey.\n *\n * @param cacheKey - A unique key to identify this set of field definitions (e.g., entityTypeId).\n * @param fields - An array of field definitions.\n * @returns A memoized Zod object schema.\n */\nexport function getValidationSchema(\n  cacheKey: string,\n  fields: FieldDef[],\n): AnyZodObject {\n  if (schemaCache.has(cacheKey)) {\n    return schemaCache.get(cacheKey)!;\n  }\n\n  const newSchema = buildSchemaFromFieldDefs(fields);\n  schemaCache.set(cacheKey, newSchema);\n\n  return newSchema;\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export * from './validation';"
                    },
                    {
                        "path": "project/packages/core/src/validation.test.ts",
                        "content": "import { describe, it } from 'node:test';\nimport assert from 'node:assert';\nimport { getValidationSchema, FieldDef } from './validation';\nimport { ZodError } from 'zod';\n\nconst baseFieldDef: Omit<FieldDef, 'key' | 'kind'> = {\n  id: 'uuid-id',\n  tenantId: 'uuid-tenant',\n  entityTypeId: 'uuid-entity-type',\n  label: 'Test Field',\n  required: false,\n  uniqueWithinType: false,\n  searchable: true,\n  indexed: false,\n  options: {},\n  validate: {},\n  acl: {},\n  position: 0,\n  active: true,\n};\n\ndescribe('getValidationSchema', () => {\n  it('should handle required and optional text fields', () => {\n    const fields: FieldDef[] = [\n      { ...baseFieldDef, key: 'name', kind: 'text', required: true },\n      { ...baseFieldDef, key: 'description', kind: 'text', required: false },\n    ];\n    const schema = getValidationSchema('text-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ name: 'test' }));\n    assert.throws(() => schema.parse({}), ZodError);\n    assert.doesNotThrow(() => schema.parse({ name: 'test', description: null }));\n    assert.doesNotThrow(() =>\n      schema.parse({ name: 'test', description: 'desc' }),\n    );\n  });\n\n  it('should handle text validation rules (minLen, maxLen, regex)', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'code',\n        kind: 'text',\n        required: true,\n        validate: { text: { minLen: 3, maxLen: 5, regex: '^[A-Z]+$' } },\n      },\n    ];\n    const schema = getValidationSchema('text-validation-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ code: 'ABCDE' }));\n    assert.throws(\n      () => schema.parse({ code: 'AB' }),\n      ZodError,\n      'minLen failed',\n    );\n    assert.throws(\n      () => schema.parse({ code: 'ABCDEF' }),\n      ZodError,\n      'maxLen failed',\n    );\n    assert.throws(\n      () => schema.parse({ code: 'abc' }),\n      ZodError,\n      'regex failed',\n    );\n  });\n\n  it('should handle number validation rules (min, max, integer)', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'amount',\n        kind: 'number',\n        required: true,\n        validate: { number: { min: 0, max: 100, integer: true } },\n      },\n    ];\n    const schema = getValidationSchema('number-validation-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ amount: 50 }));\n    assert.throws(\n      () => schema.parse({ amount: -1 }),\n      ZodError,\n      'min failed',\n    );\n    assert.throws(\n      () => schema.parse({ amount: 101 }),\n      ZodError,\n      'max failed',\n    );\n    assert.throws(\n      () => schema.parse({ amount: 50.5 }),\n      ZodError,\n      'integer failed',\n    );\n  });\n\n  it('should handle date validation', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'eventDate',\n        kind: 'date',\n        required: true,\n      },\n    ];\n    const schema = getValidationSchema('date-validation-test', fields);\n\n    assert.doesNotThrow(() =>\n      schema.parse({ eventDate: new Date().toISOString() }),\n    );\n    assert.throws(() => schema.parse({ eventDate: 'not a date' }), ZodError);\n  });\n\n  it('should handle boolean fields', () => {\n    const fields: FieldDef[] = [\n      { ...baseFieldDef, key: 'isActive', kind: 'boolean', required: true },\n    ];\n    const schema = getValidationSchema('boolean-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ isActive: true }));\n    assert.throws(() => schema.parse({ isActive: 'true' }), ZodError);\n    assert.throws(() => schema.parse({}), ZodError);\n  });\n\n  it('should handle single-select fields', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'status',\n        kind: 'select',\n        required: true,\n        options: { enum: ['open', 'closed'] },\n      },\n    ];\n    const schema = getValidationSchema('select-single-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ status: 'open' }));\n    assert.throws(() => schema.parse({ status: 'pending' }), ZodError);\n  });\n\n  it('should handle multi-select fields', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'tags',\n        kind: 'select',\n        required: false,\n        options: { enum: ['a', 'b', 'c'], multiselect: true },\n      },\n    ];\n    const schema = getValidationSchema('select-multi-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ tags: ['a', 'c'] }));\n    assert.throws(() => schema.parse({ tags: ['a', 'd'] }), ZodError);\n    assert.doesNotThrow(() => schema.parse({}));\n  });\n\n  it('should handle relation fields (one and many)', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'ownerId',\n        kind: 'relation',\n        required: true,\n        options: { relation: { target_entity_type_id: 'uuid-user' } }, // cardinality 'one' is default\n      },\n      {\n        ...baseFieldDef,\n        key: 'projectIds',\n        kind: 'relation',\n        required: false,\n        options: {\n          relation: {\n            target_entity_type_id: 'uuid-project',\n            cardinality: 'many',\n          },\n        },\n      },\n    ];\n    const schema = getValidationSchema('relation-test', fields);\n    const validUUID = '123e4567-e89b-12d3-a456-426614174000';\n\n    assert.doesNotThrow(() => schema.parse({ ownerId: validUUID }));\n    assert.throws(() => schema.parse({ ownerId: 'not-a-uuid' }), ZodError);\n    assert.doesNotThrow(() =>\n      schema.parse({ ownerId: validUUID, projectIds: [validUUID] }),\n    );\n    assert.throws(\n      () => schema.parse({ ownerId: validUUID, projectIds: ['not-a-uuid'] }),\n      ZodError,\n    );\n  });\n\n  it('should use memoized schema on subsequent calls', () => {\n    const fields: FieldDef[] = [\n      { ...baseFieldDef, key: 'name', kind: 'text', required: true },\n    ];\n    const schema1 = getValidationSchema('memo-test', fields);\n    const schema2 = getValidationSchema('memo-test', fields);\n\n    assert.strictEqual(schema1, schema2);\n  });\n});"
                    }
                ]
            }
        ]
    },
    {
        "name": "I3.T3",
        "context": {
            "task_id": "I3.T3",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the DAL functions for `records` within `apps/api`, including create, read, update, and a search function that accepts compiled SQL fragments.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Drizzle schema from `I1.T2`.",
            "target_files": [
                "apps/api/src/lib/dal/records.ts"
            ],
            "input_files": [
                "packages/db/src/schema.ts",
                "apps/api/src/"
            ],
            "deliverables": "TypeScript functions for interacting with the `records` table.",
            "acceptance_criteria": "Functions are type-safe and correctly perform their respective database operations.",
            "dependencies": [
                "I1.T2"
            ],
            "parallelizable": true
        },
        "output": "An expert developer collaboratively working on a project, I will now proceed with the task I3.T3.\n\nMy plan is as follows:\n1.  I will create a new file `apps/api/src/lib/dal/records.ts` as it does not exist.\n2.  I will define the necessary TypeScript types and interfaces, leveraging Drizzle's schema inference for type safety. This includes `Db`, `Record`, `NewRecord`, `RecordData`, and `SearchOptions`.\n3.  I will implement the `createRecord` function to insert a new record into the database, ensuring it's scoped to the correct tenant and entity type.\n4.  I will implement the `findRecordById` function to retrieve a single record, ensuring the query is scoped by both record ID and tenant ID for security.\n5.  I will implement the `updateRecord` function, which will include optimistic concurrency control by checking the `version` number in the `WHERE` clause, alongside the record ID and tenant ID.\n6.  Finally, I will implement the `searchRecords` function. This function will be designed to accept a pre-compiled SQL fragment (`SQL` object from Drizzle), along with sorting and pagination options, to build and execute a dynamic search query.\n\nThis approach ensures all acceptance criteria are met, providing a robust, secure, and type-safe Data Access Layer for the `records` table.\n\n~~~typescript\n#- file: apps/api/src/lib/dal/records.ts\nimport { and, asc, desc, eq, SQL } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\n//\n// Type Definitions\n//\n\ntype Db = FastifyInstance['db'];\ntype NewRecord = typeof schema.records.$inferInsert;\ntype Record = typeof schema.records.$inferSelect;\ntype RecordData = Record<string, unknown>;\n\n/**\n * Options for the searchRecords function.\n */\nexport interface SearchOptions {\n  /** The compiled WHERE clause from the Filter DSL Compiler */\n  filter: SQL;\n  /** Sorting options */\n  sort?: { field: keyof Record; direction: 'asc' | 'desc' };\n  /** Pagination options */\n  pagination: { limit: number; offset: number };\n}\n\n//\n// Record Functions\n//\n\n/**\n * Creates a new record for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @param payload The data for the new record.\n * @returns The newly created record.\n */\nexport async function createRecord(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  payload: { data: RecordData; createdBy?: string },\n) {\n  const [result] = await db\n    .insert(schema.records)\n    .values({\n      tenantId,\n      entityTypeId,\n      data: payload.data,\n      createdBy: payload.createdBy,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds a single record by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param recordId The ID of the record to find.\n * @returns The record, or undefined if not found or not owned by the tenant.\n */\nexport async function findRecordById(\n  db: Db,\n  tenantId: string,\n  recordId: string,\n) {\n  return db.query.records.findFirst({\n    where: and(\n      eq(schema.records.id, recordId),\n      eq(schema.records.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing record, using optimistic concurrency control.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param recordId The ID of the record to update.\n * @param version The expected version of the record.\n * @param payload The data to update.\n * @returns The updated record, or undefined if the record was not found or the version mismatched.\n */\nexport async function updateRecord(\n  db: Db,\n  tenantId: string,\n  recordId: string,\n  version: number,\n  payload: { data: Partial<RecordData>; updatedBy?: string },\n) {\n  const [result] = await db\n    .update(schema.records)\n    .set({\n      data: payload.data,\n      updatedBy: payload.updatedBy,\n      updatedAt: new Date(), // Explicitly set updatedAt\n    })\n    .where(\n      and(\n        eq(schema.records.id, recordId),\n        eq(schema.records.tenantId, tenantId),\n        eq(schema.records.version, version),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n/**\n * Searches for records based on a compiled filter, with sorting and pagination.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to search within.\n * @param options The search, sorting, and pagination options.\n * @returns An array of found records.\n */\nexport async function searchRecords(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  options: SearchOptions,\n) {\n  const conditions = [\n    eq(schema.records.tenantId, tenantId),\n    eq(schema.records.entityTypeId, entityTypeId),\n    options.filter,\n  ];\n\n  let query = db\n    .select()\n    .from(schema.records)\n    .where(and(...conditions));\n\n  if (options.sort) {\n    const sortColumn = schema.records[options.sort.field];\n    if (sortColumn) {\n      const direction = options.sort.direction === 'asc' ? asc : desc;\n      query = query.orderBy(direction(sortColumn));\n    }\n  }\n\n  query = query\n    .limit(options.pagination.limit)\n    .offset(options.pagination.offset);\n\n  return query;\n}\n~~~",
        "iteration_id": "I3",
        "completed": true,
        "target_files": [
            "apps/api/src/lib/dal/records.ts"
        ],
        "input_files": [
            "packages/db/src/schema.ts",
            "apps/api/src/"
        ],
        "files": [
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            },
            {
                "path": "apps/api/src/",
                "content": [
                    {
                        "path": "project/apps/api/src/plugins/db.ts",
                        "content": "import { drizzle } from 'drizzle-orm/node-postgres';\nimport fp from 'fastify-plugin';\nimport { Pool } from 'pg';\nimport * as schema from '@ddms/db';\n\n// Augment FastifyInstance with the db decorator\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    db: ReturnType<typeof drizzle<typeof schema>>;\n  }\n}\n\n/**\n * This plugin creates a Drizzle instance and decorates the Fastify instance with it.\n * It also handles graceful shutdown of the database connection pool.\n */\nexport default fp(async function (fastify) {\n  if (!process.env.DATABASE_URL) {\n    fastify.log.error('DATABASE_URL environment variable is not set.');\n    throw new Error('DATABASE_URL is not set');\n  }\n\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n  });\n\n  const db = drizzle(pool, { schema });\n\n  fastify.decorate('db', db);\n\n  fastify.addHook('onClose', async (instance) => {\n    instance.log.info('Closing database connection pool...');\n    await pool.end();\n    instance.log.info('Database connection pool closed.');\n  });\n});"
                    },
                    {
                        "path": "project/apps/api/src/plugins/tenant_context.ts",
                        "content": "import { FastifyPluginAsync } from 'fastify';\nimport fp from 'fastify-plugin';\nimport { sql } from 'drizzle-orm';\nimport { ZodError, z } from 'zod';\n\n// Augment FastifyRequest with the tenantId property\ndeclare module 'fastify' {\n  interface FastifyRequest {\n    tenantId: string;\n  }\n}\n\nconst tenantIdSchema = z.string().uuid({ message: 'Invalid tenant ID format.' });\n\nconst tenantContextPlugin: FastifyPluginAsync = async (fastify) => {\n  // Decorate the request with a tenantId property\n  fastify.decorateRequest('tenantId', '');\n\n  fastify.addHook('preHandler', async (request, reply) => {\n    // Bypass tenant check for health route\n    if (request.url === '/health') {\n      return;\n    }\n\n    const tenantId = request.headers['x-tenant-id'];\n\n    if (!tenantId || typeof tenantId !== 'string') {\n      return reply.status(400).send({\n        code: 'BAD_REQUEST',\n        message: 'x-tenant-id header is required.',\n      });\n    }\n\n    try {\n      const validatedTenantId = tenantIdSchema.parse(tenantId);\n\n      // Attach the validated tenantId to the request object\n      request.tenantId = validatedTenantId;\n\n      // The third argument `true` makes the setting local to the current transaction.\n      await request.server.db.execute(\n        sql`SELECT set_config('app.tenant_id', ${validatedTenantId}, true)`,\n      );\n    } catch (err) {\n      if (err instanceof ZodError) {\n        return reply.status(400).send({\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid x-tenant-id header.',\n          errors: err.errors,\n        });\n      }\n      request.log.error(err, 'Failed to set tenant context');\n      return reply.status(500).send({\n        code: 'INTERNAL_SERVER_ERROR',\n        message: 'An unexpected error occurred while setting tenant context.',\n      });\n    }\n  });\n};\n\nexport default fp(tenantContextPlugin, {\n  name: 'tenantContext',\n  dependencies: ['db'],\n});"
                    },
                    {
                        "path": "project/apps/api/src/lib/dal/metadata.ts",
                        "content": "import { and, eq } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\ntype Db = FastifyInstance['db'];\ntype NewEntityType = typeof schema.entityTypes.$inferInsert;\ntype NewFieldDef = typeof schema.fieldDefs.$inferInsert;\n\n//\n// Entity Type Functions\n//\n\n/**\n * Creates a new entity type for a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param data The data for the new entity type.\n * @returns The newly created entity type.\n */\nexport async function createEntityType(\n  db: Db,\n  tenantId: string,\n  data: Omit<NewEntityType, 'tenantId' | 'id'>,\n) {\n  const [result] = await db\n    .insert(schema.entityTypes)\n    .values({\n      ...data,\n      tenantId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all entity types belonging to a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @returns An array of entity types.\n */\nexport async function findEntityTypesByTenant(db: Db, tenantId: string) {\n  return db.query.entityTypes.findMany({\n    where: eq(schema.entityTypes.tenantId, tenantId),\n  });\n}\n\n/**\n * Finds a single entity type by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to find.\n * @returns The entity type, or undefined if not found.\n */\nexport async function findEntityTypeById(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.entityTypes.findFirst({\n    where: and(\n      eq(schema.entityTypes.id, entityTypeId),\n      eq(schema.entityTypes.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to update.\n * @param data The data to update.\n * @returns The updated entity type.\n */\nexport async function updateEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Partial<Omit<NewEntityType, 'tenantId' | 'id'>>,\n) {\n  const [result] = await db\n    .update(schema.entityTypes)\n    .set(data)\n    .where(\n      and(\n        eq(schema.entityTypes.id, entityTypeId),\n        eq(schema.entityTypes.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n//\n// Field Definition Functions\n//\n\n/**\n * Creates a new field definition for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the parent entity type.\n * @param data The data for the new field definition.\n * @returns The newly created field definition.\n */\nexport async function createFieldDef(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>,\n) {\n  const [result] = await db\n    .insert(schema.fieldDefs)\n    .values({\n      ...data,\n      tenantId,\n      entityTypeId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all field definitions for a specific entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @returns An array of field definitions.\n */\nexport async function findFieldDefsByEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.fieldDefs.findMany({\n    where: and(\n      eq(schema.fieldDefs.tenantId, tenantId),\n      eq(schema.fieldDefs.entityTypeId, entityTypeId),\n    ),\n  });\n}\n\n/**\n * Finds a single field definition by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to find.\n * @returns The field definition, or undefined if not found.\n */\nexport async function findFieldDefById(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n) {\n  return db.query.fieldDefs.findFirst({\n    where: and(\n      eq(schema.fieldDefs.id, fieldDefId),\n      eq(schema.fieldDefs.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing field definition.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to update.\n * @param data The data to update.\n * @returns The updated field definition.\n */\nexport async function updateFieldDef(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n  data: Partial<Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>>,\n) {\n  const [result] = await db\n    .update(schema.fieldDefs)\n    .set(data)\n    .where(\n      and(\n        eq(schema.fieldDefs.id, fieldDefId),\n        eq(schema.fieldDefs.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "import 'dotenv/config';\nimport { buildServer } from './server';\n\nasync function main() {\n  const server = await buildServer();\n\n  try {\n    const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 3001;\n    if (isNaN(port)) {\n      server.log.error('Invalid PORT environment variable');\n      process.exit(1);\n    }\n    const host = process.env.HOST || '0.0.0.0';\n\n    await server.listen({ port, host });\n\n    server.log.info(`Server listening at http://${host}:${port}`);\n\n    const signals: NodeJS.Signals[] = ['SIGINT', 'SIGTERM'];\n    for (const signal of signals) {\n      process.on(signal, async () => {\n        try {\n          server.log.info(`Received ${signal}, shutting down gracefully...`);\n          await server.close();\n          server.log.info('Server shut down successfully.');\n          process.exit(0);\n        } catch (err) {\n          server.log.error({ err }, 'Error during server shutdown.');\n          process.exit(1);\n        }\n      });\n    }\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n}\n\nmain();"
                    },
                    {
                        "path": "project/apps/api/src/server.ts",
                        "content": "import fastify from 'fastify';\nimport cors from '@fastify/cors';\nimport {\n  serializerCompiler,\n  validatorCompiler,\n  ZodTypeProvider,\n} from 'fastify-type-provider-zod';\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\nimport metadataRoutes from './routes/metadata';\nimport tenantContextPlugin from './plugins/tenant_context';\n\nexport async function buildServer() {\n  const server = fastify({\n    logger: {\n      transport:\n        process.env.NODE_ENV !== 'production'\n          ? {\n              target: 'pino-pretty',\n            }\n          : undefined,\n    },\n  }).withTypeProvider<ZodTypeProvider>();\n\n  server.setValidatorCompiler(validatorCompiler);\n  server.setSerializerCompiler(serializerCompiler);\n\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(tenantContextPlugin);\n  await server.register(healthRoutes);\n  await server.register(metadataRoutes, { prefix: '/api/v1' });\n\n  return server;\n}"
                    },
                    {
                        "path": "project/apps/api/src/routes/health.ts",
                        "content": "import { FastifyInstance } from 'fastify';\n\n/**\n * Registers a health check route.\n * @param fastify The Fastify instance.\n */\nexport default async function (fastify: FastifyInstance) {\n  fastify.get('/health', async (_request, reply) => {\n    // In a real application, you might also check database connectivity here.\n    // For now, just returning a 200 OK is sufficient.\n    return reply.code(200).send({ status: 'ok' });\n  });\n}"
                    },
                    {
                        "path": "project/apps/api/src/routes/metadata/schemas.ts",
                        "content": "import { z } from 'zod';\n\n// Reusable parameter schemas\nexport const entityTypeIdParamsSchema = z.object({\n  entityTypeId: z.string().uuid(),\n});\n\nexport const fieldIdParamsSchema = z.object({\n  fieldId: z.string().uuid(),\n});\n\n// Entity Type Schemas\nexport const entityTypeSchema = z.object({\n  id: z.string().uuid(),\n  key: z.string(),\n  label: z.string(),\n  description: z.string().nullable(),\n});\n\nexport const createEntityTypeBodySchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  description: z.string().nullable().optional(),\n});\n\nexport const updateEntityTypeBodySchema = z.object({\n  label: z.string().optional(),\n  description: z.string().nullable().optional(),\n});\n\n// Field Definition Schemas\nconst fieldKindEnum = z.enum([\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nexport const fieldDefSchema = z.object({\n  id: z.string().uuid(),\n  entityTypeId: z.string().uuid(),\n  key: z.string(),\n  label: z.string(),\n  kind: fieldKindEnum,\n  required: z.boolean(),\n  uniqueWithinType: z.boolean(),\n  searchable: z.boolean(),\n  indexed: z.boolean(),\n  options: z.record(z.any()),\n  validate: z.record(z.any()),\n  acl: z.record(z.any()),\n  position: z.number().int(),\n  active: z.boolean(),\n});\n\nexport const createFieldDefBodySchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  kind: fieldKindEnum,\n  required: z.boolean().optional(),\n  uniqueWithinType: z.boolean().optional(),\n  searchable: z.boolean().optional(),\n  indexed: z.boolean().optional(),\n  options: z.record(z.any()).optional(),\n  validate: z.record(z.any()).optional(),\n  acl: z.record(z.any()).optional(),\n  position: z.number().int().optional(),\n});\n\nexport const updateFieldDefBodySchema = z.object({\n  label: z.string().optional(),\n  required: z.boolean().optional(),\n  uniqueWithinType: z.boolean().optional(),\n  searchable: z.boolean().optional(),\n  indexed: z.boolean().optional(),\n  options: z.record(z.any()).optional(),\n  validate: z.record(z.any()).optional(),\n  acl: z.record(z.any()).optional(),\n  position: z.number().int().optional(),\n  active: z.boolean().optional(),\n});"
                    },
                    {
                        "path": "project/apps/api/src/routes/metadata/index.ts",
                        "content": "import { FastifyPluginAsync } from 'fastify';\nimport * as dal from '../../lib/dal/metadata';\nimport {\n  createEntityTypeBodySchema,\n  entityTypeSchema,\n  updateEntityTypeBodySchema,\n  entityTypeIdParamsSchema,\n  fieldIdParamsSchema,\n  fieldDefSchema,\n  createFieldDefBodySchema,\n  updateFieldDefBodySchema,\n} from './schemas';\n\nconst metadataRoutes: FastifyPluginAsync = async (fastify) => {\n  //\n  // Entity Type Routes\n  //\n\n  fastify.get(\n    '/entity-types',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'List Entity Types',\n        response: {\n          200: entityTypeSchema.array(),\n        },\n      },\n    },\n    async (request, reply) => {\n      const entityTypes = await dal.findEntityTypesByTenant(\n        request.db,\n        request.tenantId,\n      );\n      return reply.send(entityTypes);\n    },\n  );\n\n  fastify.post(\n    '/entity-types',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Create Entity Type',\n        body: createEntityTypeBodySchema,\n        response: {\n          201: entityTypeSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const newEntityType = await dal.createEntityType(\n        request.db,\n        request.tenantId,\n        request.body,\n      );\n      return reply.code(201).send(newEntityType);\n    },\n  );\n\n  fastify.patch(\n    '/entity-types/:entityTypeId',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Update Entity Type',\n        params: entityTypeIdParamsSchema,\n        body: updateEntityTypeBodySchema,\n        response: {\n          200: entityTypeSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const existing = await dal.findEntityTypeById(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n      );\n      if (!existing) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const updatedEntityType = await dal.updateEntityType(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n        request.body,\n      );\n      return reply.send(updatedEntityType);\n    },\n  );\n\n  //\n  // Field Definition Routes\n  //\n\n  fastify.get(\n    '/entity-types/:entityTypeId/fields',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'List Field Definitions',\n        params: entityTypeIdParamsSchema,\n        response: {\n          200: fieldDefSchema.array(),\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const entityType = await dal.findEntityTypeById(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n      );\n      if (!entityType) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const fieldDefs = await dal.findFieldDefsByEntityType(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n      );\n      return reply.send(fieldDefs);\n    },\n  );\n\n  fastify.post(\n    '/entity-types/:entityTypeId/fields',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Create Field Definition',\n        params: entityTypeIdParamsSchema,\n        body: createFieldDefBodySchema,\n        response: {\n          201: fieldDefSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const entityType = await dal.findEntityTypeById(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n      );\n      if (!entityType) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const newFieldDef = await dal.createFieldDef(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n        request.body,\n      );\n      return reply.code(201).send(newFieldDef);\n    },\n  );\n\n  fastify.patch(\n    '/fields/:fieldId',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Update Field Definition',\n        params: fieldIdParamsSchema,\n        body: updateFieldDefBodySchema,\n        response: {\n          200: fieldDefSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { fieldId } = request.params;\n\n      const existing = await dal.findFieldDefById(\n        request.db,\n        request.tenantId,\n        fieldId,\n      );\n      if (!existing) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Field definition not found' });\n      }\n\n      const updatedFieldDef = await dal.updateFieldDef(\n        request.db,\n        request.tenantId,\n        fieldId,\n        request.body,\n      );\n      return reply.send(updatedFieldDef);\n    },\n  );\n};\n\nexport default metadataRoutes;"
                    }
                ]
            },
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            },
            {
                "path": "apps/api/src/lib/dal/records.ts",
                "content": "import { and, asc, desc, eq, SQL } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\n//\n// Type Definitions\n//\n\ntype Db = FastifyInstance['db'];\ntype NewRecord = typeof schema.records.$inferInsert;\ntype Record = typeof schema.records.$inferSelect;\ntype RecordData = Record<string, unknown>;\n\n/**\n * Options for the searchRecords function.\n */\nexport interface SearchOptions {\n  /** The compiled WHERE clause from the Filter DSL Compiler */\n  filter: SQL;\n  /** Sorting options */\n  sort?: { field: keyof Record; direction: 'asc' | 'desc' };\n  /** Pagination options */\n  pagination: { limit: number; offset: number };\n}\n\n//\n// Record Functions\n//\n\n/**\n * Creates a new record for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @param payload The data for the new record.\n * @returns The newly created record.\n */\nexport async function createRecord(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  payload: { data: RecordData; createdBy?: string },\n) {\n  const [result] = await db\n    .insert(schema.records)\n    .values({\n      tenantId,\n      entityTypeId,\n      data: payload.data,\n      createdBy: payload.createdBy,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds a single record by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param recordId The ID of the record to find.\n * @returns The record, or undefined if not found or not owned by the tenant.\n */\nexport async function findRecordById(\n  db: Db,\n  tenantId: string,\n  recordId: string,\n) {\n  return db.query.records.findFirst({\n    where: and(\n      eq(schema.records.id, recordId),\n      eq(schema.records.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing record, using optimistic concurrency control.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param recordId The ID of the record to update.\n * @param version The expected version of the record.\n * @param payload The data to update.\n * @returns The updated record, or undefined if the record was not found or the version mismatched.\n */\nexport async function updateRecord(\n  db: Db,\n  tenantId: string,\n  recordId: string,\n  version: number,\n  payload: { data: Partial<RecordData>; updatedBy?: string },\n) {\n  const [result] = await db\n    .update(schema.records)\n    .set({\n      data: payload.data,\n      updatedBy: payload.updatedBy,\n      updatedAt: new Date(), // Explicitly set updatedAt\n    })\n    .where(\n      and(\n        eq(schema.records.id, recordId),\n        eq(schema.records.tenantId, tenantId),\n        eq(schema.records.version, version),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n/**\n * Searches for records based on a compiled filter, with sorting and pagination.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to search within.\n * @param options The search, sorting, and pagination options.\n * @returns An array of found records.\n */\nexport async function searchRecords(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  options: SearchOptions,\n) {\n  const conditions = [\n    eq(schema.records.tenantId, tenantId),\n    eq(schema.records.entityTypeId, entityTypeId),\n    options.filter,\n  ];\n\n  let query = db\n    .select()\n    .from(schema.records)\n    .where(and(...conditions));\n\n  if (options.sort) {\n    const sortColumn = schema.records[options.sort.field];\n    if (sortColumn) {\n      const direction = options.sort.direction === 'asc' ? asc : desc;\n      query = query.orderBy(direction(sortColumn));\n    }\n  }\n\n  query = query\n    .limit(options.pagination.limit)\n    .offset(options.pagination.offset);\n\n  return query;\n}"
            },
            {
                "path": "apps/api/src/",
                "content": [
                    {
                        "path": "project/apps/api/src/plugins/db.ts",
                        "content": "import { drizzle } from 'drizzle-orm/node-postgres';\nimport fp from 'fastify-plugin';\nimport { Pool } from 'pg';\nimport * as schema from '@ddms/db';\n\n// Augment FastifyInstance with the db decorator\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    db: ReturnType<typeof drizzle<typeof schema>>;\n  }\n}\n\n/**\n * This plugin creates a Drizzle instance and decorates the Fastify instance with it.\n * It also handles graceful shutdown of the database connection pool.\n */\nexport default fp(async function (fastify) {\n  if (!process.env.DATABASE_URL) {\n    fastify.log.error('DATABASE_URL environment variable is not set.');\n    throw new Error('DATABASE_URL is not set');\n  }\n\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n  });\n\n  const db = drizzle(pool, { schema });\n\n  fastify.decorate('db', db);\n\n  fastify.addHook('onClose', async (instance) => {\n    instance.log.info('Closing database connection pool...');\n    await pool.end();\n    instance.log.info('Database connection pool closed.');\n  });\n});"
                    },
                    {
                        "path": "project/apps/api/src/plugins/tenant_context.ts",
                        "content": "import { FastifyPluginAsync } from 'fastify';\nimport fp from 'fastify-plugin';\nimport { sql } from 'drizzle-orm';\nimport { ZodError, z } from 'zod';\n\n// Augment FastifyRequest with the tenantId property\ndeclare module 'fastify' {\n  interface FastifyRequest {\n    tenantId: string;\n  }\n}\n\nconst tenantIdSchema = z.string().uuid({ message: 'Invalid tenant ID format.' });\n\nconst tenantContextPlugin: FastifyPluginAsync = async (fastify) => {\n  // Decorate the request with a tenantId property\n  fastify.decorateRequest('tenantId', '');\n\n  fastify.addHook('preHandler', async (request, reply) => {\n    // Bypass tenant check for health route\n    if (request.url === '/health') {\n      return;\n    }\n\n    const tenantId = request.headers['x-tenant-id'];\n\n    if (!tenantId || typeof tenantId !== 'string') {\n      return reply.status(400).send({\n        code: 'BAD_REQUEST',\n        message: 'x-tenant-id header is required.',\n      });\n    }\n\n    try {\n      const validatedTenantId = tenantIdSchema.parse(tenantId);\n\n      // Attach the validated tenantId to the request object\n      request.tenantId = validatedTenantId;\n\n      // The third argument `true` makes the setting local to the current transaction.\n      await request.server.db.execute(\n        sql`SELECT set_config('app.tenant_id', ${validatedTenantId}, true)`,\n      );\n    } catch (err) {\n      if (err instanceof ZodError) {\n        return reply.status(400).send({\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid x-tenant-id header.',\n          errors: err.errors,\n        });\n      }\n      request.log.error(err, 'Failed to set tenant context');\n      return reply.status(500).send({\n        code: 'INTERNAL_SERVER_ERROR',\n        message: 'An unexpected error occurred while setting tenant context.',\n      });\n    }\n  });\n};\n\nexport default fp(tenantContextPlugin, {\n  name: 'tenantContext',\n  dependencies: ['db'],\n});"
                    },
                    {
                        "path": "project/apps/api/src/lib/dal/records.ts",
                        "content": "import { and, asc, desc, eq, SQL } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\n//\n// Type Definitions\n//\n\ntype Db = FastifyInstance['db'];\ntype NewRecord = typeof schema.records.$inferInsert;\ntype Record = typeof schema.records.$inferSelect;\ntype RecordData = Record<string, unknown>;\n\n/**\n * Options for the searchRecords function.\n */\nexport interface SearchOptions {\n  /** The compiled WHERE clause from the Filter DSL Compiler */\n  filter: SQL;\n  /** Sorting options */\n  sort?: { field: keyof Record; direction: 'asc' | 'desc' };\n  /** Pagination options */\n  pagination: { limit: number; offset: number };\n}\n\n//\n// Record Functions\n//\n\n/**\n * Creates a new record for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @param payload The data for the new record.\n * @returns The newly created record.\n */\nexport async function createRecord(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  payload: { data: RecordData; createdBy?: string },\n) {\n  const [result] = await db\n    .insert(schema.records)\n    .values({\n      tenantId,\n      entityTypeId,\n      data: payload.data,\n      createdBy: payload.createdBy,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds a single record by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param recordId The ID of the record to find.\n * @returns The record, or undefined if not found or not owned by the tenant.\n */\nexport async function findRecordById(\n  db: Db,\n  tenantId: string,\n  recordId: string,\n) {\n  return db.query.records.findFirst({\n    where: and(\n      eq(schema.records.id, recordId),\n      eq(schema.records.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing record, using optimistic concurrency control.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param recordId The ID of the record to update.\n * @param version The expected version of the record.\n * @param payload The data to update.\n * @returns The updated record, or undefined if the record was not found or the version mismatched.\n */\nexport async function updateRecord(\n  db: Db,\n  tenantId: string,\n  recordId: string,\n  version: number,\n  payload: { data: Partial<RecordData>; updatedBy?: string },\n) {\n  const [result] = await db\n    .update(schema.records)\n    .set({\n      data: payload.data,\n      updatedBy: payload.updatedBy,\n      updatedAt: new Date(), // Explicitly set updatedAt\n    })\n    .where(\n      and(\n        eq(schema.records.id, recordId),\n        eq(schema.records.tenantId, tenantId),\n        eq(schema.records.version, version),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n/**\n * Searches for records based on a compiled filter, with sorting and pagination.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to search within.\n * @param options The search, sorting, and pagination options.\n * @returns An array of found records.\n */\nexport async function searchRecords(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  options: SearchOptions,\n) {\n  const conditions = [\n    eq(schema.records.tenantId, tenantId),\n    eq(schema.records.entityTypeId, entityTypeId),\n    options.filter,\n  ];\n\n  let query = db\n    .select()\n    .from(schema.records)\n    .where(and(...conditions));\n\n  if (options.sort) {\n    const sortColumn = schema.records[options.sort.field];\n    if (sortColumn) {\n      const direction = options.sort.direction === 'asc' ? asc : desc;\n      query = query.orderBy(direction(sortColumn));\n    }\n  }\n\n  query = query\n    .limit(options.pagination.limit)\n    .offset(options.pagination.offset);\n\n  return query;\n}"
                    },
                    {
                        "path": "project/apps/api/src/lib/dal/metadata.ts",
                        "content": "import { and, eq } from 'drizzle-orm';\nimport type { FastifyInstance } from 'fastify';\nimport * as schema from '@ddms/db';\n\ntype Db = FastifyInstance['db'];\ntype NewEntityType = typeof schema.entityTypes.$inferInsert;\ntype NewFieldDef = typeof schema.fieldDefs.$inferInsert;\n\n//\n// Entity Type Functions\n//\n\n/**\n * Creates a new entity type for a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param data The data for the new entity type.\n * @returns The newly created entity type.\n */\nexport async function createEntityType(\n  db: Db,\n  tenantId: string,\n  data: Omit<NewEntityType, 'tenantId' | 'id'>,\n) {\n  const [result] = await db\n    .insert(schema.entityTypes)\n    .values({\n      ...data,\n      tenantId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all entity types belonging to a specific tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @returns An array of entity types.\n */\nexport async function findEntityTypesByTenant(db: Db, tenantId: string) {\n  return db.query.entityTypes.findMany({\n    where: eq(schema.entityTypes.tenantId, tenantId),\n  });\n}\n\n/**\n * Finds a single entity type by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to find.\n * @returns The entity type, or undefined if not found.\n */\nexport async function findEntityTypeById(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.entityTypes.findFirst({\n    where: and(\n      eq(schema.entityTypes.id, entityTypeId),\n      eq(schema.entityTypes.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type to update.\n * @param data The data to update.\n * @returns The updated entity type.\n */\nexport async function updateEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Partial<Omit<NewEntityType, 'tenantId' | 'id'>>,\n) {\n  const [result] = await db\n    .update(schema.entityTypes)\n    .set(data)\n    .where(\n      and(\n        eq(schema.entityTypes.id, entityTypeId),\n        eq(schema.entityTypes.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}\n\n//\n// Field Definition Functions\n//\n\n/**\n * Creates a new field definition for a specific entity type and tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the parent entity type.\n * @param data The data for the new field definition.\n * @returns The newly created field definition.\n */\nexport async function createFieldDef(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n  data: Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>,\n) {\n  const [result] = await db\n    .insert(schema.fieldDefs)\n    .values({\n      ...data,\n      tenantId,\n      entityTypeId,\n    })\n    .returning();\n  return result;\n}\n\n/**\n * Finds all field definitions for a specific entity type.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param entityTypeId The ID of the entity type.\n * @returns An array of field definitions.\n */\nexport async function findFieldDefsByEntityType(\n  db: Db,\n  tenantId: string,\n  entityTypeId: string,\n) {\n  return db.query.fieldDefs.findMany({\n    where: and(\n      eq(schema.fieldDefs.tenantId, tenantId),\n      eq(schema.fieldDefs.entityTypeId, entityTypeId),\n    ),\n  });\n}\n\n/**\n * Finds a single field definition by its ID, ensuring it belongs to the correct tenant.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to find.\n * @returns The field definition, or undefined if not found.\n */\nexport async function findFieldDefById(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n) {\n  return db.query.fieldDefs.findFirst({\n    where: and(\n      eq(schema.fieldDefs.id, fieldDefId),\n      eq(schema.fieldDefs.tenantId, tenantId),\n    ),\n  });\n}\n\n/**\n * Updates an existing field definition.\n * @param db The Drizzle database instance.\n * @param tenantId The ID of the tenant.\n * @param fieldDefId The ID of the field definition to update.\n * @param data The data to update.\n * @returns The updated field definition.\n */\nexport async function updateFieldDef(\n  db: Db,\n  tenantId: string,\n  fieldDefId: string,\n  data: Partial<Omit<NewFieldDef, 'tenantId' | 'id' | 'entityTypeId'>>,\n) {\n  const [result] = await db\n    .update(schema.fieldDefs)\n    .set(data)\n    .where(\n      and(\n        eq(schema.fieldDefs.id, fieldDefId),\n        eq(schema.fieldDefs.tenantId, tenantId),\n      ),\n    )\n    .returning();\n  return result;\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "import 'dotenv/config';\nimport { buildServer } from './server';\n\nasync function main() {\n  const server = await buildServer();\n\n  try {\n    const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 3001;\n    if (isNaN(port)) {\n      server.log.error('Invalid PORT environment variable');\n      process.exit(1);\n    }\n    const host = process.env.HOST || '0.0.0.0';\n\n    await server.listen({ port, host });\n\n    server.log.info(`Server listening at http://${host}:${port}`);\n\n    const signals: NodeJS.Signals[] = ['SIGINT', 'SIGTERM'];\n    for (const signal of signals) {\n      process.on(signal, async () => {\n        try {\n          server.log.info(`Received ${signal}, shutting down gracefully...`);\n          await server.close();\n          server.log.info('Server shut down successfully.');\n          process.exit(0);\n        } catch (err) {\n          server.log.error({ err }, 'Error during server shutdown.');\n          process.exit(1);\n        }\n      });\n    }\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n}\n\nmain();"
                    },
                    {
                        "path": "project/apps/api/src/server.ts",
                        "content": "import fastify from 'fastify';\nimport cors from '@fastify/cors';\nimport {\n  serializerCompiler,\n  validatorCompiler,\n  ZodTypeProvider,\n} from 'fastify-type-provider-zod';\nimport dbPlugin from './plugins/db';\nimport healthRoutes from './routes/health';\nimport metadataRoutes from './routes/metadata';\nimport tenantContextPlugin from './plugins/tenant_context';\n\nexport async function buildServer() {\n  const server = fastify({\n    logger: {\n      transport:\n        process.env.NODE_ENV !== 'production'\n          ? {\n              target: 'pino-pretty',\n            }\n          : undefined,\n    },\n  }).withTypeProvider<ZodTypeProvider>();\n\n  server.setValidatorCompiler(validatorCompiler);\n  server.setSerializerCompiler(serializerCompiler);\n\n  await server.register(cors);\n  await server.register(dbPlugin);\n  await server.register(tenantContextPlugin);\n  await server.register(healthRoutes);\n  await server.register(metadataRoutes, { prefix: '/api/v1' });\n\n  return server;\n}"
                    },
                    {
                        "path": "project/apps/api/src/routes/health.ts",
                        "content": "import { FastifyInstance } from 'fastify';\n\n/**\n * Registers a health check route.\n * @param fastify The Fastify instance.\n */\nexport default async function (fastify: FastifyInstance) {\n  fastify.get('/health', async (_request, reply) => {\n    // In a real application, you might also check database connectivity here.\n    // For now, just returning a 200 OK is sufficient.\n    return reply.code(200).send({ status: 'ok' });\n  });\n}"
                    },
                    {
                        "path": "project/apps/api/src/routes/metadata/schemas.ts",
                        "content": "import { z } from 'zod';\n\n// Reusable parameter schemas\nexport const entityTypeIdParamsSchema = z.object({\n  entityTypeId: z.string().uuid(),\n});\n\nexport const fieldIdParamsSchema = z.object({\n  fieldId: z.string().uuid(),\n});\n\n// Entity Type Schemas\nexport const entityTypeSchema = z.object({\n  id: z.string().uuid(),\n  key: z.string(),\n  label: z.string(),\n  description: z.string().nullable(),\n});\n\nexport const createEntityTypeBodySchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  description: z.string().nullable().optional(),\n});\n\nexport const updateEntityTypeBodySchema = z.object({\n  label: z.string().optional(),\n  description: z.string().nullable().optional(),\n});\n\n// Field Definition Schemas\nconst fieldKindEnum = z.enum([\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nexport const fieldDefSchema = z.object({\n  id: z.string().uuid(),\n  entityTypeId: z.string().uuid(),\n  key: z.string(),\n  label: z.string(),\n  kind: fieldKindEnum,\n  required: z.boolean(),\n  uniqueWithinType: z.boolean(),\n  searchable: z.boolean(),\n  indexed: z.boolean(),\n  options: z.record(z.any()),\n  validate: z.record(z.any()),\n  acl: z.record(z.any()),\n  position: z.number().int(),\n  active: z.boolean(),\n});\n\nexport const createFieldDefBodySchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  kind: fieldKindEnum,\n  required: z.boolean().optional(),\n  uniqueWithinType: z.boolean().optional(),\n  searchable: z.boolean().optional(),\n  indexed: z.boolean().optional(),\n  options: z.record(z.any()).optional(),\n  validate: z.record(z.any()).optional(),\n  acl: z.record(z.any()).optional(),\n  position: z.number().int().optional(),\n});\n\nexport const updateFieldDefBodySchema = z.object({\n  label: z.string().optional(),\n  required: z.boolean().optional(),\n  uniqueWithinType: z.boolean().optional(),\n  searchable: z.boolean().optional(),\n  indexed: z.boolean().optional(),\n  options: z.record(z.any()).optional(),\n  validate: z.record(z.any()).optional(),\n  acl: z.record(z.any()).optional(),\n  position: z.number().int().optional(),\n  active: z.boolean().optional(),\n});"
                    },
                    {
                        "path": "project/apps/api/src/routes/metadata/index.ts",
                        "content": "import { FastifyPluginAsync } from 'fastify';\nimport * as dal from '../../lib/dal/metadata';\nimport {\n  createEntityTypeBodySchema,\n  entityTypeSchema,\n  updateEntityTypeBodySchema,\n  entityTypeIdParamsSchema,\n  fieldIdParamsSchema,\n  fieldDefSchema,\n  createFieldDefBodySchema,\n  updateFieldDefBodySchema,\n} from './schemas';\n\nconst metadataRoutes: FastifyPluginAsync = async (fastify) => {\n  //\n  // Entity Type Routes\n  //\n\n  fastify.get(\n    '/entity-types',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'List Entity Types',\n        response: {\n          200: entityTypeSchema.array(),\n        },\n      },\n    },\n    async (request, reply) => {\n      const entityTypes = await dal.findEntityTypesByTenant(\n        request.db,\n        request.tenantId,\n      );\n      return reply.send(entityTypes);\n    },\n  );\n\n  fastify.post(\n    '/entity-types',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Create Entity Type',\n        body: createEntityTypeBodySchema,\n        response: {\n          201: entityTypeSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const newEntityType = await dal.createEntityType(\n        request.db,\n        request.tenantId,\n        request.body,\n      );\n      return reply.code(201).send(newEntityType);\n    },\n  );\n\n  fastify.patch(\n    '/entity-types/:entityTypeId',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Update Entity Type',\n        params: entityTypeIdParamsSchema,\n        body: updateEntityTypeBodySchema,\n        response: {\n          200: entityTypeSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const existing = await dal.findEntityTypeById(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n      );\n      if (!existing) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const updatedEntityType = await dal.updateEntityType(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n        request.body,\n      );\n      return reply.send(updatedEntityType);\n    },\n  );\n\n  //\n  // Field Definition Routes\n  //\n\n  fastify.get(\n    '/entity-types/:entityTypeId/fields',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'List Field Definitions',\n        params: entityTypeIdParamsSchema,\n        response: {\n          200: fieldDefSchema.array(),\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const entityType = await dal.findEntityTypeById(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n      );\n      if (!entityType) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const fieldDefs = await dal.findFieldDefsByEntityType(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n      );\n      return reply.send(fieldDefs);\n    },\n  );\n\n  fastify.post(\n    '/entity-types/:entityTypeId/fields',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Create Field Definition',\n        params: entityTypeIdParamsSchema,\n        body: createFieldDefBodySchema,\n        response: {\n          201: fieldDefSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { entityTypeId } = request.params;\n\n      const entityType = await dal.findEntityTypeById(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n      );\n      if (!entityType) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Entity type not found' });\n      }\n\n      const newFieldDef = await dal.createFieldDef(\n        request.db,\n        request.tenantId,\n        entityTypeId,\n        request.body,\n      );\n      return reply.code(201).send(newFieldDef);\n    },\n  );\n\n  fastify.patch(\n    '/fields/:fieldId',\n    {\n      schema: {\n        tags: ['Metadata'],\n        summary: 'Update Field Definition',\n        params: fieldIdParamsSchema,\n        body: updateFieldDefBodySchema,\n        response: {\n          200: fieldDefSchema,\n        },\n      },\n    },\n    async (request, reply) => {\n      const { fieldId } = request.params;\n\n      const existing = await dal.findFieldDefById(\n        request.db,\n        request.tenantId,\n        fieldId,\n      );\n      if (!existing) {\n        return reply\n          .code(404)\n          .send({ code: 'NOT_FOUND', message: 'Field definition not found' });\n      }\n\n      const updatedFieldDef = await dal.updateFieldDef(\n        request.db,\n        request.tenantId,\n        fieldId,\n        request.body,\n      );\n      return reply.send(updatedFieldDef);\n    },\n  );\n};\n\nexport default metadataRoutes;"
                    }
                ]
            }
        ]
    },
    {
        "name": "I3.T4",
        "context": {
            "task_id": "I3.T4",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the core `Filter DSL Compiler` in `packages/core`. This initial version should support `eq`, `neq`, `gt`, `gte`, `lt`, `lte`, `in`, `contains`, `fulltext`, and logical operators `and`, `or`.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 8 of the manifest.",
            "target_files": [
                "packages/core/src/filter-compiler.ts"
            ],
            "input_files": [
                "packages/core/"
            ],
            "deliverables": "A function that compiles Filter DSL JSON into parameterized SQL WHERE clauses.",
            "acceptance_criteria": "The compiler produces safe, parameterized SQL. Unit tests cover all supported operators.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "I will now proceed with implementing the Filter DSL Compiler as per the detailed plan. This involves creating the main compiler logic, defining the necessary TypeScript types, writing comprehensive unit tests, and exporting the new module.\n\nFirst, I will create the core compiler file, `packages/core/src/filter-compiler.ts`. This file will contain the types for the DSL, the recursive `processNode` helper function, and the main `compileFilter` function.\n\n~~~typescript\n#- file: packages/core/src/filter-compiler.ts\n// 1. Type Definitions\ntype Comparator = 'eq' | 'neq' | 'lt' | 'lte' | 'gt' | 'gte';\ntype Logic = 'and' | 'or';\n\nexport type ComparisonFilter = {\n  op: Comparator;\n  field: string;\n  value: unknown;\n};\n\nexport type InFilter = {\n  op: 'in';\n  field: string;\n  values: unknown[];\n};\n\nexport type ContainsFilter = {\n  op: 'contains';\n  field: string;\n  value: string;\n};\n\nexport type FulltextFilter = {\n  op: 'fulltext';\n  query: string;\n};\n\nexport type LogicalFilter = {\n  op: Logic;\n  filters: Filter[];\n};\n\nexport type Filter =\n  | LogicalFilter\n  | ComparisonFilter\n  | InFilter\n  | ContainsFilter\n  | FulltextFilter;\n\nexport type CompiledFilter = {\n  sql: string;\n  params: any[];\n};\n\ntype ProcessedNode = {\n  sql: string;\n  params: any[];\n  nextParamIndex: number;\n};\n\nconst OPERATOR_MAP: Record<Comparator, string> = {\n  eq: '=',\n  neq: '!=',\n  gt: '>',\n  gte: '>=',\n  lt: '<',\n  lte: '<=',\n};\n\n// 3. Recursive Helper\nfunction processNode(node: Filter, paramIndex: number): ProcessedNode {\n  switch (node.op) {\n    // 4. Logical Operators\n    case 'and':\n    case 'or': {\n      if (node.filters.length === 0) {\n        return { sql: 'TRUE', params: [], nextParamIndex: paramIndex };\n      }\n\n      let currentIndex = paramIndex;\n      const childResults = node.filters.map((filter) => {\n        const result = processNode(filter, currentIndex);\n        currentIndex = result.nextParamIndex;\n        return result;\n      });\n\n      const sqlFragments = childResults.map((r) => r.sql);\n      const allParams = childResults.flatMap((r) => r.params);\n      const joiner = ` ${node.op.toUpperCase()} `;\n\n      return {\n        sql: `(${sqlFragments.join(joiner)})`,\n        params: allParams,\n        nextParamIndex: currentIndex,\n      };\n    }\n\n    // 5. Comparison Operators\n    case 'eq':\n    case 'neq':\n    case 'gt':\n    case 'gte':\n    case 'lt':\n    case 'lte': {\n      const sqlOp = OPERATOR_MAP[node.op];\n      return {\n        sql: `(data->>'${node.field}') ${sqlOp} $${paramIndex}`,\n        params: [node.value],\n        nextParamIndex: paramIndex + 1,\n      };\n    }\n\n    case 'in': {\n      return {\n        sql: `(data->>'${node.field}') = ANY($${paramIndex})`,\n        params: [node.values],\n        nextParamIndex: paramIndex + 1,\n      };\n    }\n\n    case 'contains': {\n      return {\n        sql: `(data->>'${node.field}') ILIKE $${paramIndex}`,\n        params: [`%${node.value}%`],\n        nextParamIndex: paramIndex + 1,\n      };\n    }\n\n    case 'fulltext': {\n      return {\n        sql: `fts @@ plainto_tsquery('simple', $${paramIndex})`,\n        params: [node.query],\n        nextParamIndex: paramIndex + 1,\n      };\n    }\n\n    default: {\n      const exhaustiveCheck: never = node;\n      throw new Error(`Unsupported filter operator: ${(exhaustiveCheck as any).op}`);\n    }\n  }\n}\n\n// 2. Main Compiler Function\n/**\n * Compiles a Filter DSL object into a parameterized SQL WHERE clause.\n * @param filter - The Filter DSL object.\n * @returns An object containing the SQL string and parameters array.\n */\nexport function compileFilter(filter: Filter | null | undefined): CompiledFilter {\n  if (!filter) {\n    return { sql: 'TRUE', params: [] };\n  }\n\n  const result = processNode(filter, 1);\n  return {\n    sql: result.sql,\n    params: result.params,\n  };\n}\n~~~\nNext, I will create the corresponding test file, `packages/core/src/filter-compiler.test.ts`, to ensure all operators and logical combinations are handled correctly, satisfying the acceptance criteria.\n~~~typescript\n#- file: packages/core/src/filter-compiler.test.ts\nimport { describe, it } from 'node:test';\nimport assert from 'node:assert';\nimport { compileFilter, Filter } from './filter-compiler';\n\ndescribe('compileFilter', () => {\n  it('should handle null or empty filter', () => {\n    const result = compileFilter(null);\n    assert.deepStrictEqual(result, { sql: 'TRUE', params: [] });\n  });\n\n  // Simple comparison operators\n  it('should compile an \"eq\" filter', () => {\n    const filter: Filter = { op: 'eq', field: 'status', value: 'active' };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(data->>'status') = $1`,\n      params: ['active'],\n    });\n  });\n\n  it('should compile a \"neq\" filter', () => {\n    const filter: Filter = { op: 'neq', field: 'name', value: 'John' };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(data->>'name') != $1`,\n      params: ['John'],\n    });\n  });\n\n  it('should compile a \"gt\" filter for a number', () => {\n    const filter: Filter = { op: 'gt', field: 'age', value: 30 };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(data->>'age') > $1`,\n      params: [30],\n    });\n  });\n\n  it('should compile a \"gte\" filter', () => {\n    const filter: Filter = { op: 'gte', field: 'budget', value: 1000 };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(data->>'budget') >= $1`,\n      params: [1000],\n    });\n  });\n\n  it('should compile an \"lt\" filter', () => {\n    const filter: Filter = { op: 'lt', field: 'price', value: 99.99 };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(data->>'price') < $1`,\n      params: [99.99],\n    });\n  });\n\n  it('should compile an \"lte\" filter', () => {\n    const filter: Filter = { op: 'lte', field: 'stock', value: 0 };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(data->>'stock') <= $1`,\n      params: [0],\n    });\n  });\n\n  // Special operators\n  it('should compile an \"in\" filter', () => {\n    const filter: Filter = {\n      op: 'in',\n      field: 'category',\n      values: ['A', 'B', 'C'],\n    };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(data->>'category') = ANY($1)`,\n      params: [['A', 'B', 'C']],\n    });\n  });\n\n  it('should compile a \"contains\" filter', () => {\n    const filter: Filter = { op: 'contains', field: 'title', value: 'roadmap' };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(data->>'title') ILIKE $1`,\n      params: ['%roadmap%'],\n    });\n  });\n\n  it('should compile a \"fulltext\" filter', () => {\n    const filter: Filter = { op: 'fulltext', query: 'agile development' };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `fts @@ plainto_tsquery('simple', $1)`,\n      params: ['agile development'],\n    });\n  });\n\n  // Logical operators\n  it('should compile an \"and\" filter with multiple conditions', () => {\n    const filter: Filter = {\n      op: 'and',\n      filters: [\n        { op: 'eq', field: 'status', value: 'active' },\n        { op: 'gte', field: 'budget', value: 5000 },\n      ],\n    };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `((data->>'status') = $1 AND (data->>'budget') >= $2)`,\n      params: ['active', 5000],\n    });\n  });\n\n  it('should compile an \"or\" filter with multiple conditions', () => {\n    const filter: Filter = {\n      op: 'or',\n      filters: [\n        { op: 'eq', field: 'priority', value: 'high' },\n        { op: 'gt', field: 'overdue_days', value: 10 },\n      ],\n    };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `((data->>'priority') = $1 OR (data->>'overdue_days') > $2)`,\n      params: ['high', 10],\n    });\n  });\n\n  it('should handle an empty \"and\" filter', () => {\n    const filter: Filter = { op: 'and', filters: [] };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, { sql: 'TRUE', params: [] });\n  });\n\n  // Nested logical operators\n  it('should compile a nested filter: (A AND B) OR C', () => {\n    const filter: Filter = {\n      op: 'or',\n      filters: [\n        {\n          op: 'and',\n          filters: [\n            { op: 'eq', field: 'type', value: 'A' },\n            { op: 'gt', field: 'value', value: 100 },\n          ],\n        },\n        { op: 'eq', field: 'owner', value: 'admin' },\n      ],\n    };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `(((data->>'type') = $1 AND (data->>'value') > $2) OR (data->>'owner') = $3)`,\n      params: ['A', 100, 'admin'],\n    });\n  });\n\n  it('should compile a nested filter: A AND (B OR C)', () => {\n    const filter: Filter = {\n      op: 'and',\n      filters: [\n        { op: 'eq', field: 'status', value: 'active' },\n        {\n          op: 'or',\n          filters: [\n            { op: 'eq', field: 'priority', value: 'high' },\n            { op: 'in', field: 'tags', values: ['urgent', 'critical'] },\n          ],\n        },\n      ],\n    };\n    const result = compileFilter(filter);\n    assert.deepStrictEqual(result, {\n      sql: `((data->>'status') = $1 AND ((data->>'priority') = $2 OR (data->>'tags') = ANY($3)))`,\n      params: ['active', 'high', ['urgent', 'critical']],\n    });\n  });\n\n  it('should throw an error for an unknown operator', () => {\n    const filter = { op: 'unknown', field: 'test', value: 1 } as any;\n    assert.throws(\n      () => compileFilter(filter),\n      new Error('Unsupported filter operator: unknown'),\n    );\n  });\n});\n~~~\nFinally, I will edit `packages/core/src/index.ts` to export the new compiler, making it available to other packages in the monorepo.\n~~~edits\n#- file: packages/core/src/index.ts\n***start_edit\nLITERAL\n***search\nexport * from './validation';\n***replace\nexport * from './validation';\nexport * from './filter-compiler';\n***description\nExport the newly created filter compiler module from the core package.\n***end_edit\n~~~",
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "packages/core/src/filter-compiler.ts"
        ],
        "input_files": [
            "packages/core/"
        ],
        "files": [
            {
                "path": "packages/core/",
                "content": [
                    {
                        "path": "project/packages/core/dist/index.js",
                        "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.core = void 0;\nconst core = () => 'Hello from @ddms/core';\nexports.core = core;\n//# sourceMappingURL=index.js.map"
                    },
                    {
                        "path": "project/packages/core/dist/index.js.map",
                        "content": "{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/index.ts\"],\"names\":[],\"mappings\":\";;;AAAO,MAAM,IAAI,GAAG,GAAG,EAAE,CAAC,uBAAuB,CAAC;AAArC,QAAA,IAAI,QAAiC\"}"
                    },
                    {
                        "path": "project/packages/core/dist/index.d.ts",
                        "content": "export declare const core: () => string;\n"
                    },
                    {
                        "path": "project/packages/core/tsconfig.tsbuildinfo",
                        "content": "{\"fileNames\":[\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es5.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.iterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.dom.asynciterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.webworker.importscripts.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.scripthost.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.core.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.collection.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.generator.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.iterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.proxy.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.reflect.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.symbol.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.array.include.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2016.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.date.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2018.regexp.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.array.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.symbol.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2019.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.bigint.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.date.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2020.number.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.promise.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.weakref.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2021.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.array.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.error.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.intl.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.object.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.string.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.regexp.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.decorators.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.decorators.legacy.d.ts\",\"../../node_modules/.pnpm/typescript@5.9.3/node_modules/typescript/lib/lib.es2022.full.d.ts\",\"./src/index.ts\"],\"fileInfos\":[{\"version\":\"c430d44666289dae81f30fa7b2edebf186ecc91a2d4c71266ea6ae76388792e1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4\",\"impliedFormat\":1},{\"version\":\"3facaf05f0c5fc569c5649dd359892c98a85557e3e0c847964caeb67076f4d75\",\"impliedFormat\":1},{\"version\":\"e44bb8bbac7f10ecc786703fe0a6a4b952189f908707980ba8f3c8975a760962\",\"impliedFormat\":1},{\"version\":\"5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8\",\"impliedFormat\":1},{\"version\":\"68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7\",\"impliedFormat\":1},{\"version\":\"5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4\",\"impliedFormat\":1},{\"version\":\"feecb1be483ed332fad555aff858affd90a48ab19ba7272ee084704eb7167569\",\"impliedFormat\":1},{\"version\":\"ee7bad0c15b58988daa84371e0b89d313b762ab83cb5b31b8a2d1162e8eb41c2\",\"impliedFormat\":1},{\"version\":\"080941d9f9ff9307f7e27a83bcd888b7c8270716c39af943532438932ec1d0b9\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"2e80ee7a49e8ac312cc11b77f1475804bee36b3b2bc896bead8b6e1266befb43\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d7a3c8b952931daebdfc7a2897c53c0a1c73624593fa070e46bd537e64dcd20a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"80e18897e5884b6723488d4f5652167e7bb5024f946743134ecc4aa4ee731f89\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"cd034f499c6cdca722b60c04b5b1b78e058487a7085a8e0d6fb50809947ee573\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"c57796738e7f83dbc4b8e65132f11a377649c00dd3eee333f672b8f0a6bea671\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"dc2df20b1bcdc8c2d34af4926e2c3ab15ffe1160a63e58b7e09833f616efff44\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"515d0b7b9bea2e31ea4ec968e9edd2c39d3eebf4a2d5cbd04e88639819ae3b71\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0559b1f683ac7505ae451f9a96ce4c3c92bdc71411651ca6ddb0e88baaaad6a3\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0dc1e7ceda9b8b9b455c3a2d67b0412feab00bd2f66656cd8850e8831b08b537\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"4ff2a353abf8a80ee399af572debb8faab2d33ad38c4b4474cff7f26e7653b8d\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"fb0f136d372979348d59b3f5020b4cdb81b5504192b1cacff5d1fbba29378aa1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d15bea3d62cbbdb9797079416b8ac375ae99162a7fba5de2c6c505446486ac0a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"68d18b664c9d32a7336a70235958b8997ebc1c3b8505f4f1ae2b7e7753b87618\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"eb3d66c8327153d8fa7dd03f9c58d351107fe824c79e9b56b462935176cdf12a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"69ab18c3b76cd9b1be3d188eaf8bba06112ebbe2f47f6c322b5105a6fbc45a2e\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"a680117f487a4d2f30ea46f1b4b7f58bef1480456e18ba53ee85c2746eeca012\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"4de680d5bb41c17f7f68e0419412ca23c98d5749dcaaea1896172f06435891fc\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"954296b30da6d508a104a3a0b5d96b76495c709785c1d11610908e63481ee667\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"ac9538681b19688c8eae65811b329d3744af679e0bdfa5d842d0e32524c73e1c\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0a969edff4bd52585473d24995c5ef223f6652d6ef46193309b3921d65dd4376\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"9e9fbd7030c440b33d021da145d3232984c8bb7916f277e8ffd3dc2e3eae2bdb\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"811ec78f7fefcabbda4bfa93b3eb67d9ae166ef95f9bff989d964061cbf81a0c\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"717937616a17072082152a2ef351cb51f98802fb4b2fdabd32399843875974ca\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d7e7d9b7b50e5f22c915b525acc5a49a7a6584cf8f62d0569e557c5cfc4b2ac2\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"71c37f4c9543f31dfced6c7840e068c5a5aacb7b89111a4364b1d5276b852557\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"74f7fa2d027d5b33eb0471c8e82a6c87216223181ec31247c357a3e8e2fddc5b\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"d6d7ae4d1f1f3772e2a3cde568ed08991a8ae34a080ff1151af28b7f798e22ca\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"063600664504610fe3e99b717a1223f8b1900087fab0b4cad1496a114744f8df\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"934019d7e3c81950f9a8426d093458b65d5aff2c7c1511233c0fd5b941e608ab\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"52ada8e0b6e0482b728070b7639ee42e83a9b1c22d205992756fe020fd9f4a47\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3bdefe1bfd4d6dee0e26f928f93ccc128f1b64d5d501ff4a8cf3c6371200e5e6\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"59fb2c069260b4ba00b5643b907ef5d5341b167e7d1dbf58dfd895658bda2867\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"639e512c0dfc3fad96a84caad71b8834d66329a1f28dc95e3946c9b58176c73a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"af3dd424cf267428f30ccfc376f47a2c0114546b55c44d8c0f1d57d841e28d74\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"995c005ab91a498455ea8dfb63aa9f83fa2ea793c3d8aa344be4a1678d06d399\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"959d36cddf5e7d572a65045b876f2956c973a586da58e5d26cde519184fd9b8a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"965f36eae237dd74e6cca203a43e9ca801ce38824ead814728a2807b1910117d\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3925a6c820dcb1a06506c90b1577db1fdbf7705d65b62b99dce4be75c637e26b\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"0a3d63ef2b853447ec4f749d3f368ce642264246e02911fcb1590d8c161b8005\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8cdf8847677ac7d20486e54dd3fcf09eda95812ac8ace44b4418da1bbbab6eb8\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8444af78980e3b20b49324f4a16ba35024fef3ee069a0eb67616ea6ca821c47a\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3287d9d085fbd618c3971944b65b4be57859f5415f495b33a6adc994edd2f004\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"b4b67b1a91182421f5df999988c690f14d813b9850b40acd06ed44691f6727ad\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"8e7f8264d0fb4c5339605a15daadb037bf238c10b654bb3eee14208f860a32ea\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538\",\"affectsGlobalScope\":true,\"impliedFormat\":1},{\"version\":\"3cbad9a1ba4453443026ed38e4b8be018abb26565fa7c944376463ad9df07c41\",\"impliedFormat\":1},{\"version\":\"3ed321a1f1fcaeb1c05cc9f6d90e149bad7642cfa73facb323a347198e7b6e62\",\"signature\":\"252314f963f733f961076c222dbe6ce80a2062a15c5b8bf5e48f06f5247856f4\",\"impliedFormat\":1}],\"root\":[64],\"options\":{\"composite\":true,\"declaration\":true,\"esModuleInterop\":true,\"module\":199,\"outDir\":\"./dist\",\"rootDir\":\"./src\",\"skipLibCheck\":true,\"sourceMap\":true,\"strict\":true,\"target\":9},\"latestChangedDtsFile\":\"./dist/index.d.ts\",\"version\":\"5.9.3\"}"
                    },
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"tsx --test src/**/*.test.ts\"\n  },\n  \"dependencies\": {\n    \"@ddms/db\": \"workspace:*\",\n    \"drizzle-orm\": \"^0.32.1\",\n    \"zod\": \"^3.23.8\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.14.2\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\",\n    \"types\": [\n      \"node\"\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/core/src/validation.ts",
                        "content": "import { z, ZodTypeAny, AnyZodObject } from 'zod';\nimport { fieldDefs } from '@ddms/db/schema';\nimport { InferSelectModel } from 'drizzle-orm';\n\n// Drizzle's InferSelectModel gives us the type of a selected row.\nexport type FieldDef = InferSelectModel<typeof fieldDefs>;\n\n// Schemas for the `validate` JSONB column, nested by field kind as per manifest\nconst textValidationSchema = z\n  .object({\n    minLen: z.number().optional(),\n    maxLen: z.number().optional(),\n    regex: z.string().optional(),\n  })\n  .optional();\n\nconst numberValidationSchema = z\n  .object({\n    min: z.number().optional(),\n    max: z.number().optional(),\n    integer: z.boolean().optional(),\n  })\n  .optional();\n\nconst dateValidationSchema = z\n  .object({\n    min: z.string().optional(),\n    max: z.string().optional(),\n  })\n  .optional();\n\n// Schemas for the `options` JSONB column\nconst selectOptionsSchema = z\n  .object({\n    enum: z.array(z.string()).min(1),\n    multiselect: z.boolean().optional(),\n  })\n  .optional();\n\nconst relationOptionsSchema = z\n  .object({\n    relation: z.object({\n      target_entity_type_id: z.string().uuid(),\n      cardinality: z.enum(['one', 'many']).optional(),\n    }),\n  })\n  .optional();\n\n/**\n * Builds a Zod schema from a single field definition.\n * @param field - The field definition from the database.\n * @returns A Zod type for the given field.\n */\nfunction buildZodTypeFromFieldDef(field: FieldDef): ZodTypeAny {\n  let zodType: ZodTypeAny;\n\n  switch (field.kind) {\n    case 'text': {\n      let type = z.string();\n      const validationRules = z\n        .object({ text: textValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.text;\n\n      if (validate?.minLen !== undefined) {\n        type = type.min(validate.minLen);\n      }\n      if (validate?.maxLen !== undefined) {\n        type = type.max(validate.maxLen);\n      }\n      if (validate?.regex) {\n        type = type.regex(new RegExp(validate.regex));\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'number': {\n      let type = z.number();\n      const validationRules = z\n        .object({ number: numberValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.number;\n\n      if (validate?.min !== undefined) {\n        type = type.min(validate.min);\n      }\n      if (validate?.max !== undefined) {\n        type = type.max(validate.max);\n      }\n      if (validate?.integer) {\n        type = type.int();\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'date': {\n      let type = z\n        .string()\n        .datetime({ message: 'Invalid ISO 8601 date format' });\n      const validationRules = z\n        .object({ date: dateValidationSchema })\n        .optional()\n        .parse(field.validate ?? {});\n      const validate = validationRules?.date;\n\n      if (validate?.min) {\n        type = type.refine((val) => new Date(val) >= new Date(validate!.min!), {\n          message: `Date must be on or after ${validate.min}`,\n        });\n      }\n      if (validate?.max) {\n        type = type.refine((val) => new Date(val) <= new Date(validate!.max!), {\n          message: `Date must be on or before ${validate.max}`,\n        });\n      }\n      zodType = type;\n      break;\n    }\n\n    case 'boolean': {\n      zodType = z.boolean();\n      break;\n    }\n\n    case 'select': {\n      const options = selectOptionsSchema.parse(field.options ?? {});\n      if (!options?.enum) {\n        throw new Error(\n          `'select' field '${field.key}' is missing enum options.`,\n        );\n      }\n      const enumType = z.enum(options.enum as [string, ...string[]]);\n      if (options.multiselect) {\n        zodType = z.array(enumType);\n      } else {\n        zodType = enumType;\n      }\n      break;\n    }\n\n    case 'relation': {\n      const options = relationOptionsSchema.parse(field.options ?? {});\n      const relationOptions = options?.relation;\n      if (!relationOptions?.target_entity_type_id) {\n        throw new Error(\n          `'relation' field '${field.key}' is missing target_entity_type_id.`,\n        );\n      }\n      const uuidType = z.string().uuid();\n      if (relationOptions.cardinality === 'many') {\n        zodType = z.array(uuidType);\n      } else {\n        zodType = uuidType;\n      }\n      break;\n    }\n\n    default: {\n      const exhaustiveCheck: never = field.kind;\n      throw new Error(`Unsupported field kind: ${exhaustiveCheck}`);\n    }\n  }\n\n  if (!field.required) {\n    return zodType.optional().nullable();\n  }\n\n  return zodType;\n}\n\n/**\n * The internal schema builder without memoization.\n * @param fields - An array of field definitions.\n * @returns A Zod object schema.\n */\nfunction buildSchemaFromFieldDefs(fields: FieldDef[]): AnyZodObject {\n  const shape: Record<string, ZodTypeAny> = {};\n\n  for (const field of fields) {\n    shape[field.key] = buildZodTypeFromFieldDef(field);\n  }\n\n  return z.object(shape);\n}\n\n// Memoization cache\nconst schemaCache = new Map<string, AnyZodObject>();\n\n/**\n * Gets a Zod validation schema for a given set of field definitions.\n * The result is memoized based on the cacheKey.\n *\n * @param cacheKey - A unique key to identify this set of field definitions (e.g., entityTypeId).\n * @param fields - An array of field definitions.\n * @returns A memoized Zod object schema.\n */\nexport function getValidationSchema(\n  cacheKey: string,\n  fields: FieldDef[],\n): AnyZodObject {\n  if (schemaCache.has(cacheKey)) {\n    return schemaCache.get(cacheKey)!;\n  }\n\n  const newSchema = buildSchemaFromFieldDefs(fields);\n  schemaCache.set(cacheKey, newSchema);\n\n  return newSchema;\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export * from './validation';"
                    },
                    {
                        "path": "project/packages/core/src/validation.test.ts",
                        "content": "import { describe, it } from 'node:test';\nimport assert from 'node:assert';\nimport { getValidationSchema, FieldDef } from './validation';\nimport { ZodError } from 'zod';\n\nconst baseFieldDef: Omit<FieldDef, 'key' | 'kind'> = {\n  id: 'uuid-id',\n  tenantId: 'uuid-tenant',\n  entityTypeId: 'uuid-entity-type',\n  label: 'Test Field',\n  required: false,\n  uniqueWithinType: false,\n  searchable: true,\n  indexed: false,\n  options: {},\n  validate: {},\n  acl: {},\n  position: 0,\n  active: true,\n};\n\ndescribe('getValidationSchema', () => {\n  it('should handle required and optional text fields', () => {\n    const fields: FieldDef[] = [\n      { ...baseFieldDef, key: 'name', kind: 'text', required: true },\n      { ...baseFieldDef, key: 'description', kind: 'text', required: false },\n    ];\n    const schema = getValidationSchema('text-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ name: 'test' }));\n    assert.throws(() => schema.parse({}), ZodError);\n    assert.doesNotThrow(() => schema.parse({ name: 'test', description: null }));\n    assert.doesNotThrow(() =>\n      schema.parse({ name: 'test', description: 'desc' }),\n    );\n  });\n\n  it('should handle text validation rules (minLen, maxLen, regex)', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'code',\n        kind: 'text',\n        required: true,\n        validate: { text: { minLen: 3, maxLen: 5, regex: '^[A-Z]+$' } },\n      },\n    ];\n    const schema = getValidationSchema('text-validation-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ code: 'ABCDE' }));\n    assert.throws(\n      () => schema.parse({ code: 'AB' }),\n      ZodError,\n      'minLen failed',\n    );\n    assert.throws(\n      () => schema.parse({ code: 'ABCDEF' }),\n      ZodError,\n      'maxLen failed',\n    );\n    assert.throws(\n      () => schema.parse({ code: 'abc' }),\n      ZodError,\n      'regex failed',\n    );\n  });\n\n  it('should handle number validation rules (min, max, integer)', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'amount',\n        kind: 'number',\n        required: true,\n        validate: { number: { min: 0, max: 100, integer: true } },\n      },\n    ];\n    const schema = getValidationSchema('number-validation-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ amount: 50 }));\n    assert.throws(\n      () => schema.parse({ amount: -1 }),\n      ZodError,\n      'min failed',\n    );\n    assert.throws(\n      () => schema.parse({ amount: 101 }),\n      ZodError,\n      'max failed',\n    );\n    assert.throws(\n      () => schema.parse({ amount: 50.5 }),\n      ZodError,\n      'integer failed',\n    );\n  });\n\n  it('should handle date validation', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'eventDate',\n        kind: 'date',\n        required: true,\n      },\n    ];\n    const schema = getValidationSchema('date-validation-test', fields);\n\n    assert.doesNotThrow(() =>\n      schema.parse({ eventDate: new Date().toISOString() }),\n    );\n    assert.throws(() => schema.parse({ eventDate: 'not a date' }), ZodError);\n  });\n\n  it('should handle boolean fields', () => {\n    const fields: FieldDef[] = [\n      { ...baseFieldDef, key: 'isActive', kind: 'boolean', required: true },\n    ];\n    const schema = getValidationSchema('boolean-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ isActive: true }));\n    assert.throws(() => schema.parse({ isActive: 'true' }), ZodError);\n    assert.throws(() => schema.parse({}), ZodError);\n  });\n\n  it('should handle single-select fields', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'status',\n        kind: 'select',\n        required: true,\n        options: { enum: ['open', 'closed'] },\n      },\n    ];\n    const schema = getValidationSchema('select-single-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ status: 'open' }));\n    assert.throws(() => schema.parse({ status: 'pending' }), ZodError);\n  });\n\n  it('should handle multi-select fields', () => {\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'tags',\n        kind: 'select',\n        required: false,\n        options: { enum: ['a', 'b', 'c'], multiselect: true },\n      },\n    ];\n    const schema = getValidationSchema('select-multi-test', fields);\n\n    assert.doesNotThrow(() => schema.parse({ tags: ['a', 'c'] }));\n    assert.throws(() => schema.parse({ tags: ['a', 'd'] }), ZodError);\n    assert.doesNotThrow(() => schema.parse({}));\n  });\n\n  it('should handle relation fields (one and many)', () => {\n    const userEntityTypeId = 'a1b2c3d4-e5f6-7890-1234-567890abcdef';\n    const projectEntityTypeId = 'f0e9d8c7-b6a5-4321-fedc-ba9876543210';\n    const fields: FieldDef[] = [\n      {\n        ...baseFieldDef,\n        key: 'ownerId',\n        kind: 'relation',\n        required: true,\n        options: { relation: { target_entity_type_id: userEntityTypeId } }, // cardinality 'one' is default\n      },\n      {\n        ...baseFieldDef,\n        key: 'projectIds',\n        kind: 'relation',\n        required: false,\n        options: {\n          relation: {\n            target_entity_type_id: projectEntityTypeId,\n            cardinality: 'many',\n          },\n        },\n      },\n    ];\n    const schema = getValidationSchema('relation-test', fields);\n    const validUUID = '123e4567-e89b-12d3-a456-426614174000';\n\n    assert.doesNotThrow(() => schema.parse({ ownerId: validUUID }));\n    assert.throws(() => schema.parse({ ownerId: 'not-a-uuid' }), ZodError);\n    assert.doesNotThrow(() =>\n      schema.parse({ ownerId: validUUID, projectIds: [validUUID] }),\n    );\n    assert.throws(\n      () => schema.parse({ ownerId: validUUID, projectIds: ['not-a-uuid'] }),\n      ZodError,\n    );\n  });\n\n  it('should use memoized schema on subsequent calls', () => {\n    const fields: FieldDef[] = [\n      { ...baseFieldDef, key: 'name', kind: 'text', required: true },\n    ];\n    const schema1 = getValidationSchema('memo-test', fields);\n    const schema2 = getValidationSchema('memo-test', fields);\n\n    assert.strictEqual(schema1, schema2);\n  });\n});"
                    }
                ]
            }
        ]
    },
    {
        "name": "I3.T5",
        "context": {
            "task_id": "I3.T5",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the API routes and handlers for record CRUD and search, integrating the Validation Engine (`I3.T2`) for writes and the Filter Compiler (`I3.T4`) for search.",
            "agent_type_hint": "BackendAgent",
            "inputs": "OpenAPI spec (`I3.T1`), Validation Engine (`I3.T2`), Record DAL (`I3.T3`), Filter Compiler (`I3.T4`).",
            "target_files": [
                "apps/api/src/routes/entities/"
            ],
            "input_files": [
                "api/openapi.yaml",
                "packages/core/",
                "apps/api/src/lib/dal/records.ts"
            ],
            "deliverables": "Implemented API routes for records.",
            "acceptance_criteria": "Endpoints behave as specified. Validation errors are returned in the correct format. Search returns filtered results.",
            "dependencies": [
                "I3.T1",
                "I3.T2",
                "I3.T3",
                "I3.T4"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "apps/api/src/routes/entities/"
        ],
        "input_files": [
            "api/openapi.yaml",
            "packages/core/",
            "apps/api/src/lib/dal/records.ts"
        ],
        "files": []
    },
    {
        "name": "I3.T6",
        "context": {
            "task_id": "I3.T6",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the database triggers for FTS refresh (`records_fts_refresh`) and versioning (`records_versioning`) as new migration files.",
            "agent_type_hint": "DatabaseAgent",
            "inputs": "Section 6.6 of the manifest.",
            "target_files": [
                "packages/db/migrations/0002_record_triggers.sql"
            ],
            "input_files": [
                "packages/db/migrations/"
            ],
            "deliverables": "A new SQL migration file.",
            "acceptance_criteria": "The migration applies successfully. Updating a record correctly populates the `fts` column and creates an entry in `record_versions`.",
            "dependencies": [
                "I1.T3"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "packages/db/migrations/0002_record_triggers.sql"
        ],
        "input_files": [
            "packages/db/migrations/"
        ],
        "files": []
    },
    {
        "name": "I4.T1",
        "context": {
            "task_id": "I4.T1",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Scaffold the Next.js application in `apps/web` using TypeScript. Set up basic project structure, including components, pages, and styles.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Section 15 of the manifest.",
            "target_files": [
                "apps/web/src/",
                "apps/web/package.json",
                "apps/web/next.config.js"
            ],
            "input_files": [
                "apps/web/"
            ],
            "deliverables": "A runnable Next.js application.",
            "acceptance_criteria": "The default Next.js page loads successfully in a browser.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "apps/web/src/",
            "apps/web/package.json",
            "apps/web/next.config.js"
        ],
        "input_files": [
            "apps/web/"
        ],
        "files": []
    },
    {
        "name": "I4.T2",
        "context": {
            "task_id": "I4.T2",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Generate a typed API client using a tool like `openapi-typescript` and place it in the `packages/sdk` directory. Configure the frontend to use this SDK for all API calls.",
            "agent_type_hint": "SetupAgent",
            "inputs": "The OpenAPI spec from `I3.T1`.",
            "target_files": [
                "packages/sdk/src/index.ts"
            ],
            "input_files": [
                "api/openapi.yaml"
            ],
            "deliverables": "A TypeScript SDK package.",
            "acceptance_criteria": "The SDK is generated successfully and provides typed methods for all defined API endpoints.",
            "dependencies": [
                "I3.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "packages/sdk/src/index.ts"
        ],
        "input_files": [
            "api/openapi.yaml"
        ],
        "files": []
    },
    {
        "name": "I4.T3",
        "context": {
            "task_id": "I4.T3",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Integrate TanStack Query (React Query) into the Next.js app for server state management. Configure a global query client provider.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Next.js app from `I4.T1`.",
            "target_files": [
                "apps/web/src/lib/query-client.ts",
                "apps/web/src/pages/_app.tsx"
            ],
            "input_files": [
                "apps/web/src/pages/_app.tsx"
            ],
            "deliverables": "React Query setup.",
            "acceptance_criteria": "The `QueryClientProvider` is correctly configured at the root of the application.",
            "dependencies": [
                "I4.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "apps/web/src/lib/query-client.ts",
            "apps/web/src/pages/_app.tsx"
        ],
        "input_files": [
            "apps/web/src/pages/_app.tsx"
        ],
        "files": []
    },
    {
        "name": "I4.T4",
        "context": {
            "task_id": "I4.T4",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Create the UI pages and components for listing, creating, and editing `Entity Types`. Use the generated SDK and React Query for data fetching and mutations.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "SDK from `I4.T2`.",
            "target_files": [
                "apps/web/src/pages/admin/entity-types/",
                "apps/web/src/components/entity-types/"
            ],
            "input_files": [
                "packages/sdk/",
                "apps/web/src/"
            ],
            "deliverables": "React components and pages for Entity Type management.",
            "acceptance_criteria": "Users can view a list of entity types, create a new one, and edit an existing one's label/description.",
            "dependencies": [
                "I4.T2",
                "I4.T3"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "apps/web/src/pages/admin/entity-types/",
            "apps/web/src/components/entity-types/"
        ],
        "input_files": [
            "packages/sdk/",
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I4.T5",
        "context": {
            "task_id": "I4.T5",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Create the UI pages and components for managing `Field Definitions` for a specific entity type.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "SDK from `I4.T2`.",
            "target_files": [
                "apps/web/src/pages/admin/entity-types/[id].tsx",
                "apps/web/src/components/field-defs/"
            ],
            "input_files": [
                "packages/sdk/",
                "apps/web/src/"
            ],
            "deliverables": "React components and pages for Field Definition management.",
            "acceptance_criteria": "Users can view, add, and edit fields for a selected entity type. The form should handle all `kind` options and validation rules.",
            "dependencies": [
                "I4.T4"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "apps/web/src/pages/admin/entity-types/[id].tsx",
            "apps/web/src/components/field-defs/"
        ],
        "input_files": [
            "packages/sdk/",
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I5.T1",
        "context": {
            "task_id": "I5.T1",
            "iteration_id": "I5",
            "iteration_goal": "Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.",
            "description": "Implement a dynamic table component using TanStack Table. The component should accept an `entityTypeKey`, fetch its `field_defs`, and render columns dynamically. It should also fetch data from the `/search` endpoint.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Section 15.2 of the manifest.",
            "target_files": [
                "apps/web/src/components/dynamic-table/",
                "apps/web/src/pages/entities/[entityTypeKey]/index.tsx"
            ],
            "input_files": [
                "apps/web/src/"
            ],
            "deliverables": "A reusable dynamic table component and a page to display it.",
            "acceptance_criteria": "The table correctly displays columns and data for a given entity type. Basic server-side pagination works.",
            "dependencies": [
                "I4.T5"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "apps/web/src/components/dynamic-table/",
            "apps/web/src/pages/entities/[entityTypeKey]/index.tsx"
        ],
        "input_files": [
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I5.T2",
        "context": {
            "task_id": "I5.T2",
            "iteration_id": "I5",
            "iteration_goal": "Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.",
            "description": "Implement a filter builder UI that allows users to construct a Filter DSL JSON object. This UI should be connected to the dynamic table to trigger searches.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Section 15.2 of the manifest.",
            "target_files": [
                "apps/web/src/components/filter-builder/"
            ],
            "input_files": [
                "apps/web/src/components/dynamic-table/"
            ],
            "deliverables": "A filter builder component.",
            "acceptance_criteria": "The component generates a valid Filter DSL object based on user input and refetches table data when the filter is applied.",
            "dependencies": [
                "I5.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "apps/web/src/components/filter-builder/"
        ],
        "input_files": [
            "apps/web/src/components/dynamic-table/"
        ],
        "files": []
    },
    {
        "name": "I5.T3",
        "context": {
            "task_id": "I5.T3",
            "iteration_id": "I5",
            "iteration_goal": "Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.",
            "description": "Implement a dynamic form component using TanStack Form. The component should fetch `field_defs` and render the appropriate input fields (text, number, select, etc.) with client-side validation.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Section 15.3 of the manifest.",
            "target_files": [
                "apps/web/src/components/dynamic-form/"
            ],
            "input_files": [
                "apps/web/src/"
            ],
            "deliverables": "A reusable dynamic form component.",
            "acceptance_criteria": "The form renders correctly for different field kinds. Client-side validation provides immediate feedback.",
            "dependencies": [
                "I4.T5"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "apps/web/src/components/dynamic-form/"
        ],
        "input_files": [
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I5.T4",
        "context": {
            "task_id": "I5.T4",
            "iteration_id": "I5",
            "iteration_goal": "Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.",
            "description": "Create pages for creating and editing records, integrating the dynamic form component. On submission, it should call the appropriate API endpoints.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Dynamic form from `I5.T3`.",
            "target_files": [
                "apps/web/src/pages/entities/[entityTypeKey]/new.tsx",
                "apps/web/src/pages/entities/[entityTypeKey]/[recordId].tsx"
            ],
            "input_files": [
                "apps/web/src/components/dynamic-form/"
            ],
            "deliverables": "Pages for creating and editing records.",
            "acceptance_criteria": "Users can successfully create and update records. Server-side validation errors are displayed correctly on the form.",
            "dependencies": [
                "I5.T3"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "apps/web/src/pages/entities/[entityTypeKey]/new.tsx",
            "apps/web/src/pages/entities/[entityTypeKey]/[recordId].tsx"
        ],
        "input_files": [
            "apps/web/src/components/dynamic-form/"
        ],
        "files": []
    },
    {
        "name": "I6.T1",
        "context": {
            "task_id": "I6.T1",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Update `api/openapi.yaml` to include endpoints for creating and deleting relations (`/relations`).",
            "agent_type_hint": "DocumentationAgent",
            "inputs": "Section 9.3 of the manifest.",
            "target_files": [
                "api/openapi.yaml"
            ],
            "input_files": [
                "api/openapi.yaml"
            ],
            "deliverables": "Updated OpenAPI YAML file.",
            "acceptance_criteria": "The spec is valid and includes the new relation management endpoints.",
            "dependencies": [
                "I3.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "api/openapi.yaml"
        ],
        "input_files": [
            "api/openapi.yaml"
        ],
        "files": []
    },
    {
        "name": "I6.T2",
        "context": {
            "task_id": "I6.T2",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Implement the backend logic and API endpoints for creating and deleting `edges` (relations).",
            "agent_type_hint": "BackendAgent",
            "inputs": "OpenAPI spec from `I6.T1`.",
            "target_files": [
                "apps/api/src/routes/relations/",
                "apps/api/src/lib/dal/edges.ts"
            ],
            "input_files": [
                "api/openapi.yaml",
                "apps/api/src/"
            ],
            "deliverables": "Implemented API routes for relations.",
            "acceptance_criteria": "Users can create and delete relationships between records. The `edges_validate` trigger prevents invalid relations.",
            "dependencies": [
                "I6.T1",
                "I2.T5"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "apps/api/src/routes/relations/",
            "apps/api/src/lib/dal/edges.ts"
        ],
        "input_files": [
            "api/openapi.yaml",
            "apps/api/src/"
        ],
        "files": []
    },
    {
        "name": "I6.T3",
        "context": {
            "task_id": "I6.T3",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Implement the `SSE Broadcaster` on the backend, which listens to Postgres `NOTIFY` events and forwards them to clients connected to a `GET /events` endpoint. Add `NOTIFY` calls to the database triggers.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 9.5 and 24.4 of the manifest.",
            "target_files": [
                "apps/api/src/routes/events.ts",
                "packages/db/migrations/0003_notify_triggers.sql"
            ],
            "input_files": [
                "apps/api/src/",
                "packages/db/migrations/"
            ],
            "deliverables": "SSE endpoint and updated DB triggers.",
            "acceptance_criteria": "Changes to records or edges emit a notification that is broadcast to connected SSE clients.",
            "dependencies": [
                "I3.T6"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "apps/api/src/routes/events.ts",
            "packages/db/migrations/0003_notify_triggers.sql"
        ],
        "input_files": [
            "apps/api/src/",
            "packages/db/migrations/"
        ],
        "files": []
    },
    {
        "name": "I6.T4",
        "context": {
            "task_id": "I6.T4",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Integrate an SSE client into the frontend. On receiving events, invalidate the relevant React Query caches to trigger automatic data refetching and UI updates.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "SSE endpoint from `I6.T3`.",
            "target_files": [
                "apps/web/src/hooks/use-sse.ts",
                "apps/web/src/pages/_app.tsx"
            ],
            "input_files": [
                "apps/web/src/"
            ],
            "deliverables": "Real-time UI updates.",
            "acceptance_criteria": "When a record is updated in one browser tab, the change is reflected in the data table in another tab without a manual refresh.",
            "dependencies": [
                "I6.T3",
                "I5.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "apps/web/src/hooks/use-sse.ts",
            "apps/web/src/pages/_app.tsx"
        ],
        "input_files": [
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I6.T5",
        "context": {
            "task_id": "I6.T5",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Implement the authorization layer in the backend. This includes a middleware to parse JWTs and an authorization service that enforces RBAC and per-field ACLs on all relevant endpoints.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 10 of the manifest.",
            "target_files": [
                "apps/api/src/plugins/auth.ts",
                "apps/api/src/lib/authz.ts"
            ],
            "input_files": [
                "apps/api/src/"
            ],
            "deliverables": "A comprehensive authorization system.",
            "acceptance_criteria": "API requests fail with 401/403 errors for users with insufficient permissions. Data returned from read endpoints is stripped of fields the user cannot see.",
            "dependencies": [
                "I3.T5"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "apps/api/src/plugins/auth.ts",
            "apps/api/src/lib/authz.ts"
        ],
        "input_files": [
            "apps/api/src/"
        ],
        "files": []
    }
]