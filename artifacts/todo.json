[
    {
        "name": "I1.T1",
        "context": {
            "task_id": "I1.T1",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Initialize the pnpm monorepo workspace with the directory structure defined in Section 3. Set up base TypeScript configurations (`tsconfig.base.json`).",
            "agent_type_hint": "SetupAgent",
            "inputs": "Section 3 (Directory Structure)",
            "target_files": [
                "package.json",
                "pnpm-workspace.yaml",
                "tsconfig.base.json",
                "apps/",
                "packages/"
            ],
            "input_files": [],
            "deliverables": "An initialized monorepo with placeholder `package.json` files in each app/package.",
            "acceptance_criteria": "The directory structure matches the plan. `pnpm install` runs successfully at the root.",
            "dependencies": [],
            "parallelizable": false
        },
        "output": "~~~json\n#- file: package.json\n{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\"\n  }\n}\n~~~\n~~~yaml\n#- file: pnpm-workspace.yaml\npackages:\n  - 'apps/*'\n  - 'packages/*'\n~~~\n~~~json\n#- file: tsconfig.base.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n~~~\n~~~json\n#- file: apps/api/package.json\n{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true\n}\n~~~\n~~~json\n#- file: apps/web/package.json\n{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true\n}\n~~~\n~~~json\n#- file: packages/core/package.json\n{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\"\n}\n~~~\n~~~json\n#- file: packages/db/package.json\n{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\"\n}\n~~~\n~~~json\n#- file: packages/sdk/package.json\n{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\"\n}\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "package.json",
            "pnpm-workspace.yaml",
            "tsconfig.base.json",
            "apps/",
            "packages/"
        ],
        "input_files": [],
        "files": [
            {
                "path": "pnpm-workspace.yaml",
                "content": "packages:\n  - 'apps/*'\n  - 'packages/*'"
            },
            {
                "path": "packages/",
                "content": [
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\"\n}"
                    },
                    {
                        "path": "project/packages/sdk/package.json",
                        "content": "{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\"\n}"
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\"\n}"
                    }
                ]
            },
            {
                "path": "tsconfig.base.json",
                "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\"\n  }\n}"
            },
            {
                "path": "apps/",
                "content": [
                    {
                        "path": "project/apps/web/package.json",
                        "content": "{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true\n}"
                    },
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true\n}"
                    }
                ]
            },
            {
                "path": "pnpm-workspace.yaml",
                "content": "packages:\n  - 'apps/*'\n  - 'packages/*'"
            },
            {
                "path": "packages/",
                "content": [
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export const core = () => 'Hello from @ddms/core';"
                    },
                    {
                        "path": "project/packages/sdk/package.json",
                        "content": "{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/sdk/src/index.ts",
                        "content": "export const sdk = () => 'Hello from @ddms/sdk';"
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export const db = () => 'Hello from @ddms/db';"
                    }
                ]
            },
            {
                "path": "tsconfig.base.json",
                "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"format\": \"prettier --write \\\"**/*.{ts,tsx,md}\\\"\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^7.10.0\",\n    \"@typescript-eslint/parser\": \"^7.10.0\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"prettier\": \"^3.3.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}"
            },
            {
                "path": "apps/",
                "content": [
                    {
                        "path": "project/apps/web/package.json",
                        "content": "{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts,.tsx\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/web/src/index.ts",
                        "content": "// Placeholder for web app entry point"
                    },
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "console.log('Hello from @ddms/api');"
                    }
                ]
            },
            {
                "path": "pnpm-workspace.yaml",
                "content": "packages:\n  - 'apps/*'\n  - 'packages/*'"
            },
            {
                "path": "packages/",
                "content": [
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/core: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export const core = () => 'Hello from @ddms/core';"
                    },
                    {
                        "path": "project/packages/sdk/package.json",
                        "content": "{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/sdk: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/sdk/src/index.ts",
                        "content": "export const sdk = () => 'Hello from @ddms/sdk';"
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export const db = () => 'Hello from @ddms/db';"
                    }
                ]
            },
            {
                "path": "tsconfig.base.json",
                "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"format\": \"prettier --write \\\"**/*.{ts,tsx,md}\\\"\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^7.10.0\",\n    \"@typescript-eslint/parser\": \"^7.10.0\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"prettier\": \"^3.3.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}"
            },
            {
                "path": "apps/",
                "content": [
                    {
                        "path": "project/apps/web/package.json",
                        "content": "{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts,.tsx\",\n    \"test\": \"echo \\\"@ddms/web: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/web/src/index.ts",
                        "content": "// Placeholder for web app entry point"
                    },
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/api: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "console.log('Hello from @ddms/api');"
                    }
                ]
            },
            {
                "path": "pnpm-workspace.yaml",
                "content": "packages:\n  - 'apps/*'\n  - 'packages/*'"
            },
            {
                "path": "packages/",
                "content": [
                    {
                        "path": "project/packages/core/package.json",
                        "content": "{\n  \"name\": \"@ddms/core\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/core: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/core/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/core/src/index.ts",
                        "content": "export const core = () => 'Hello from @ddms/core';"
                    },
                    {
                        "path": "project/packages/sdk/package.json",
                        "content": "{\n  \"name\": \"@ddms/sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/sdk: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/sdk/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/sdk/src/index.ts",
                        "content": "export const sdk = () => 'Hello from @ddms/sdk';"
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export const db = () => 'Hello from @ddms/db';"
                    }
                ]
            },
            {
                "path": "tsconfig.base.json",
                "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"composite\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"ddms\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"description\": \"Dynamic Data Management System\",\n  \"scripts\": {\n    \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n    \"dev\": \"pnpm --parallel --stream run dev\",\n    \"format\": \"prettier --write \\\"**/*.{ts,tsx,md}\\\"\",\n    \"lint\": \"pnpm --parallel run lint\",\n    \"test\": \"pnpm --parallel run test\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^7.10.0\",\n    \"@typescript-eslint/parser\": \"^7.10.0\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"prettier\": \"^3.3.0\",\n    \"tsx\": \"^4.11.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}"
            },
            {
                "path": "apps/",
                "content": [
                    {
                        "path": "project/apps/web/package.json",
                        "content": "{\n  \"name\": \"@ddms/web\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"echo \\\"@ddms/web: no dev script specified\\\" && exit 0\",\n    \"lint\": \"eslint src --ext .ts,.tsx\",\n    \"test\": \"echo \\\"@ddms/web: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/web/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"noEmit\": true,\n    \"incremental\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\"\n  },\n  \"include\": [\"src\"],\n  \"references\": [\n    { \"path\": \"../../packages/sdk\" }\n  ]\n}"
                    },
                    {
                        "path": "project/apps/web/src/index.ts",
                        "content": "// Placeholder for web app entry point\nconsole.log('Hello from @ddms/web');"
                    },
                    {
                        "path": "project/apps/api/package.json",
                        "content": "{\n  \"name\": \"@ddms/api\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"tsx watch src/index.ts\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/api: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/apps/api/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": [\n    { \"path\": \"../../packages/core\" },\n    { \"path\": \"../../packages/db\" },\n    { \"path\": \"../../packages/sdk\" }\n  ]\n}"
                    },
                    {
                        "path": "project/apps/api/src/index.ts",
                        "content": "console.log('Hello from @ddms/api');"
                    }
                ]
            }
        ]
    },
    {
        "name": "I1.T2",
        "context": {
            "task_id": "I1.T2",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Set up the `packages/db` package with Drizzle ORM. Define the full database schema in TypeScript based on the DDL provided in the manifest (tables: `tenants`, `entity_types`, `field_defs`, `records`, `edges`, `record_versions`, `audit_log`).",
            "agent_type_hint": "DatabaseAgent",
            "inputs": "Section 6 of the manifest (Data Model DDL)",
            "target_files": [
                "packages/db/src/schema.ts"
            ],
            "input_files": [
                "packages/db/"
            ],
            "deliverables": "A TypeScript file containing the Drizzle schema definitions for all tables.",
            "acceptance_criteria": "The Drizzle schema correctly represents all tables, columns, types, and relations from the manifest's DDL. The code is type-correct.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "I will create a new file `packages/db/src/schema.ts` to define the Drizzle ORM schema based on the provided DDL.\n\nThis involves:\n1.  Importing necessary functions from `drizzle-orm` and `drizzle-orm/pg-core`.\n2.  Defining a `pgEnum` for `field_defs.kind` and a `customType` for `records.fts` (tsvector).\n3.  Translating each SQL `CREATE TABLE` statement into a Drizzle `pgTable` definition, mapping all columns, types, and constraints.\n4.  Adding table-level composite unique constraints where specified.\n5.  Defining all inter-table relationships using the `relations` helper function after all tables are defined, which is crucial for type-safe querying and joins.\n\nThe schema will accurately reflect all tables: `tenants`, `entity_types`, `field_defs`, `records`, `edges`, `record_versions`, and `audit_log`.\n\n~~~typescript\n#- file: packages/db/src/schema.ts\nimport { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));\n~~~\n~~~edits\n#- file: packages/db/src/index.ts\n***start_edit\nLITERAL\n***search\nexport const db = () => 'Hello from @ddms/db';\n***replace\nexport * from './schema';\n***description\nExport the newly created schema from the main index file of the @ddms/db package. This makes the schema objects available for other packages to import.\n***end_edit\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "packages/db/src/schema.ts"
        ],
        "input_files": [
            "packages/db/"
        ],
        "files": [
            {
                "path": "packages/db/",
                "content": [
                    {
                        "path": "project/packages/db/migrations/.gitkeep",
                        "content": ""
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export const db = () => 'Hello from @ddms/db';"
                    }
                ]
            },
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            },
            {
                "path": "packages/db/",
                "content": [
                    {
                        "path": "project/packages/db/migrations/.gitkeep",
                        "content": ""
                    },
                    {
                        "path": "project/packages/db/package.json",
                        "content": "{\n  \"name\": \"@ddms/db\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -b\",\n    \"lint\": \"eslint src --ext .ts\",\n    \"test\": \"echo \\\"@ddms/db: no test specified\\\" && exit 0\"\n  }\n}"
                    },
                    {
                        "path": "project/packages/db/tsconfig.json",
                        "content": "{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"references\": []\n}"
                    },
                    {
                        "path": "project/packages/db/src/schema.ts",
                        "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
                    },
                    {
                        "path": "project/packages/db/src/index.ts",
                        "content": "export * from './schema';"
                    }
                ]
            }
        ]
    },
    {
        "name": "I1.T3",
        "context": {
            "task_id": "I1.T3",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Generate the initial SQL migration files from the Drizzle schema defined in `I1.T2`.",
            "agent_type_hint": "DatabaseAgent",
            "inputs": "Drizzle schema from `I1.T2`.",
            "target_files": [
                "packages/db/migrations/0000_*.sql"
            ],
            "input_files": [
                "packages/db/src/schema.ts"
            ],
            "deliverables": "SQL migration files.",
            "acceptance_criteria": "The generated migration files accurately reflect the schema and can be applied to a clean PostgreSQL database without errors.",
            "dependencies": [
                "I1.T2"
            ],
            "parallelizable": false
        },
        "output": "This task requires generating the initial SQL migration file from the Drizzle schema. This is typically an automated process using `drizzle-kit`. I will replicate the output of this tool by analyzing the provided `packages/db/src/schema.ts` file and constructing the corresponding SQL DDL statements.\n\nThe migration will include:\n1.  Creation of the custom `field_kind` enum type.\n2.  Creation of all seven tables: `tenants`, `entity_types`, `field_defs`, `records`, `edges`, `record_versions`, and `audit_log`, with their respective columns, constraints, and default values.\n3.  Addition of all foreign key constraints with the specified `ON DELETE CASCADE` behavior.\n\nThe resulting SQL file will be placed in the `packages/db/migrations/` directory, following the naming convention `0000_*.sql`.\n\n~~~\n#- file: packages/db/migrations/0000_curvy_mysterio.sql\nCREATE TYPE \"field_kind\" AS ENUM('text', 'number', 'date', 'select', 'relation', 'boolean');\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"audit_log\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"actor_id\" uuid,\n\t\"action\" text NOT NULL,\n\t\"resource_type\" text NOT NULL,\n\t\"resource_id\" uuid,\n\t\"meta\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"edges\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"field_id\" uuid NOT NULL,\n\t\"from_record_id\" uuid NOT NULL,\n\t\"to_record_id\" uuid NOT NULL,\n\t\"created_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\tCONSTRAINT \"edges_tenant_id_field_id_from_record_id_to_record_id_unique\" UNIQUE(\"tenant_id\",\"field_id\",\"from_record_id\",\"to_record_id\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"entity_types\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"description\" text,\n\tCONSTRAINT \"entity_types_tenant_id_key_unique\" UNIQUE(\"tenant_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"field_defs\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"key\" text NOT NULL,\n\t\"label\" text NOT NULL,\n\t\"kind\" \"field_kind\" NOT NULL,\n\t\"required\" boolean DEFAULT false NOT NULL,\n\t\"unique_within_type\" boolean DEFAULT false NOT NULL,\n\t\"searchable\" boolean DEFAULT true NOT NULL,\n\t\"indexed\" boolean DEFAULT false NOT NULL,\n\t\"options\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"validate\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"acl\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"position\" integer DEFAULT 0 NOT NULL,\n\t\"active\" boolean DEFAULT true NOT NULL,\n\tCONSTRAINT \"field_defs_tenant_id_entity_type_id_key_unique\" UNIQUE(\"tenant_id\",\"entity_type_id\",\"key\")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"record_versions\" (\n\t\"id\" bigserial PRIMARY KEY NOT NULL,\n\t\"record_id\" uuid NOT NULL,\n\t\"version\" integer NOT NULL,\n\t\"data\" jsonb NOT NULL,\n\t\"changed_by\" uuid,\n\t\"changed_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"records\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"tenant_id\" uuid NOT NULL,\n\t\"entity_type_id\" uuid NOT NULL,\n\t\"data\" jsonb DEFAULT '{}'::jsonb NOT NULL,\n\t\"fts\" tsvector,\n\t\"version\" integer DEFAULT 1 NOT NULL,\n\t\"created_by\" uuid,\n\t\"updated_by\" uuid,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS \"tenants\" (\n\t\"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n\t\"name\" text NOT NULL,\n\t\"created_at\" timestamp with time zone DEFAULT now() NOT NULL\n);\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_field_id_field_defs_id_fk\" FOREIGN KEY (\"field_id\") REFERENCES \"public\".\"field_defs\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_from_record_id_records_id_fk\" FOREIGN KEY (\"from_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"edges\" ADD CONSTRAINT \"edges_to_record_id_records_id_fk\" FOREIGN KEY (\"to_record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"entity_types\" ADD CONSTRAINT \"entity_types_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"field_defs\" ADD CONSTRAINT \"field_defs_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"record_versions\" ADD CONSTRAINT \"record_versions_record_id_records_id_fk\" FOREIGN KEY (\"record_id\") REFERENCES \"public\".\"records\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_tenant_id_tenants_id_fk\" FOREIGN KEY (\"tenant_id\") REFERENCES \"public\".\"tenants\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE \"records\" ADD CONSTRAINT \"records_entity_type_id_entity_types_id_fk\" FOREIGN KEY (\"entity_type_id\") REFERENCES \"public\".\"entity_types\"(\"id\") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "packages/db/migrations/0000_*.sql"
        ],
        "input_files": [
            "packages/db/src/schema.ts"
        ],
        "files": [
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            },
            {
                "path": "packages/db/src/schema.ts",
                "content": "import { relations, sql } from 'drizzle-orm';\nimport {\n  bigserial,\n  boolean,\n  customType,\n  integer,\n  jsonb,\n  pgEnum,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\n\n// Enums and Custom Types\nexport const fieldKindEnum = pgEnum('field_kind', [\n  'text',\n  'number',\n  'date',\n  'select',\n  'relation',\n  'boolean',\n]);\n\nconst tsvector = customType<{ data: string }>('tsvector');\n\n// Table Definitions\n\n/**\n * 6.1 Tenancy\n * An organization using the system. Tenants are strictly isolated.\n */\nexport const tenants = pgTable('tenants', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  name: text('name').notNull(),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.2 Entity Types & Field Definitions\n * An Entity Type is a template describing a kind of record (e.g., \"user\", \"project\").\n */\nexport const entityTypes = pgTable(\n  'entity_types',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    description: text('description'),\n  },\n  (table) => ({\n    uniqueKey: unique('entity_types_tenant_id_key_unique').on(\n      table.tenantId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * A Field Definition describes a custom field's metadata (key, label, kind, constraints).\n */\nexport const fieldDefs = pgTable(\n  'field_defs',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    entityTypeId: uuid('entity_type_id')\n      .notNull()\n      .references(() => entityTypes.id, { onDelete: 'cascade' }),\n    key: text('key').notNull(),\n    label: text('label').notNull(),\n    kind: fieldKindEnum('kind').notNull(),\n    required: boolean('required').notNull().default(false),\n    uniqueWithinType: boolean('unique_within_type').notNull().default(false),\n    searchable: boolean('searchable').notNull().default(true),\n    indexed: boolean('indexed').notNull().default(false),\n    options: jsonb('options').notNull().default(sql`'{}'::jsonb`),\n    validate: jsonb('validate').notNull().default(sql`'{}'::jsonb`),\n    acl: jsonb('acl').notNull().default(sql`'{}'::jsonb`),\n    position: integer('position').notNull().default(0),\n    active: boolean('active').notNull().default(true),\n  },\n  (table) => ({\n    uniqueKey: unique('field_defs_tenant_id_entity_type_id_key_unique').on(\n      table.tenantId,\n      table.entityTypeId,\n      table.key,\n    ),\n  }),\n);\n\n/**\n * 6.3 Records (Property Bag)\n * A Record is one instance of an entity type, storing business data in a JSONB property bag.\n */\nexport const records = pgTable('records', {\n  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n  tenantId: uuid('tenant_id')\n    .notNull()\n    .references(() => tenants.id, { onDelete: 'cascade' }),\n  entityTypeId: uuid('entity_type_id')\n    .notNull()\n    .references(() => entityTypes.id, { onDelete: 'cascade' }),\n  data: jsonb('data').notNull().default(sql`'{}'::jsonb`),\n  fts: tsvector('fts'),\n  version: integer('version').notNull().default(1),\n  createdBy: uuid('created_by'),\n  updatedBy: uuid('updated_by'),\n  createdAt: timestamp('created_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * 6.4 Edges (Relationships)\n * An Edge represents a relationship between two records.\n */\nexport const edges = pgTable(\n  'edges',\n  {\n    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),\n    tenantId: uuid('tenant_id')\n      .notNull()\n      .references(() => tenants.id, { onDelete: 'cascade' }),\n    fieldId: uuid('field_id')\n      .notNull()\n      .references(() => fieldDefs.id, { onDelete: 'cascade' }),\n    fromRecordId: uuid('from_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    toRecordId: uuid('to_record_id')\n      .notNull()\n      .references(() => records.id, { onDelete: 'cascade' }),\n    createdBy: uuid('created_by'),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => ({\n    uniqueKey:\n      unique('edges_tenant_id_field_id_from_record_id_to_record_id_unique').on(\n        table.tenantId,\n        table.fieldId,\n        table.fromRecordId,\n        table.toRecordId,\n      ),\n  }),\n);\n\n/**\n * 6.5 History & Auditing\n * Stores historical versions of records.\n */\nexport const recordVersions = pgTable('record_versions', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  recordId: uuid('record_id')\n    .notNull()\n    .references(() => records.id, { onDelete: 'cascade' }),\n  version: integer('version').notNull(),\n  data: jsonb('data').notNull(),\n  changedBy: uuid('changed_by'),\n  changedAt: timestamp('changed_at', { withTimezone: true })\n    .notNull()\n    .defaultNow(),\n});\n\n/**\n * Logs significant actions within the system for auditing purposes.\n */\nexport const auditLog = pgTable('audit_log', {\n  id: bigserial('id', { mode: 'number' }).primaryKey(),\n  tenantId: uuid('tenant_id').notNull(),\n  actorId: uuid('actor_id'),\n  action: text('action').notNull(),\n  resourceType: text('resource_type').notNull(),\n  resourceId: uuid('resource_id'),\n  meta: jsonb('meta').notNull().default(sql`'{}'::jsonb`),\n  at: timestamp('at', { withTimezone: true }).notNull().defaultNow(),\n});\n\n// Relations\n\nexport const tenantsRelations = relations(tenants, ({ many }) => ({\n  entityTypes: many(entityTypes),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n  edges: many(edges),\n  auditLogs: many(auditLog),\n}));\n\nexport const entityTypesRelations = relations(entityTypes, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [entityTypes.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDefs: many(fieldDefs),\n  records: many(records),\n}));\n\nexport const fieldDefsRelations = relations(fieldDefs, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [fieldDefs.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [fieldDefs.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edges: many(edges),\n}));\n\nexport const recordsRelations = relations(records, ({ one, many }) => ({\n  tenant: one(tenants, {\n    fields: [records.tenantId],\n    references: [tenants.id],\n  }),\n  entityType: one(entityTypes, {\n    fields: [records.entityTypeId],\n    references: [entityTypes.id],\n  }),\n  edgesFrom: many(edges, { relationName: 'edgesFrom' }),\n  edgesTo: many(edges, { relationName: 'edgesTo' }),\n  versions: many(recordVersions),\n}));\n\nexport const edgesRelations = relations(edges, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [edges.tenantId],\n    references: [tenants.id],\n  }),\n  fieldDef: one(fieldDefs, {\n    fields: [edges.fieldId],\n    references: [fieldDefs.id],\n  }),\n  fromRecord: one(records, {\n    fields: [edges.fromRecordId],\n    references: [records.id],\n    relationName: 'edgesFrom',\n  }),\n  toRecord: one(records, {\n    fields: [edges.toRecordId],\n    references: [records.id],\n    relationName: 'edgesTo',\n  }),\n}));\n\nexport const recordVersionsRelations = relations(recordVersions, ({ one }) => ({\n  record: one(records, {\n    fields: [recordVersions.recordId],\n    references: [records.id],\n  }),\n}));\n\nexport const auditLogRelations = relations(auditLog, ({ one }) => ({\n  tenant: one(tenants, {\n    fields: [auditLog.tenantId],\n    references: [tenants.id],\n  }),\n}));"
            }
        ]
    },
    {
        "name": "I1.T4",
        "context": {
            "task_id": "I1.T4",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Create a `docker-compose.yml` file in the `infra/` directory to run a PostgreSQL 14+ instance for local development, including volume for data persistence.",
            "agent_type_hint": "SetupAgent",
            "inputs": "Section 5 of the manifest (Stack details)",
            "target_files": [
                "infra/docker-compose.yml"
            ],
            "input_files": [],
            "deliverables": "A functional `docker-compose.yml` file.",
            "acceptance_criteria": "`docker-compose up` successfully starts a PostgreSQL container.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "I will create the `infra/docker-compose.yml` file as requested. This file will define a PostgreSQL service using the official `postgres:14` image, configure it with environment variables for the user, password, and database name, map the standard PostgreSQL port `5432` to the host machine, and set up a named volume for data persistence.\n\n~~~yaml\n#- file: infra/docker-compose.yml\nversion: '3.8'\n\nservices:\n  db:\n    image: postgres:14\n    container_name: zentio-db\n    restart: unless-stopped\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: zentio_db\n    ports:\n      - '5432:5432'\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n    driver: local\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "infra/docker-compose.yml"
        ],
        "input_files": [],
        "files": [
            {
                "path": "infra/docker-compose.yml",
                "content": "version: '3.8'\n\nservices:\n  db:\n    image: postgres:14\n    container_name: zentio-db\n    restart: unless-stopped\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: zentio_db\n    ports:\n      - '5432:5432'\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n    driver: local"
            }
        ]
    },
    {
        "name": "I1.T5",
        "context": {
            "task_id": "I1.T5",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Generate a PlantUML Component Diagram for the Backend API based on the components described in Section 2 of this plan and Section 3.5 of the manifest's architecture blueprint.",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Section 2 (Core Architecture), Manifest Architecture Blueprint (Section 3.5)",
            "target_files": [
                "docs/diagrams/backend_component_diagram.puml"
            ],
            "input_files": [],
            "deliverables": "A PlantUML source file for the component diagram.",
            "acceptance_criteria": "The diagram accurately visualizes the REST Controllers, Authorization Service, Validation Engine, Filter Compiler, Core Services, Index Manager, SSE Broadcaster, and DAL. The file renders correctly.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "I will now generate the PlantUML component diagram for the Backend API. The task is to create a new file, `docs/diagrams/backend_component_diagram.puml`, and populate it with the PlantUML code that describes the internal components of the API server.\n\nThe design artifacts, specifically Section 3.5 of the manifest's architecture blueprint, provide a complete and accurate PlantUML definition for this diagram. I will use that as the source for the file's content. This will ensure all acceptance criteria are met, including the visualization of all required components and their relationships.\n\n~~~puml\n#- file: docs/diagrams/backend_component_diagram.puml\n@startuml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml\n\ntitle Component Diagram for Backend API\n\nContainer(api, \"Backend API\", \"Node.js, Fastify\") {\n    Component(rest_controller, \"REST API Controllers\", \"Fastify Routes\", \"Exposes OpenAPI endpoints, handles HTTP requests/responses.\")\n    Component(authz, \"Authorization Service\", \"TypeScript Module\", \"Enforces RBAC and per-field ACLs on incoming requests.\")\n    Component(validation_engine, \"Validation Engine\", \"TypeScript Module\", \"Dynamically builds and memoizes Zod schemas from Field Definitions.\")\n    Component(filter_compiler, \"Filter DSL Compiler\", \"TypeScript Module\", \"Parses JSON filter DSL and compiles it into parameterized SQL queries.\")\n    Component(core_services, \"Core Business Logic\", \"TypeScript Modules\", \"Implements logic for managing records, fields, bulk operations, etc.\")\n    Component(index_manager, \"Index Manager\", \"TypeScript Module\", \"Manages creation of on-demand expression indexes concurrently.\")\n    Component(sse_broadcaster, \"SSE Broadcaster\", \"TypeScript Module\", \"Listens for Postgres NOTIFY events and pushes them to connected SSE clients.\")\n    Component(dal, \"Data Access Layer\", \"Drizzle ORM\", \"Provides a type-safe interface to the database.\")\n}\n\nContainerDb(db, \"Database\", \"PostgreSQL\", \"Stores all system data.\")\n\nRel(rest_controller, authz, \"Uses\", \"For checking permissions\")\nRel(rest_controller, validation_engine, \"Uses\", \"For validating request bodies\")\nRel(rest_controller, core_services, \"Delegates to\", \"For business operations\")\nRel(rest_controller, filter_compiler, \"Uses\", \"For search requests\")\nRel(rest_controller, sse_broadcaster, \"Uses\", \"To handle SSE connections\")\n\nRel(core_services, dal, \"Uses\", \"To access data\")\nRel(filter_compiler, dal, \"Generates SQL for\")\nRel(index_manager, dal, \"Executes CREATE INDEX on\")\n\nRel(dal, db, \"Reads/Writes data\", \"SQL/TCP\")\nRel_Back(sse_broadcaster, db, \"Subscribes to events\", \"LISTEN/NOTIFY\")\n\n@enduml\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "docs/diagrams/backend_component_diagram.puml"
        ],
        "input_files": [],
        "files": [
            {
                "path": "docs/diagrams/backend_component_diagram.puml",
                "content": "@startuml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml\n\ntitle Component Diagram for Backend API\n\nContainer(api, \"Backend API\", \"Node.js, Fastify\") {\n    Component(rest_controller, \"REST API Controllers\", \"Fastify Routes\", \"Exposes OpenAPI endpoints, handles HTTP requests/responses.\")\n    Component(authz, \"Authorization Service\", \"TypeScript Module\", \"Enforces RBAC and per-field ACLs on incoming requests.\")\n    Component(validation_engine, \"Validation Engine\", \"TypeScript Module\", \"Dynamically builds and memoizes Zod schemas from Field Definitions.\")\n    Component(filter_compiler, \"Filter DSL Compiler\", \"TypeScript Module\", \"Parses JSON filter DSL and compiles it into parameterized SQL queries.\")\n    Component(core_services, \"Core Business Logic\", \"TypeScript Modules\", \"Implements logic for managing records, fields, bulk operations, etc.\")\n    Component(index_manager, \"Index Manager\", \"TypeScript Module\", \"Manages creation of on-demand expression indexes concurrently.\")\n    Component(sse_broadcaster, \"SSE Broadcaster\", \"TypeScript Module\", \"Listens for Postgres NOTIFY events and pushes them to connected SSE clients.\")\n    Component(dal, \"Data Access Layer\", \"Drizzle ORM\", \"Provides a type-safe interface to the database.\")\n}\n\nContainerDb(db, \"Database\", \"PostgreSQL\", \"Stores all system data.\")\n\nRel(rest_controller, authz, \"Uses\", \"For checking permissions\")\nRel(rest_controller, validation_engine, \"Uses\", \"For validating request bodies\")\nRel(rest_controller, core_services, \"Delegates to\", \"For business operations\")\nRel(rest_controller, filter_compiler, \"Uses\", \"For search requests\")\nRel(rest_controller, sse_broadcaster, \"Uses\", \"To handle SSE connections\")\n\nRel(core_services, dal, \"Uses\", \"To access data\")\nRel(filter_compiler, dal, \"Generates SQL for\")\nRel(index_manager, dal, \"Executes CREATE INDEX on\")\n\nRel(dal, db, \"Reads/Writes data\", \"SQL/TCP\")\nRel_Back(sse_broadcaster, db, \"Subscribes to events\", \"LISTEN/NOTIFY\")\n\n@enduml"
            }
        ]
    },
    {
        "name": "I1.T6",
        "context": {
            "task_id": "I1.T6",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Generate a Mermaid ERD for the database schema based on the DDL in Section 6 of the manifest.",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Section 6 of the manifest (Data Model DDL)",
            "target_files": [
                "docs/diagrams/database_erd.md"
            ],
            "input_files": [],
            "deliverables": "A Markdown file containing the Mermaid syntax for the ERD.",
            "acceptance_criteria": "The ERD correctly shows all entities and their relationships as defined in the schema. The Mermaid syntax is valid.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "~~~\n#- file: docs/diagrams/database_erd.md\n# Database Entity Relationship Diagram\n\nThis diagram visualizes the database schema for the Dynamic Data Management System, showing all tables and their relationships.\n\n```mermaid\nerDiagram\n    tenants {\n        uuid id PK \"Primary Key\"\n        text name \"Tenant's name\"\n    }\n\n    entity_types {\n        uuid id PK\n        uuid tenant_id FK\n        text key \"e.g., 'user', 'project'\"\n        text label \"e.g., 'User', 'Project'\"\n    }\n\n    field_defs {\n        uuid id PK\n        uuid tenant_id FK\n        uuid entity_type_id FK\n        text key \"e.g., 'status', 'budget'\"\n        text kind \"e.g., 'text', 'relation'\"\n    }\n\n    records {\n        uuid id PK\n        uuid tenant_id FK\n        uuid entity_type_id FK\n        jsonb data \"Property bag for custom fields\"\n        integer version \"For optimistic concurrency\"\n    }\n\n    edges {\n        uuid id PK\n        uuid tenant_id FK\n        uuid field_id FK \"Must be kind='relation'\"\n        uuid from_record_id FK \"Source of the relationship\"\n        uuid to_record_id FK \"Target of the relationship\"\n    }\n\n    record_versions {\n        bigserial id PK\n        uuid record_id FK\n        integer version \"Version number\"\n        jsonb data \"Snapshot of record data\"\n    }\n\n    audit_log {\n        bigserial id PK\n        uuid tenant_id FK\n        text action \"e.g., 'UPDATE_RECORD'\"\n        text resource_type\n        uuid resource_id\n    }\n\n    tenants ||--o{ entity_types : \"owns\"\n    tenants ||--o{ field_defs : \"owns\"\n    tenants ||--o{ records : \"owns\"\n    tenants ||--o{ edges : \"owns\"\n    tenants ||--o{ audit_log : \"owns\"\n\n    entity_types ||--o{ field_defs : \"has\"\n    entity_types ||--o{ records : \"has instances of\"\n\n    records ||--o{ record_versions : \"has versions\"\n    \n    field_defs ||--o{ edges : \"defines\"\n\n    records }o--|| edges : \"is source of (from)\"\n    records }o--|| edges : \"is target of (to)\"\n```\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "docs/diagrams/database_erd.md"
        ],
        "input_files": [],
        "files": [
            {
                "path": "docs/diagrams/database_erd.md",
                "content": "# Database Entity Relationship Diagram\n\nThis diagram visualizes the database schema for the Dynamic Data Management System, showing all tables and their relationships.\n\n```mermaid\nerDiagram\n    tenants {\n        uuid id PK \"Primary Key\"\n        text name \"Tenant's name\"\n    }\n\n    entity_types {\n        uuid id PK\n        uuid tenant_id FK\n        text key \"e.g., 'user', 'project'\"\n        text label \"e.g., 'User', 'Project'\"\n    }\n\n    field_defs {\n        uuid id PK\n        uuid tenant_id FK\n        uuid entity_type_id FK\n        text key \"e.g., 'status', 'budget'\"\n        text kind \"e.g., 'text', 'relation'\"\n    }\n\n    records {\n        uuid id PK\n        uuid tenant_id FK\n        uuid entity_type_id FK\n        jsonb data \"Property bag for custom fields\"\n        integer version \"For optimistic concurrency\"\n    }\n\n    edges {\n        uuid id PK\n        uuid tenant_id FK\n        uuid field_id FK \"Must be kind='relation'\"\n        uuid from_record_id FK \"Source of the relationship\"\n        uuid to_record_id FK \"Target of the relationship\"\n    }\n\n    record_versions {\n        bigserial id PK\n        uuid record_id FK\n        integer version \"Version number\"\n        jsonb data \"Snapshot of record data\"\n    }\n\n    audit_log {\n        bigserial id PK\n        uuid tenant_id FK\n        text action \"e.g., 'UPDATE_RECORD'\"\n        text resource_type\n        uuid resource_id\n    }\n\n    tenants ||--o{ entity_types : \"owns\"\n    tenants ||--o{ field_defs : \"owns\"\n    tenants ||--o{ records : \"owns\"\n    tenants ||--o{ edges : \"owns\"\n    tenants ||--o{ audit_log : \"owns\"\n\n    entity_types ||--o{ field_defs : \"has\"\n    entity_types ||--o{ records : \"has instances of\"\n\n    records ||--o{ record_versions : \"has versions\"\n    \n    field_defs ||--o{ edges : \"defines\"\n\n    records }o--|| edges : \"is source of (from)\"\n    records }o--|| edges : \"is target of (to)\"\n```"
            }
        ]
    },
    {
        "name": "I1.T7",
        "context": {
            "task_id": "I1.T7",
            "iteration_id": "I1",
            "iteration_goal": "Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.",
            "description": "Generate a PlantUML Sequence Diagram for the \"Record Search\" flow, as described in Section 3.7 of the manifest's architecture blueprint.",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Manifest Architecture Blueprint (Section 3.7)",
            "target_files": [
                "docs/diagrams/record_search_sequence.puml"
            ],
            "input_files": [],
            "deliverables": "A PlantUML source file for the sequence diagram.",
            "acceptance_criteria": "The diagram accurately depicts the interaction between User, Frontend, API, Filter Compiler, DAL, and Database. The file renders correctly.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": "~~~\n#- file: docs/diagrams/record_search_sequence.puml\n@startuml\ntitle Sequence Diagram: Record Search\n\nactor User\nparticipant \"Frontend App\" as FE\nparticipant \"Backend API\" as API\nparticipant \"Filter Compiler\" as Compiler\nparticipant \"Data Access Layer\" as DAL\ndatabase \"PostgreSQL DB\" as DB\n\nUser -> FE : Builds filter criteria in UI\nFE -> API : POST /entities/:type/search\\n(Filter DSL JSON)\n\nactivate API\nAPI -> Compiler : Compile(filterDSL)\nactivate Compiler\nCompiler --> API : Returns { sql: \"...\", params: [...] }\ndeactivate Compiler\n\nAPI -> DAL : findRecords(sql, params)\nactivate DAL\nDAL -> DB : Executes parameterized SQL query\nactivate DB\nDB --> DAL : Returns matching record rows\ndeactivate DB\nDAL --> API : Returns records\ndeactivate DAL\n\nAPI --> FE : 200 OK\\n{ rows: [...], nextCursor: ... }\ndeactivate API\nFE -> User : Displays filtered records in table\n\n@enduml\n~~~",
        "iteration_id": "I1",
        "completed": false,
        "target_files": [
            "docs/diagrams/record_search_sequence.puml"
        ],
        "input_files": [],
        "files": []
    },
    {
        "name": "I2.T1",
        "context": {
            "task_id": "I2.T1",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Scaffold the Fastify API server in `apps/api`. Include basic setup for routing, plugins (e.g., CORS), structured logging (Pino), and database connection using Drizzle.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 2 (Technology Stack)",
            "target_files": [
                "apps/api/src/server.ts",
                "apps/api/src/plugins/",
                "apps/api/src/routes/"
            ],
            "input_files": [
                "apps/api/",
                "packages/db/"
            ],
            "deliverables": "A runnable Fastify server that can connect to the database.",
            "acceptance_criteria": "The server starts without errors. A basic health check endpoint (`/health`) returns 200 OK.",
            "dependencies": [
                "I1.T2",
                "I1.T4"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I2",
        "completed": false,
        "target_files": [
            "apps/api/src/server.ts",
            "apps/api/src/plugins/",
            "apps/api/src/routes/"
        ],
        "input_files": [
            "apps/api/",
            "packages/db/"
        ],
        "files": []
    },
    {
        "name": "I2.T2",
        "context": {
            "task_id": "I2.T2",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Create the initial OpenAPI v3 specification in `api/openapi.yaml`. Define the schemas and endpoints for managing `entity_types` and `field_defs` (GET, POST, PATCH).",
            "agent_type_hint": "DocumentationAgent",
            "inputs": "Section 9.1 of the manifest (Metadata API)",
            "target_files": [
                "api/openapi.yaml"
            ],
            "input_files": [],
            "deliverables": "An OpenAPI YAML file.",
            "acceptance_criteria": "The YAML file is syntactically valid and passes OpenAPI validation. It accurately defines the metadata endpoints.",
            "dependencies": [],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I2",
        "completed": false,
        "target_files": [
            "api/openapi.yaml"
        ],
        "input_files": [],
        "files": []
    },
    {
        "name": "I2.T3",
        "context": {
            "task_id": "I2.T3",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Implement the Data Access Layer (DAL) functions within `apps/api` for CRUD operations on `entity_types` and `field_defs` using the Drizzle schema.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Drizzle schema from `I1.T2`.",
            "target_files": [
                "apps/api/src/lib/dal/metadata.ts"
            ],
            "input_files": [
                "packages/db/src/schema.ts",
                "apps/api/src/"
            ],
            "deliverables": "TypeScript functions for interacting with metadata tables.",
            "acceptance_criteria": "Functions are type-safe and correctly perform create, read, update operations.",
            "dependencies": [
                "I1.T2"
            ],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I2",
        "completed": false,
        "target_files": [
            "apps/api/src/lib/dal/metadata.ts"
        ],
        "input_files": [
            "packages/db/src/schema.ts",
            "apps/api/src/"
        ],
        "files": []
    },
    {
        "name": "I2.T4",
        "context": {
            "task_id": "I2.T4",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Implement the Fastify routes and handlers for the `entity_types` and `field_defs` endpoints, using the DAL functions from `I2.T3` and validating requests against Zod schemas derived from the OpenAPI spec.",
            "agent_type_hint": "BackendAgent",
            "inputs": "OpenAPI spec from `I2.T2`, DAL from `I2.T3`.",
            "target_files": [
                "apps/api/src/routes/metadata/"
            ],
            "input_files": [
                "api/openapi.yaml",
                "apps/api/src/lib/dal/metadata.ts"
            ],
            "deliverables": "Implemented API routes for metadata.",
            "acceptance_criteria": "Endpoints behave as specified in the OpenAPI document. Basic positive-path tests pass.",
            "dependencies": [
                "I2.T2",
                "I2.T3"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I2",
        "completed": false,
        "target_files": [
            "apps/api/src/routes/metadata/"
        ],
        "input_files": [
            "api/openapi.yaml",
            "apps/api/src/lib/dal/metadata.ts"
        ],
        "files": []
    },
    {
        "name": "I2.T5",
        "context": {
            "task_id": "I2.T5",
            "iteration_id": "I2",
            "iteration_goal": "Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.",
            "description": "Implement the database triggers for relation type checking (`edges_validate`) and the RLS policies for all tables, along with the API middleware to set `app.tenant_id` for each request.",
            "agent_type_hint": "DatabaseAgent",
            "inputs": "Section 6.6 and 6.7 of the manifest.",
            "target_files": [
                "packages/db/migrations/0001_triggers_and_rls.sql",
                "apps/api/src/plugins/tenant_context.ts"
            ],
            "input_files": [
                "packages/db/migrations/"
            ],
            "deliverables": "A new SQL migration file and a Fastify plugin.",
            "acceptance_criteria": "The migration applies successfully. The middleware correctly sets the tenant ID on the database connection.",
            "dependencies": [
                "I1.T3",
                "I2.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I2",
        "completed": false,
        "target_files": [
            "packages/db/migrations/0001_triggers_and_rls.sql",
            "apps/api/src/plugins/tenant_context.ts"
        ],
        "input_files": [
            "packages/db/migrations/"
        ],
        "files": []
    },
    {
        "name": "I3.T1",
        "context": {
            "task_id": "I3.T1",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Update `api/openapi.yaml` to include the endpoints for `records`: `POST /entities/:entityTypeKey`, `GET /entities/:entityTypeKey/:id`, `PATCH /entities/:entityTypeKey/:id`, and `POST /entities/:entityTypeKey/search`.",
            "agent_type_hint": "DocumentationAgent",
            "inputs": "Section 9.2 of the manifest, existing OpenAPI spec.",
            "target_files": [
                "api/openapi.yaml"
            ],
            "input_files": [
                "api/openapi.yaml"
            ],
            "deliverables": "Updated OpenAPI YAML file.",
            "acceptance_criteria": "The spec is valid and includes the new record management endpoints.",
            "dependencies": [
                "I2.T2"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "api/openapi.yaml"
        ],
        "input_files": [
            "api/openapi.yaml"
        ],
        "files": []
    },
    {
        "name": "I3.T2",
        "context": {
            "task_id": "I3.T2",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the `Validation Engine` in the `packages/core` package. It should contain a function that takes an array of `field_defs` and returns a Zod object schema. Implement memoization for caching.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 7.1 of the manifest.",
            "target_files": [
                "packages/core/src/validation.ts"
            ],
            "input_files": [
                "packages/core/"
            ],
            "deliverables": "A well-tested validation schema builder function.",
            "acceptance_criteria": "The function correctly translates `field_defs` of all kinds (`text`, `number`, `select`, etc.) into corresponding Zod validators.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "packages/core/src/validation.ts"
        ],
        "input_files": [
            "packages/core/"
        ],
        "files": []
    },
    {
        "name": "I3.T3",
        "context": {
            "task_id": "I3.T3",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the DAL functions for `records` within `apps/api`, including create, read, update, and a search function that accepts compiled SQL fragments.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Drizzle schema from `I1.T2`.",
            "target_files": [
                "apps/api/src/lib/dal/records.ts"
            ],
            "input_files": [
                "packages/db/src/schema.ts",
                "apps/api/src/"
            ],
            "deliverables": "TypeScript functions for interacting with the `records` table.",
            "acceptance_criteria": "Functions are type-safe and correctly perform their respective database operations.",
            "dependencies": [
                "I1.T2"
            ],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "apps/api/src/lib/dal/records.ts"
        ],
        "input_files": [
            "packages/db/src/schema.ts",
            "apps/api/src/"
        ],
        "files": []
    },
    {
        "name": "I3.T4",
        "context": {
            "task_id": "I3.T4",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the core `Filter DSL Compiler` in `packages/core`. This initial version should support `eq`, `neq`, `gt`, `gte`, `lt`, `lte`, `in`, `contains`, `fulltext`, and logical operators `and`, `or`.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 8 of the manifest.",
            "target_files": [
                "packages/core/src/filter-compiler.ts"
            ],
            "input_files": [
                "packages/core/"
            ],
            "deliverables": "A function that compiles Filter DSL JSON into parameterized SQL WHERE clauses.",
            "acceptance_criteria": "The compiler produces safe, parameterized SQL. Unit tests cover all supported operators.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "packages/core/src/filter-compiler.ts"
        ],
        "input_files": [
            "packages/core/"
        ],
        "files": []
    },
    {
        "name": "I3.T5",
        "context": {
            "task_id": "I3.T5",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the API routes and handlers for record CRUD and search, integrating the Validation Engine (`I3.T2`) for writes and the Filter Compiler (`I3.T4`) for search.",
            "agent_type_hint": "BackendAgent",
            "inputs": "OpenAPI spec (`I3.T1`), Validation Engine (`I3.T2`), Record DAL (`I3.T3`), Filter Compiler (`I3.T4`).",
            "target_files": [
                "apps/api/src/routes/entities/"
            ],
            "input_files": [
                "api/openapi.yaml",
                "packages/core/",
                "apps/api/src/lib/dal/records.ts"
            ],
            "deliverables": "Implemented API routes for records.",
            "acceptance_criteria": "Endpoints behave as specified. Validation errors are returned in the correct format. Search returns filtered results.",
            "dependencies": [
                "I3.T1",
                "I3.T2",
                "I3.T3",
                "I3.T4"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "apps/api/src/routes/entities/"
        ],
        "input_files": [
            "api/openapi.yaml",
            "packages/core/",
            "apps/api/src/lib/dal/records.ts"
        ],
        "files": []
    },
    {
        "name": "I3.T6",
        "context": {
            "task_id": "I3.T6",
            "iteration_id": "I3",
            "iteration_goal": "Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.",
            "description": "Implement the database triggers for FTS refresh (`records_fts_refresh`) and versioning (`records_versioning`) as new migration files.",
            "agent_type_hint": "DatabaseAgent",
            "inputs": "Section 6.6 of the manifest.",
            "target_files": [
                "packages/db/migrations/0002_record_triggers.sql"
            ],
            "input_files": [
                "packages/db/migrations/"
            ],
            "deliverables": "A new SQL migration file.",
            "acceptance_criteria": "The migration applies successfully. Updating a record correctly populates the `fts` column and creates an entry in `record_versions`.",
            "dependencies": [
                "I1.T3"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "packages/db/migrations/0002_record_triggers.sql"
        ],
        "input_files": [
            "packages/db/migrations/"
        ],
        "files": []
    },
    {
        "name": "I4.T1",
        "context": {
            "task_id": "I4.T1",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Scaffold the Next.js application in `apps/web` using TypeScript. Set up basic project structure, including components, pages, and styles.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Section 15 of the manifest.",
            "target_files": [
                "apps/web/src/",
                "apps/web/package.json",
                "apps/web/next.config.js"
            ],
            "input_files": [
                "apps/web/"
            ],
            "deliverables": "A runnable Next.js application.",
            "acceptance_criteria": "The default Next.js page loads successfully in a browser.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "apps/web/src/",
            "apps/web/package.json",
            "apps/web/next.config.js"
        ],
        "input_files": [
            "apps/web/"
        ],
        "files": []
    },
    {
        "name": "I4.T2",
        "context": {
            "task_id": "I4.T2",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Generate a typed API client using a tool like `openapi-typescript` and place it in the `packages/sdk` directory. Configure the frontend to use this SDK for all API calls.",
            "agent_type_hint": "SetupAgent",
            "inputs": "The OpenAPI spec from `I3.T1`.",
            "target_files": [
                "packages/sdk/src/index.ts"
            ],
            "input_files": [
                "api/openapi.yaml"
            ],
            "deliverables": "A TypeScript SDK package.",
            "acceptance_criteria": "The SDK is generated successfully and provides typed methods for all defined API endpoints.",
            "dependencies": [
                "I3.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "packages/sdk/src/index.ts"
        ],
        "input_files": [
            "api/openapi.yaml"
        ],
        "files": []
    },
    {
        "name": "I4.T3",
        "context": {
            "task_id": "I4.T3",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Integrate TanStack Query (React Query) into the Next.js app for server state management. Configure a global query client provider.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Next.js app from `I4.T1`.",
            "target_files": [
                "apps/web/src/lib/query-client.ts",
                "apps/web/src/pages/_app.tsx"
            ],
            "input_files": [
                "apps/web/src/pages/_app.tsx"
            ],
            "deliverables": "React Query setup.",
            "acceptance_criteria": "The `QueryClientProvider` is correctly configured at the root of the application.",
            "dependencies": [
                "I4.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "apps/web/src/lib/query-client.ts",
            "apps/web/src/pages/_app.tsx"
        ],
        "input_files": [
            "apps/web/src/pages/_app.tsx"
        ],
        "files": []
    },
    {
        "name": "I4.T4",
        "context": {
            "task_id": "I4.T4",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Create the UI pages and components for listing, creating, and editing `Entity Types`. Use the generated SDK and React Query for data fetching and mutations.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "SDK from `I4.T2`.",
            "target_files": [
                "apps/web/src/pages/admin/entity-types/",
                "apps/web/src/components/entity-types/"
            ],
            "input_files": [
                "packages/sdk/",
                "apps/web/src/"
            ],
            "deliverables": "React components and pages for Entity Type management.",
            "acceptance_criteria": "Users can view a list of entity types, create a new one, and edit an existing one's label/description.",
            "dependencies": [
                "I4.T2",
                "I4.T3"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "apps/web/src/pages/admin/entity-types/",
            "apps/web/src/components/entity-types/"
        ],
        "input_files": [
            "packages/sdk/",
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I4.T5",
        "context": {
            "task_id": "I4.T5",
            "iteration_id": "I4",
            "iteration_goal": "Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.",
            "description": "Create the UI pages and components for managing `Field Definitions` for a specific entity type.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "SDK from `I4.T2`.",
            "target_files": [
                "apps/web/src/pages/admin/entity-types/[id].tsx",
                "apps/web/src/components/field-defs/"
            ],
            "input_files": [
                "packages/sdk/",
                "apps/web/src/"
            ],
            "deliverables": "React components and pages for Field Definition management.",
            "acceptance_criteria": "Users can view, add, and edit fields for a selected entity type. The form should handle all `kind` options and validation rules.",
            "dependencies": [
                "I4.T4"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "apps/web/src/pages/admin/entity-types/[id].tsx",
            "apps/web/src/components/field-defs/"
        ],
        "input_files": [
            "packages/sdk/",
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I5.T1",
        "context": {
            "task_id": "I5.T1",
            "iteration_id": "I5",
            "iteration_goal": "Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.",
            "description": "Implement a dynamic table component using TanStack Table. The component should accept an `entityTypeKey`, fetch its `field_defs`, and render columns dynamically. It should also fetch data from the `/search` endpoint.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Section 15.2 of the manifest.",
            "target_files": [
                "apps/web/src/components/dynamic-table/",
                "apps/web/src/pages/entities/[entityTypeKey]/index.tsx"
            ],
            "input_files": [
                "apps/web/src/"
            ],
            "deliverables": "A reusable dynamic table component and a page to display it.",
            "acceptance_criteria": "The table correctly displays columns and data for a given entity type. Basic server-side pagination works.",
            "dependencies": [
                "I4.T5"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "apps/web/src/components/dynamic-table/",
            "apps/web/src/pages/entities/[entityTypeKey]/index.tsx"
        ],
        "input_files": [
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I5.T2",
        "context": {
            "task_id": "I5.T2",
            "iteration_id": "I5",
            "iteration_goal": "Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.",
            "description": "Implement a filter builder UI that allows users to construct a Filter DSL JSON object. This UI should be connected to the dynamic table to trigger searches.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Section 15.2 of the manifest.",
            "target_files": [
                "apps/web/src/components/filter-builder/"
            ],
            "input_files": [
                "apps/web/src/components/dynamic-table/"
            ],
            "deliverables": "A filter builder component.",
            "acceptance_criteria": "The component generates a valid Filter DSL object based on user input and refetches table data when the filter is applied.",
            "dependencies": [
                "I5.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "apps/web/src/components/filter-builder/"
        ],
        "input_files": [
            "apps/web/src/components/dynamic-table/"
        ],
        "files": []
    },
    {
        "name": "I5.T3",
        "context": {
            "task_id": "I5.T3",
            "iteration_id": "I5",
            "iteration_goal": "Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.",
            "description": "Implement a dynamic form component using TanStack Form. The component should fetch `field_defs` and render the appropriate input fields (text, number, select, etc.) with client-side validation.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Section 15.3 of the manifest.",
            "target_files": [
                "apps/web/src/components/dynamic-form/"
            ],
            "input_files": [
                "apps/web/src/"
            ],
            "deliverables": "A reusable dynamic form component.",
            "acceptance_criteria": "The form renders correctly for different field kinds. Client-side validation provides immediate feedback.",
            "dependencies": [
                "I4.T5"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "apps/web/src/components/dynamic-form/"
        ],
        "input_files": [
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I5.T4",
        "context": {
            "task_id": "I5.T4",
            "iteration_id": "I5",
            "iteration_goal": "Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.",
            "description": "Create pages for creating and editing records, integrating the dynamic form component. On submission, it should call the appropriate API endpoints.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Dynamic form from `I5.T3`.",
            "target_files": [
                "apps/web/src/pages/entities/[entityTypeKey]/new.tsx",
                "apps/web/src/pages/entities/[entityTypeKey]/[recordId].tsx"
            ],
            "input_files": [
                "apps/web/src/components/dynamic-form/"
            ],
            "deliverables": "Pages for creating and editing records.",
            "acceptance_criteria": "Users can successfully create and update records. Server-side validation errors are displayed correctly on the form.",
            "dependencies": [
                "I5.T3"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "apps/web/src/pages/entities/[entityTypeKey]/new.tsx",
            "apps/web/src/pages/entities/[entityTypeKey]/[recordId].tsx"
        ],
        "input_files": [
            "apps/web/src/components/dynamic-form/"
        ],
        "files": []
    },
    {
        "name": "I6.T1",
        "context": {
            "task_id": "I6.T1",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Update `api/openapi.yaml` to include endpoints for creating and deleting relations (`/relations`).",
            "agent_type_hint": "DocumentationAgent",
            "inputs": "Section 9.3 of the manifest.",
            "target_files": [
                "api/openapi.yaml"
            ],
            "input_files": [
                "api/openapi.yaml"
            ],
            "deliverables": "Updated OpenAPI YAML file.",
            "acceptance_criteria": "The spec is valid and includes the new relation management endpoints.",
            "dependencies": [
                "I3.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "api/openapi.yaml"
        ],
        "input_files": [
            "api/openapi.yaml"
        ],
        "files": []
    },
    {
        "name": "I6.T2",
        "context": {
            "task_id": "I6.T2",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Implement the backend logic and API endpoints for creating and deleting `edges` (relations).",
            "agent_type_hint": "BackendAgent",
            "inputs": "OpenAPI spec from `I6.T1`.",
            "target_files": [
                "apps/api/src/routes/relations/",
                "apps/api/src/lib/dal/edges.ts"
            ],
            "input_files": [
                "api/openapi.yaml",
                "apps/api/src/"
            ],
            "deliverables": "Implemented API routes for relations.",
            "acceptance_criteria": "Users can create and delete relationships between records. The `edges_validate` trigger prevents invalid relations.",
            "dependencies": [
                "I6.T1",
                "I2.T5"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "apps/api/src/routes/relations/",
            "apps/api/src/lib/dal/edges.ts"
        ],
        "input_files": [
            "api/openapi.yaml",
            "apps/api/src/"
        ],
        "files": []
    },
    {
        "name": "I6.T3",
        "context": {
            "task_id": "I6.T3",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Implement the `SSE Broadcaster` on the backend, which listens to Postgres `NOTIFY` events and forwards them to clients connected to a `GET /events` endpoint. Add `NOTIFY` calls to the database triggers.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 9.5 and 24.4 of the manifest.",
            "target_files": [
                "apps/api/src/routes/events.ts",
                "packages/db/migrations/0003_notify_triggers.sql"
            ],
            "input_files": [
                "apps/api/src/",
                "packages/db/migrations/"
            ],
            "deliverables": "SSE endpoint and updated DB triggers.",
            "acceptance_criteria": "Changes to records or edges emit a notification that is broadcast to connected SSE clients.",
            "dependencies": [
                "I3.T6"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "apps/api/src/routes/events.ts",
            "packages/db/migrations/0003_notify_triggers.sql"
        ],
        "input_files": [
            "apps/api/src/",
            "packages/db/migrations/"
        ],
        "files": []
    },
    {
        "name": "I6.T4",
        "context": {
            "task_id": "I6.T4",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Integrate an SSE client into the frontend. On receiving events, invalidate the relevant React Query caches to trigger automatic data refetching and UI updates.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "SSE endpoint from `I6.T3`.",
            "target_files": [
                "apps/web/src/hooks/use-sse.ts",
                "apps/web/src/pages/_app.tsx"
            ],
            "input_files": [
                "apps/web/src/"
            ],
            "deliverables": "Real-time UI updates.",
            "acceptance_criteria": "When a record is updated in one browser tab, the change is reflected in the data table in another tab without a manual refresh.",
            "dependencies": [
                "I6.T3",
                "I5.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "apps/web/src/hooks/use-sse.ts",
            "apps/web/src/pages/_app.tsx"
        ],
        "input_files": [
            "apps/web/src/"
        ],
        "files": []
    },
    {
        "name": "I6.T5",
        "context": {
            "task_id": "I6.T5",
            "iteration_id": "I6",
            "iteration_goal": "Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).",
            "description": "Implement the authorization layer in the backend. This includes a middleware to parse JWTs and an authorization service that enforces RBAC and per-field ACLs on all relevant endpoints.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Section 10 of the manifest.",
            "target_files": [
                "apps/api/src/plugins/auth.ts",
                "apps/api/src/lib/authz.ts"
            ],
            "input_files": [
                "apps/api/src/"
            ],
            "deliverables": "A comprehensive authorization system.",
            "acceptance_criteria": "API requests fail with 401/403 errors for users with insufficient permissions. Data returned from read endpoints is stripped of fields the user cannot see.",
            "dependencies": [
                "I3.T5"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "apps/api/src/plugins/auth.ts",
            "apps/api/src/lib/authz.ts"
        ],
        "input_files": [
            "apps/api/src/"
        ],
        "files": []
    }
]