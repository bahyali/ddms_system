# Project Plan: Dynamic Data Management System (DDMS)

**Version:** 1.0
**Date:** 2024-05-21
**Generated By:** GPT-4o

## 1. Project Overview

*   **Goal:** To build a multi-tenant system allowing customers to define custom data schemas (fields, entities, relationships) without database migrations, featuring sub-second querying, strong validation, and real-time updates.
*   **High-Level Requirements Summary:**
    *   Multi-tenant architecture with strict data isolation via PostgreSQL RLS.
    *   Dynamic schema management for Entity Types and Field Definitions.
    *   Flexible record storage using a JSONB "property bag".
    *   Powerful search capabilities via a custom JSON-based Filter DSL.
    *   Robust, dynamic server-side validation based on Field Definitions.
    *   Management of relationships (edges) between records.
    *   Record versioning and a comprehensive audit log.
    *   Real-time UI updates using Server-Sent Events (SSE) powered by Postgres LISTEN/NOTIFY.
    *   A high-performance, responsive React frontend with dynamic tables and forms.
    *   A RESTful API specified with OpenAPI.
*   **Key Assumptions:**
    *   The technology stack specified in the requirements (Node.js, Fastify, PostgreSQL, React, Next.js, Drizzle, Zod) is final and approved.
    *   Tenants are completely isolated with no requirement for cross-tenant data access.
    *   The initial development will focus on core CRUD, search, and dynamic schema features. Advanced features like bulk import/export and computed fields will be built upon this foundation.
    *   Authentication (JWT generation and refresh flows) is handled by an external service; this system is responsible for validating JWTs and enforcing authorization.

## 2. Core Architecture

*   **Architectural Style:** Layered Monolith with event-driven elements for real-time notifications. The backend is internally modularized to promote separation of concerns.
*   **Technology Stack:**
    *   Frontend: React 18+, Next.js, TanStack (Table, Form, Query), TypeScript.
    *   Backend: Node.js 20+, Fastify, TypeScript, Drizzle ORM, Zod.
    *   Database: PostgreSQL 14+ with `pgcrypto` extension.
    *   Messaging/Queues: PostgreSQL `LISTEN/NOTIFY` for real-time events.
    *   Deployment: Docker containers for the API, with a managed PostgreSQL service recommended.
    *   Other Key Libraries/Tools: OpenAPI for API specification, Pino for logging, Playwright for E2E testing.
*   **Key Components/Services:**
    *   **Backend API:** Exposes REST endpoints, handles authorization, validation, and business logic.
    *   **Validation Engine:** Dynamically builds and caches Zod validation schemas from `field_defs`.
    *   **Filter DSL Compiler:** Parses the JSON filter language and safely compiles it to parameterized SQL queries.
    *   **Index Manager:** Manages the creation of on-demand expression indexes on the `records` table.
    *   **SSE Broadcaster:** Listens for database notifications and pushes events to connected clients.
    *   **Data Access Layer (DAL):** Uses Drizzle ORM for type-safe database interaction.
    *   **Frontend Application:** A Next.js SPA that provides the dynamic UI for managing metadata and data.
*   **Data Model Overview:** The core data is stored in a `records` table using a `data` JSONB column (property bag pattern). Metadata (`entity_types`, `field_defs`) defines the structure and rules for the data within the JSONB column. Relationships are explicitly stored in a dedicated `edges` table. *An ERD will be generated in I1.T6.*
*   **API Contract Style:** RESTful, defined by an OpenAPI v3 specification. *The initial spec will be created in I2.T2 and refined in subsequent iterations.*
*   **Communication Patterns:**
    *   **Synchronous Request/Response:** For all standard CRUD and search operations via the REST API.
    *   **Asynchronous Server-to-Client Push:** For real-time UI updates using Server-Sent Events (SSE). *A sequence diagram for the search flow will be generated in I1.T7.*

## 2.1. Key Architectural Artifacts Planned

*   **Backend Component Diagram (PlantUML):** To visualize the internal components of the API server and their interactions. (Created in I1.T5)
*   **Database ERD (Mermaid):** To provide a clear visual representation of the database schema and entity relationships. (Created in I1.T6)
*   **Record Search Sequence Diagram (PlantUML):** To detail the flow of a search request from the API endpoint through the Filter Compiler to the database. (Created in I1.T7)
*   **API Specification (OpenAPI v3 YAML):** To define all API endpoints, request/response schemas, and security requirements. This will serve as the contract for the frontend and backend. (Created in I2.T2, refined in I3.T1, I6.T1)

## 3. Directory Structure

*   **Root Directory:** `ddms/`
*   **Structure Definition:** A monorepo structure to manage shared packages and applications.
    ~~~
    ddms/
    ├── apps/
    │   ├── api/            # Fastify backend application
    │   │   ├── src/
    │   │   └── package.json
    │   └── web/            # Next.js frontend application
    │       ├── src/
    │       └── package.json
    ├── packages/
    │   ├── core/           # Shared business logic (Filter Compiler, Validation Engine)
    │   │   ├── src/
    │   │   └── package.json
    │   ├── db/             # Drizzle ORM schema, migrations, and seeding
    │   │   ├── migrations/
    │   │   ├── src/
    │   │   └── package.json
    │   └── sdk/            # Auto-generated API client from OpenAPI spec
    │       └── package.json
    ├── docs/
    │   ├── diagrams/       # PlantUML and Mermaid source files for architecture
    │   └── adr/            # Architectural Decision Records (optional)
    ├── api/                # OpenAPI specification file(s)
    │   └── openapi.yaml
    ├── infra/
    │   └── docker-compose.yml # For local development environment (Postgres)
    ├── package.json        # Root package.json for monorepo workspace (pnpm)
    ├── pnpm-workspace.yaml
    └── tsconfig.base.json
    ~~~

## 4. Iteration Plan

*   **Total Iterations Planned:** 6
*   **Iteration Dependencies:** Iterations are designed to be sequential, with each building upon the deliverables of the previous one. Frontend development (I4) begins after the core backend APIs are defined and implemented.

---

### Iteration 1: Foundation, Database, and Architecture Visualization

*   **Iteration ID:** `I1`
*   **Goal:** Establish the project structure, define the complete database schema with migrations, set up the local development environment, and generate core architectural diagrams.
*   **Prerequisites:** None
*   **Tasks:**
    *   **Task 1.1:**
        *   **Task ID:** `I1.T1`
        *   **Description:** Initialize the pnpm monorepo workspace with the directory structure defined in Section 3. Set up base TypeScript configurations (`tsconfig.base.json`).
        *   **Agent Type Hint:** `SetupAgent`
        *   **Inputs:** Section 3 (Directory Structure)
        *   **Input Files**: []
        *   **Target Files:** [`package.json`, `pnpm-workspace.yaml`, `tsconfig.base.json`, `apps/`, `packages/`]
        *   **Deliverables:** An initialized monorepo with placeholder `package.json` files in each app/package.
        *   **Acceptance Criteria:** The directory structure matches the plan. `pnpm install` runs successfully at the root.
        *   **Dependencies:** None
        *   **Parallelizable:** No
    *   **Task 1.2:**
        *   **Task ID:** `I1.T2`
        *   **Description:** Set up the `packages/db` package with Drizzle ORM. Define the full database schema in TypeScript based on the DDL provided in the manifest (tables: `tenants`, `entity_types`, `field_defs`, `records`, `edges`, `record_versions`, `audit_log`).
        *   **Agent Type Hint:** `DatabaseAgent`
        *   **Inputs:** Section 6 of the manifest (Data Model DDL)
        *   **Input Files**: [`packages/db/`]
        *   **Target Files:** [`packages/db/src/schema.ts`]
        *   **Deliverables:** A TypeScript file containing the Drizzle schema definitions for all tables.
        *   **Acceptance Criteria:** The Drizzle schema correctly represents all tables, columns, types, and relations from the manifest's DDL. The code is type-correct.
        *   **Dependencies:** [`I1.T1`]
        *   **Parallelizable:** Yes
    *   **Task 1.3:**
        *   **Task ID:** `I1.T3`
        *   **Description:** Generate the initial SQL migration files from the Drizzle schema defined in `I1.T2`.
        *   **Agent Type Hint:** `DatabaseAgent`
        *   **Inputs:** Drizzle schema from `I1.T2`.
        *   **Input Files**: [`packages/db/src/schema.ts`]
        *   **Target Files:** [`packages/db/migrations/0000_*.sql`]
        *   **Deliverables:** SQL migration files.
        *   **Acceptance Criteria:** The generated migration files accurately reflect the schema and can be applied to a clean PostgreSQL database without errors.
        *   **Dependencies:** [`I1.T2`]
        *   **Parallelizable:** No
    *   **Task 1.4:**
        *   **Task ID:** `I1.T4`
        *   **Description:** Create a `docker-compose.yml` file in the `infra/` directory to run a PostgreSQL 14+ instance for local development, including volume for data persistence.
        *   **Agent Type Hint:** `SetupAgent`
        *   **Inputs:** Section 5 of the manifest (Stack details)
        *   **Input Files**: []
        *   **Target Files:** [`infra/docker-compose.yml`]
        *   **Deliverables:** A functional `docker-compose.yml` file.
        *   **Acceptance Criteria:** `docker-compose up` successfully starts a PostgreSQL container.
        *   **Dependencies:** [`I1.T1`]
        *   **Parallelizable:** Yes
    *   **Task 1.5:**
        *   **Task ID:** `I1.T5`
        *   **Description:** Generate a PlantUML Component Diagram for the Backend API based on the components described in Section 2 of this plan and Section 3.5 of the manifest's architecture blueprint.
        *   **Agent Type Hint:** `DiagrammingAgent`
        *   **Inputs:** Section 2 (Core Architecture), Manifest Architecture Blueprint (Section 3.5)
        *   **Input Files**: []
        *   **Target Files:** [`docs/diagrams/backend_component_diagram.puml`]
        *   **Deliverables:** A PlantUML source file for the component diagram.
        *   **Acceptance Criteria:** The diagram accurately visualizes the REST Controllers, Authorization Service, Validation Engine, Filter Compiler, Core Services, Index Manager, SSE Broadcaster, and DAL. The file renders correctly.
        *   **Dependencies:** [`I1.T1`]
        *   **Parallelizable:** Yes
    *   **Task 1.6:**
        *   **Task ID:** `I1.T6`
        *   **Description:** Generate a Mermaid ERD for the database schema based on the DDL in Section 6 of the manifest.
        *   **Agent Type Hint:** `DiagrammingAgent`
        *   **Inputs:** Section 6 of the manifest (Data Model DDL)
        *   **Input Files**: []
        *   **Target Files:** [`docs/diagrams/database_erd.md`]
        *   **Deliverables:** A Markdown file containing the Mermaid syntax for the ERD.
        *   **Acceptance Criteria:** The ERD correctly shows all entities and their relationships as defined in the schema. The Mermaid syntax is valid.
        *   **Dependencies:** [`I1.T1`]
        *   **Parallelizable:** Yes
    *   **Task 1.7:**
        *   **Task ID:** `I1.T7`
        *   **Description:** Generate a PlantUML Sequence Diagram for the "Record Search" flow, as described in Section 3.7 of the manifest's architecture blueprint.
        *   **Agent Type Hint:** `DiagrammingAgent`
        *   **Inputs:** Manifest Architecture Blueprint (Section 3.7)
        *   **Input Files**: []
        *   **Target Files:** [`docs/diagrams/record_search_sequence.puml`]
        *   **Deliverables:** A PlantUML source file for the sequence diagram.
        *   **Acceptance Criteria:** The diagram accurately depicts the interaction between User, Frontend, API, Filter Compiler, DAL, and Database. The file renders correctly.
        *   **Dependencies:** [`I1.T1`]
        *   **Parallelizable:** Yes

---

### Iteration 2: API Scaffolding & Metadata Management

*   **Iteration ID:** `I2`
*   **Goal:** Implement the backend API server and the CRUD endpoints for managing `entity_types` and `field_defs`.
*   **Prerequisites:** `I1`
*   **Tasks:**
    *   **Task 2.1:**
        *   **Task ID:** `I2.T1`
        *   **Description:** Scaffold the Fastify API server in `apps/api`. Include basic setup for routing, plugins (e.g., CORS), structured logging (Pino), and database connection using Drizzle.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 2 (Technology Stack)
        *   **Input Files**: [`apps/api/`, `packages/db/`]
        *   **Target Files:** [`apps/api/src/server.ts`, `apps/api/src/plugins/`, `apps/api/src/routes/`]
        *   **Deliverables:** A runnable Fastify server that can connect to the database.
        *   **Acceptance Criteria:** The server starts without errors. A basic health check endpoint (`/health`) returns 200 OK.
        *   **Dependencies:** [`I1.T2`, `I1.T4`]
        *   **Parallelizable:** No
    *   **Task 2.2:**
        *   **Task ID:** `I2.T2`
        *   **Description:** Create the initial OpenAPI v3 specification in `api/openapi.yaml`. Define the schemas and endpoints for managing `entity_types` and `field_defs` (GET, POST, PATCH).
        *   **Agent Type Hint:** `DocumentationAgent`
        *   **Inputs:** Section 9.1 of the manifest (Metadata API)
        *   **Input Files**: []
        *   **Target Files:** [`api/openapi.yaml`]
        *   **Deliverables:** An OpenAPI YAML file.
        *   **Acceptance Criteria:** The YAML file is syntactically valid and passes OpenAPI validation. It accurately defines the metadata endpoints.
        *   **Dependencies:** None
        *   **Parallelizable:** Yes
    *   **Task 2.3:**
        *   **Task ID:** `I2.T3`
        *   **Description:** Implement the Data Access Layer (DAL) functions within `apps/api` for CRUD operations on `entity_types` and `field_defs` using the Drizzle schema.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Drizzle schema from `I1.T2`.
        *   **Input Files**: [`packages/db/src/schema.ts`, `apps/api/src/`]
        *   **Target Files:** [`apps/api/src/lib/dal/metadata.ts`]
        *   **Deliverables:** TypeScript functions for interacting with metadata tables.
        *   **Acceptance Criteria:** Functions are type-safe and correctly perform create, read, update operations.
        *   **Dependencies:** [`I1.T2`]
        *   **Parallelizable:** Yes
    *   **Task 2.4:**
        *   **Task ID:** `I2.T4`
        *   **Description:** Implement the Fastify routes and handlers for the `entity_types` and `field_defs` endpoints, using the DAL functions from `I2.T3` and validating requests against Zod schemas derived from the OpenAPI spec.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** OpenAPI spec from `I2.T2`, DAL from `I2.T3`.
        *   **Input Files**: [`api/openapi.yaml`, `apps/api/src/lib/dal/metadata.ts`]
        *   **Target Files:** [`apps/api/src/routes/metadata/`]
        *   **Deliverables:** Implemented API routes for metadata.
        *   **Acceptance Criteria:** Endpoints behave as specified in the OpenAPI document. Basic positive-path tests pass.
        *   **Dependencies:** [`I2.T2`, `I2.T3`]
        *   **Parallelizable:** No
    *   **Task 2.5:**
        *   **Task ID:** `I2.T5`
        *   **Description:** Implement the database triggers for relation type checking (`edges_validate`) and the RLS policies for all tables, along with the API middleware to set `app.tenant_id` for each request.
        *   **Agent Type Hint:** `DatabaseAgent`
        *   **Inputs:** Section 6.6 and 6.7 of the manifest.
        *   **Input Files**: [`packages/db/migrations/`]
        *   **Target Files:** [`packages/db/migrations/0001_triggers_and_rls.sql`, `apps/api/src/plugins/tenant_context.ts`]
        *   **Deliverables:** A new SQL migration file and a Fastify plugin.
        *   **Acceptance Criteria:** The migration applies successfully. The middleware correctly sets the tenant ID on the database connection.
        *   **Dependencies:** [`I1.T3`, `I2.T1`]
        *   **Parallelizable:** No

---

### Iteration 3: Core Record Management & Search

*   **Iteration ID:** `I3`
*   **Goal:** Implement CRUD operations for `records`, including the dynamic validation engine and the initial version of the Filter DSL for searching.
*   **Prerequisites:** `I2`
*   **Tasks:**
    *   **Task 3.1:**
        *   **Task ID:** `I3.T1`
        *   **Description:** Update `api/openapi.yaml` to include the endpoints for `records`: `POST /entities/:entityTypeKey`, `GET /entities/:entityTypeKey/:id`, `PATCH /entities/:entityTypeKey/:id`, and `POST /entities/:entityTypeKey/search`.
        *   **Agent Type Hint:** `DocumentationAgent`
        *   **Inputs:** Section 9.2 of the manifest, existing OpenAPI spec.
        *   **Input Files**: [`api/openapi.yaml`]
        *   **Target Files:** [`api/openapi.yaml`]
        *   **Deliverables:** Updated OpenAPI YAML file.
        *   **Acceptance Criteria:** The spec is valid and includes the new record management endpoints.
        *   **Dependencies:** [`I2.T2`]
        *   **Parallelizable:** No
    *   **Task 3.2:**
        *   **Task ID:** `I3.T2`
        *   **Description:** Implement the `Validation Engine` in the `packages/core` package. It should contain a function that takes an array of `field_defs` and returns a Zod object schema. Implement memoization for caching.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 7.1 of the manifest.
        *   **Input Files**: [`packages/core/`]
        *   **Target Files:** [`packages/core/src/validation.ts`]
        *   **Deliverables:** A well-tested validation schema builder function.
        *   **Acceptance Criteria:** The function correctly translates `field_defs` of all kinds (`text`, `number`, `select`, etc.) into corresponding Zod validators.
        *   **Dependencies:** [`I1.T1`]
        *   **Parallelizable:** Yes
    *   **Task 3.3:**
        *   **Task ID:** `I3.T3`
        *   **Description:** Implement the DAL functions for `records` within `apps/api`, including create, read, update, and a search function that accepts compiled SQL fragments.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Drizzle schema from `I1.T2`.
        *   **Input Files**: [`packages/db/src/schema.ts`, `apps/api/src/`]
        *   **Target Files:** [`apps/api/src/lib/dal/records.ts`]
        *   **Deliverables:** TypeScript functions for interacting with the `records` table.
        *   **Acceptance Criteria:** Functions are type-safe and correctly perform their respective database operations.
        *   **Dependencies:** [`I1.T2`]
        *   **Parallelizable:** Yes
    *   **Task 3.4:**
        *   **Task ID:** `I3.T4`
        *   **Description:** Implement the core `Filter DSL Compiler` in `packages/core`. This initial version should support `eq`, `neq`, `gt`, `gte`, `lt`, `lte`, `in`, `contains`, `fulltext`, and logical operators `and`, `or`.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 8 of the manifest.
        *   **Input Files**: [`packages/core/`]
        *   **Target Files:** [`packages/core/src/filter-compiler.ts`]
        *   **Deliverables:** A function that compiles Filter DSL JSON into parameterized SQL WHERE clauses.
        *   **Acceptance Criteria:** The compiler produces safe, parameterized SQL. Unit tests cover all supported operators.
        *   **Dependencies:** [`I1.T1`]
        *   **Parallelizable:** Yes
    *   **Task 3.5:**
        *   **Task ID:** `I3.T5`
        *   **Description:** Implement the API routes and handlers for record CRUD and search, integrating the Validation Engine (`I3.T2`) for writes and the Filter Compiler (`I3.T4`) for search.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** OpenAPI spec (`I3.T1`), Validation Engine (`I3.T2`), Record DAL (`I3.T3`), Filter Compiler (`I3.T4`).
        *   **Input Files**: [`api/openapi.yaml`, `packages/core/`, `apps/api/src/lib/dal/records.ts`]
        *   **Target Files:** [`apps/api/src/routes/entities/`]
        *   **Deliverables:** Implemented API routes for records.
        *   **Acceptance Criteria:** Endpoints behave as specified. Validation errors are returned in the correct format. Search returns filtered results.
        *   **Dependencies:** [`I3.T1`, `I3.T2`, `I3.T3`, `I3.T4`]
        *   **Parallelizable:** No
    *   **Task 3.6:**
        *   **Task ID:** `I3.T6`
        *   **Description:** Implement the database triggers for FTS refresh (`records_fts_refresh`) and versioning (`records_versioning`) as new migration files.
        *   **Agent Type Hint:** `DatabaseAgent`
        *   **Inputs:** Section 6.6 of the manifest.
        *   **Input Files**: [`packages/db/migrations/`]
        *   **Target Files:** [`packages/db/migrations/0002_record_triggers.sql`]
        *   **Deliverables:** A new SQL migration file.
        *   **Acceptance Criteria:** The migration applies successfully. Updating a record correctly populates the `fts` column and creates an entry in `record_versions`.
        *   **Dependencies:** [`I1.T3`]
        *   **Parallelizable:** No

---

### Iteration 4: Frontend Foundation & Metadata UI

*   **Iteration ID:** `I4`
*   **Goal:** Set up the Next.js frontend application and build the UI for managing Entity Types and Field Definitions.
*   **Prerequisites:** `I3`
*   **Tasks:**
    *   **Task 4.1:**
        *   **Task ID:** `I4.T1`
        *   **Description:** Scaffold the Next.js application in `apps/web` using TypeScript. Set up basic project structure, including components, pages, and styles.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 15 of the manifest.
        *   **Input Files**: [`apps/web/`]
        *   **Target Files:** [`apps/web/src/`, `apps/web/package.json`, `apps/web/next.config.js`]
        *   **Deliverables:** A runnable Next.js application.
        *   **Acceptance Criteria:** The default Next.js page loads successfully in a browser.
        *   **Dependencies:** [`I1.T1`]
        *   **Parallelizable:** No
    *   **Task 4.2:**
        *   **Task ID:** `I4.T2`
        *   **Description:** Generate a typed API client using a tool like `openapi-typescript` and place it in the `packages/sdk` directory. Configure the frontend to use this SDK for all API calls.
        *   **Agent Type Hint:** `SetupAgent`
        *   **Inputs:** The OpenAPI spec from `I3.T1`.
        *   **Input Files**: [`api/openapi.yaml`]
        *   **Target Files:** [`packages/sdk/src/index.ts`]
        *   **Deliverables:** A TypeScript SDK package.
        *   **Acceptance Criteria:** The SDK is generated successfully and provides typed methods for all defined API endpoints.
        *   **Dependencies:** [`I3.T1`]
        *   **Parallelizable:** No
    *   **Task 4.3:**
        *   **Task ID:** `I4.T3`
        *   **Description:** Integrate TanStack Query (React Query) into the Next.js app for server state management. Configure a global query client provider.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Next.js app from `I4.T1`.
        *   **Input Files**: [`apps/web/src/pages/_app.tsx`]
        *   **Target Files:** [`apps/web/src/lib/query-client.ts`, `apps/web/src/pages/_app.tsx`]
        *   **Deliverables:** React Query setup.
        *   **Acceptance Criteria:** The `QueryClientProvider` is correctly configured at the root of the application.
        *   **Dependencies:** [`I4.T1`]
        *   **Parallelizable:** No
    *   **Task 4.4:**
        *   **Task ID:** `I4.T4`
        *   **Description:** Create the UI pages and components for listing, creating, and editing `Entity Types`. Use the generated SDK and React Query for data fetching and mutations.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** SDK from `I4.T2`.
        *   **Input Files**: [`packages/sdk/`, `apps/web/src/`]
        *   **Target Files:** [`apps/web/src/pages/admin/entity-types/`, `apps/web/src/components/entity-types/`]
        *   **Deliverables:** React components and pages for Entity Type management.
        *   **Acceptance Criteria:** Users can view a list of entity types, create a new one, and edit an existing one's label/description.
        *   **Dependencies:** [`I4.T2`, `I4.T3`]
        *   **Parallelizable:** No
    *   **Task 4.5:**
        *   **Task ID:** `I4.T5`
        *   **Description:** Create the UI pages and components for managing `Field Definitions` for a specific entity type.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** SDK from `I4.T2`.
        *   **Input Files**: [`packages/sdk/`, `apps/web/src/`]
        *   **Target Files:** [`apps/web/src/pages/admin/entity-types/[id].tsx`, `apps/web/src/components/field-defs/`]
        *   **Deliverables:** React components and pages for Field Definition management.
        *   **Acceptance Criteria:** Users can view, add, and edit fields for a selected entity type. The form should handle all `kind` options and validation rules.
        *   **Dependencies:** [`I4.T4`]
        *   **Parallelizable:** No

---

### Iteration 5: Frontend Dynamic Data UI

*   **Iteration ID:** `I5`
*   **Goal:** Implement the primary user-facing features: the dynamic data table and dynamic forms for viewing, searching, and editing records.
*   **Prerequisites:** `I4`
*   **Tasks:**
    *   **Task 5.1:**
        *   **Task ID:** `I5.T1`
        *   **Description:** Implement a dynamic table component using TanStack Table. The component should accept an `entityTypeKey`, fetch its `field_defs`, and render columns dynamically. It should also fetch data from the `/search` endpoint.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 15.2 of the manifest.
        *   **Input Files**: [`apps/web/src/`]
        *   **Target Files:** [`apps/web/src/components/dynamic-table/`, `apps/web/src/pages/entities/[entityTypeKey]/index.tsx`]
        *   **Deliverables:** A reusable dynamic table component and a page to display it.
        *   **Acceptance Criteria:** The table correctly displays columns and data for a given entity type. Basic server-side pagination works.
        *   **Dependencies:** [`I4.T5`]
        *   **Parallelizable:** No
    *   **Task 5.2:**
        *   **Task ID:** `I5.T2`
        *   **Description:** Implement a filter builder UI that allows users to construct a Filter DSL JSON object. This UI should be connected to the dynamic table to trigger searches.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 15.2 of the manifest.
        *   **Input Files**: [`apps/web/src/components/dynamic-table/`]
        *   **Target Files:** [`apps/web/src/components/filter-builder/`]
        *   **Deliverables:** A filter builder component.
        *   **Acceptance Criteria:** The component generates a valid Filter DSL object based on user input and refetches table data when the filter is applied.
        *   **Dependencies:** [`I5.T1`]
        *   **Parallelizable:** No
    *   **Task 5.3:**
        *   **Task ID:** `I5.T3`
        *   **Description:** Implement a dynamic form component using TanStack Form. The component should fetch `field_defs` and render the appropriate input fields (text, number, select, etc.) with client-side validation.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 15.3 of the manifest.
        *   **Input Files**: [`apps/web/src/`]
        *   **Target Files:** [`apps/web/src/components/dynamic-form/`]
        *   **Deliverables:** A reusable dynamic form component.
        *   **Acceptance Criteria:** The form renders correctly for different field kinds. Client-side validation provides immediate feedback.
        *   **Dependencies:** [`I4.T5`]
        *   **Parallelizable:** No
    *   **Task 5.4:**
        *   **Task ID:** `I5.T4`
        *   **Description:** Create pages for creating and editing records, integrating the dynamic form component. On submission, it should call the appropriate API endpoints.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Dynamic form from `I5.T3`.
        *   **Input Files**: [`apps/web/src/components/dynamic-form/`]
        *   **Target Files:** [`apps/web/src/pages/entities/[entityTypeKey]/new.tsx`, `apps/web/src/pages/entities/[entityTypeKey]/[recordId].tsx`]
        *   **Deliverables:** Pages for creating and editing records.
        *   **Acceptance Criteria:** Users can successfully create and update records. Server-side validation errors are displayed correctly on the form.
        *   **Dependencies:** [`I5.T3`]
        *   **Parallelizable:** No

---

### Iteration 6: Advanced Features & Authorization

*   **Iteration ID:** `I6`
*   **Goal:** Implement relationship management, real-time updates via SSE, and the complete authorization model (RBAC + Field ACLs).
*   **Prerequisites:** `I5`
*   **Tasks:**
    *   **Task 6.1:**
        *   **Task ID:** `I6.T1`
        *   **Description:** Update `api/openapi.yaml` to include endpoints for creating and deleting relations (`/relations`).
        *   **Agent Type Hint:** `DocumentationAgent`
        *   **Inputs:** Section 9.3 of the manifest.
        *   **Input Files**: [`api/openapi.yaml`]
        *   **Target Files:** [`api/openapi.yaml`]
        *   **Deliverables:** Updated OpenAPI YAML file.
        *   **Acceptance Criteria:** The spec is valid and includes the new relation management endpoints.
        *   **Dependencies:** [`I3.T1`]
        *   **Parallelizable:** No
    *   **Task 6.2:**
        *   **Task ID:** `I6.T2`
        *   **Description:** Implement the backend logic and API endpoints for creating and deleting `edges` (relations).
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** OpenAPI spec from `I6.T1`.
        *   **Input Files**: [`api/openapi.yaml`, `apps/api/src/`]
        *   **Target Files:** [`apps/api/src/routes/relations/`, `apps/api/src/lib/dal/edges.ts`]
        *   **Deliverables:** Implemented API routes for relations.
        *   **Acceptance Criteria:** Users can create and delete relationships between records. The `edges_validate` trigger prevents invalid relations.
        *   **Dependencies:** [`I6.T1`, `I2.T5`]
        *   **Parallelizable:** No
    *   **Task 6.3:**
        *   **Task ID:** `I6.T3`
        *   **Description:** Implement the `SSE Broadcaster` on the backend, which listens to Postgres `NOTIFY` events and forwards them to clients connected to a `GET /events` endpoint. Add `NOTIFY` calls to the database triggers.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 9.5 and 24.4 of the manifest.
        *   **Input Files**: [`apps/api/src/`, `packages/db/migrations/`]
        *   **Target Files:** [`apps/api/src/routes/events.ts`, `packages/db/migrations/0003_notify_triggers.sql`]
        *   **Deliverables:** SSE endpoint and updated DB triggers.
        *   **Acceptance Criteria:** Changes to records or edges emit a notification that is broadcast to connected SSE clients.
        *   **Dependencies:** [`I3.T6`]
        *   **Parallelizable:** No
    *   **Task 6.4:**
        *   **Task ID:** `I6.T4`
        *   **Description:** Integrate an SSE client into the frontend. On receiving events, invalidate the relevant React Query caches to trigger automatic data refetching and UI updates.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** SSE endpoint from `I6.T3`.
        *   **Input Files**: [`apps/web/src/`]
        *   **Target Files:** [`apps/web/src/hooks/use-sse.ts`, `apps/web/src/pages/_app.tsx`]
        *   **Deliverables:** Real-time UI updates.
        *   **Acceptance Criteria:** When a record is updated in one browser tab, the change is reflected in the data table in another tab without a manual refresh.
        *   **Dependencies:** [`I6.T3`, `I5.1`]
        *   **Parallelizable:** No
    *   **Task 6.5:**
        *   **Task ID:** `I6.T5`
        *   **Description:** Implement the authorization layer in the backend. This includes a middleware to parse JWTs and an authorization service that enforces RBAC and per-field ACLs on all relevant endpoints.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 10 of the manifest.
        *   **Input Files**: [`apps/api/src/`]
        *   **Target Files:** [`apps/api/src/plugins/auth.ts`, `apps/api/src/lib/authz.ts`]
        *   **Deliverables:** A comprehensive authorization system.
        *   **Acceptance Criteria:** API requests fail with 401/403 errors for users with insufficient permissions. Data returned from read endpoints is stripped of fields the user cannot see.
        *   **Dependencies:** [`I3.T5`]
        *   **Parallelizable:** No

## 5. Verification and Integration Strategy

*   **Testing Levels:**
    *   **Unit Tests:** Each package (`core`, `db`) and API module (DAL, services) will have comprehensive unit tests. The Filter Compiler and Validation Engine will be heavily unit-tested.
    *   **Integration Tests:** Tests will verify the interaction between API routes, services, and the database, including trigger functionality and RLS policies.
    *   **E2E Tests:** Playwright tests will cover the critical user journeys defined in Section 16 of the manifest, such as creating an entity type, adding records, and searching.
*   **CI/CD:** A CI pipeline will be set up to run on every commit/PR. Steps will include:
    1.  Linting and static analysis (ESLint).
    2.  Type checking (TypeScript).
    3.  Running all unit and integration tests.
    4.  Building all applications and packages.
    5.  (On merge to main) Building Docker images and deploying to a staging environment.
*   **Code Quality Gates:**
    *   All PRs must pass the CI pipeline.
    *   A minimum test coverage threshold (e.g., 80%) will be enforced.
    *   Code must be formatted with a tool like Prettier.
*   **Artifact Validation:**
    *   The OpenAPI specification will be linted and validated as part of the CI process.
    *   PlantUML and Mermaid diagrams will be reviewed during PRs to ensure they align with the implementation.

## 6. Glossary

*   **ACL:** Access Control List, optionally defined per field to control read/write permissions for different roles.
*   **DDMS:** Dynamic Data Management System, the name of the project.
*   **Drizzle:** A TypeScript ORM used for type-safe database access.
*   **Edge:** A record representing a relationship between two other records.
*   **Entity Type:** A template or schema for a type of record (e.g., "Project", "User").
*   **FieldDef:** Field Definition; metadata that describes a custom field.
*   **Filter DSL:** A JSON-based Domain-Specific Language for defining complex search queries.
*   **PlantUML:** A tool for creating UML diagrams from a plain text language.
*   **RLS:** Row-Level Security, a PostgreSQL feature used to enforce tenant data isolation.
*   **SSE:** Server-Sent Events, a web technology for pushing real-time updates from a server to a client.
*   **Zod:** A TypeScript-first schema declaration and validation library.